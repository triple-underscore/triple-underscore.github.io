<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Object Model (CSSOM) （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">

<style>
td:first-child, th:first-child {
	border-right: thin solid var(--pale-color);
}
tr{
	border-top: thin solid var(--pale-color);
}

thead > tr:first-child {
	border-top: none;
	border-bottom: medium solid var(--pale-color);
}

th[colspan]{
	padding: 0.5em;
}

b.cp-name {
	font-weight: normal;
	color: var(--K-color);
}

.xattr {
	color: var(--K-color);
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let ctx_ifc = '';
	let ctx_ifc1 = ''; // interface for 'm1'

	return this.html.replace(
		/❝.|%[~\w\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]){
	case '❝':
		key = (match.charCodeAt(1) + 0x1000000).toString(16).toUpperCase().slice(3);
		return (
`<span class="code-point">U+${key}</span> (<span class="char-symbol">${match[1]}</span>)`
		);
	default:
		return `<var>${match.slice(1)}</var>`;
	}
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'I':
	if(indicator === '@'){
		ctx_ifc = key;
	} else {
		ctx_ifc1 = key;
	}
	break;
case 'I1':
	ctx_ifc1 = key;
	return '';
	break;
//case 'mb': // IDL dictionary member
case 'm1':
case 'm':
	{
		const n = text.indexOf('(');
		if(n > 0){
			key = text.slice(0, n);
			text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
		}
		const ifc = ( klass === 'm1' ) ? ctx_ifc1: ctx_ifc
		href = `#dom-${ifc}-${key}`.toLowerCase();
	}
	break;
case 'mc':
	text = 'constructor';
	break;
case 'ps':
	text = `:${key}`;
	break;
case 'pe':
	text = `::${key}`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'td': // desc value type
	text = `&lt;'<code class="descriptor">${key}</code>'&gt;`;
	href = link_map[`d.${key}`];
	break;
case 'U0':
	text = `U+${key}`;
	break;
case 'E':
	href = `~WEBIDL#${key.toLowerCase()}`;
	break;
case 'l':
	return `"<code class="literal">${text}</code>"`;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}
return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:CSS Object Model (CSSOM)
spec_date:2025-05-02
trans_update:2025-05-03
source_checked:250502
page_state_key:CSS
original_url:https://drafts.csswg.org/cssom-1/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:cssom,css
conformance:css
copyright:2025,permissive
trans_1st_pub:2012-05-31


●●class_map
p:property
d:descriptor
ps:pseudo
pe:pseudo
v:value
t:type
td:type
css:css
e:element
a:attr
at:at-rule
E:error
h:header
U0:code-point
cn:cp-name

●●tag_map
p:code
d:code
ps:code
pe:code
I:code
m:code
m1:code
mA:code
e:code
E:code
a:code
at:code
h:code
css:code
xmlss:code
c:code
U0:span
cn:span
td:var
v:code
t:var
i:i
sub:sub
em:em
cite:cite

●●words_table1

XMLSS:xml-stylesheet-ja.html
	XMLSS:~TR/xml-stylesheet/

SP: <b class="cp-name">space</b> 
MediaList: <code>MediaList</code> 

camel_cased_attr:<var>camel_cased_attribute</var>
webkit_cased_attr:<var>webkit_cased_attribute</var>
dashed_attr:<var>dashed_attribute</var>
color_t:<var class="type">&lt;color&gt;</var>

●●words_table


	●fetch
LOCAL:
intranet::::イントラネット
	inputURL:input URL:入力~URL
give-up:give up

	●処理
持続的:persistent::~
更新あり:updated:~
構築元:constructor::~::コンストラクタ
back:
連結-:concatenate:~
	-:concatenation
	-:call
	~~変更:mutating
	変換する:convert／-
	入力:input／-
	On getting:
	On setting:
	%~URL:url
	%規則~list:rules
	%応答の処理n:processTheResponse
	%関数:func
	%内容:-
	%名前:-

	●CSS
CSSOM:
	~style付け:styling
ss:style sheet:::スタイルシート
important:
cascaded::::カスケード
	cascade法:cascading
全称:universal::~
単純-:simple::~
解像度:resolution:~
周波数:frequency:~
sRGB:
alpha:
宣言d:declared::宣言

	●構文
prolog::::プロローグ
surrogate::::サロゲート
辞書式:lexicographical:~
	規則集合
	宣言~群:declarations
基数:base:~
基数10:base-ten:10 進
dash:
	~dashを接頭する:dash prefix

	先頭を小文字~化する:lowercase first
	直列化-法:serializing
	直列化-済み:serialized
	構文解析-法:parsing
	きちんと:well-
	字下げ:indent

	●仕様
utility::::ユーティリティ
網羅的:exhaustive:~
仮想の:hypothetical:~
	~~詳細:specific／specificity
展開-:expand:~
仕事:work:~
改訂:revisions:~
機能:function:~
	registration
	~testし易さ:testability
必須の:required:~
復帰:reverting:~
切替えた:switchした:切り替えた
捕捉-:capture:~

	~~目的:oriented towards
	あるいは、:alternatively
	一方で:whereas
	各種用語／用語:terminology
	用例集:Examples
	略記:-
	備考:-
	明確:-
	規定:-
	可能:-
	~~状況:circumstance
	総称:
	必要
	呼称:-
	関心の欠如:lack of interest
	-:please
	-:hypothetical
	-:typically
	-:pattern
	-:local
	-:details
	-:resource
	穴:hole
	ありそう:sound-like
	~~犠牲に:regress
	見込みが高い:would likely
	-:teach
	処する:deal with
	任意選択で:may
	選んで:choice
	管理
	知る:tell
	-:consult
	-:lack
	-:reverse-engineer
	-:describe
	-:perform
	表す:signify
	同様に:akin to

	●未分類
注釈付き:annotated:~
	投出し直す:re-throw
	対応-:maps to／map to
	対応
封入-:enclose:~
	^en:backing list
生成元clean:origin-clean::生成元-clean::オリジン-clean
供与-:contribute:~
選択-:select::~
否定形:negated:~
分子成分:numerator:~
分母成分:denominator:~
MathML:
疑似属性:pseudo-attribute::~
ns:namespace::名前空間
	~ns接頭辞:namespace prefix
処理命令:processing instruction:~
macro::::マクロ
	type:::種別
null:
	inclusion:
	~chain:::チェイン
dot::::ドット
選択肢:option:~
最終-:final:~

	反復:-
	存続:-
	処理前後
	処理前:before
	処理後:after
	前置-:precede
	除外-:excluding／omitting
	~~混在: 1
	書かれ:write
	変換:〜to
	転換-:turn into
	呼ばれ／:named
	~~反映:updated as appropriate
	在る:is present
	可能:
	等価な〜関数:functional equivalent
	-:literal
	変数:-
	区別:-
	省略:-
	出力:output／
	別途
	進数
	小数部
	用途
	秒数
	種類:-
	一致:／
	入力:input
	利用:
	位置:position／
	minus
	per
	-:double bar
	-:join
	-:map
	-:pair
	-:certain
	-:translations
	-:syntactic
	-:reorder
	加えて:additionally
	-:appear
	-:different
	-:omit
	-:combine
	%~index 番:zero-index
	-:second
	以前:formerly
	唯一:only
	前後
	一方
	個数
	以外
	先頭
	一連
	以下
	任意
	個目の:second／third
	一部
	部分
	複数
	特定
	全体
	自身
	先行
	内部
	末尾
	該当
	後続
	当該
	個以上
	時点
	各種
	場合
	初回
	回目
	以上
	余分
	列目
	最短:short
	最短:shortest
	最短-形の:shortest form possible
	最短な形:shortest form possible
	限られた~~範囲:less-widely
	総数
	最高位:greatest 〜 order
	part
	最小個数:smallest possible
	-:earlier
	-:between
	以前:previous
	から:based
	1 個の:one
	末尾:the end
	混ざって:in between


●●original_id_map

ascii-case-insensitive:
whitespace:

serialize-a-css-longhands:
css-style-rule:

	多重 id
	dom-cssstyleproperties-camel-cased-attribute:dom-cssstyleproperties-camel_cased_attribute
	dom-cssstyleproperties-webkit-cased-attribute:dom-cssstyleproperties-webkit_cased_attribute
	dom-cssstyleproperties-dashed-attribute:dom-cssstyleproperties-dashed_attribute


●●mdn_urls
	http-default-style:HTTP/Headers/Default-Style

cssgroupingrule:API/CSSGroupingRule
	cssimportrule:API/CSSImportRule
	cssmarginrule:API/CSSMarginRule
cssnamespacerule:API/CSSNamespaceRule
cssomstring:API/CSSOMString
csspagerule:API/CSSPageRule
cssrule:API/CSSRule
cssrulelist:API/CSSRuleList
cssstyledeclaration:API/CSSStyleDeclaration
cssstylerule:API/CSSStyleRule
cssstylesheet:API/CSSStyleSheet
elementcssinlinestyle:API/ElementCSSInlineStyle
linkstyle:API/LinkStyle
medialist:API/MediaList
namespacedef-css:API/CSS
stylesheet:API/StyleSheet
stylesheetlist:API/StyleSheetList


●●link_map

	●IDL
CEReactions:~HEcustom#cereactions
LegacyNullToEmptyString:~WEBIDLjs#LegacyNullToEmptyString
SameObject:~WEBIDLjs#SameObject
PutForwards:~WEBIDLjs#PutForwards
NewObject:~WEBIDLjs#NewObject
Exposed:~WEBIDLjs#Exposed

E.TypeError:~WEBIDL#exceptiondef-typeerror
E.NotAllowedError:~WEBIDL#notallowederror
E.SyntaxError:~WEBIDL#syntaxerror

undefined:~WEBIDL#idl-undefined
long:~WEBIDL#idl-long
boolean:~WEBIDL#idl-boolean
Promise:~WEBIDL#idl-promise
unsigned short:~WEBIDL#idl-unsigned-short
unsigned long:~WEBIDL#idl-unsigned-long
USVString:~WEBIDL#idl-USVString
DOMString:~WEBIDL#idl-DOMString
CSSOMString:#cssomstring
ObservableArray:~WEBIDL#idl-observable-array

I.CSSOMString:#cssomstring
I.USVString:~WEBIDL#idl-USVString
I.DOMString:~WEBIDL#idl-DOMString

I.CSS:#namespacedef-css
I.CSSGroupingRule:#cssgroupingrule
I.CSSImportRule:#cssimportrule
I.CSSMarginRule:#cssmarginrule
I.CSSNamespaceRule:#cssnamespacerule
I.CSSPageDescriptors:#csspagedescriptors
I.CSSPageRule:#csspagerule
I.CSSRule:#cssrule
I.CSSRuleList:#cssrulelist
I.CSSStyleDeclaration:#cssstyledeclaration
I.CSSStyleProperties:#cssstyleproperties
I.CSSStyleRule:#cssstylerule
I.CSSStyleSheet:#cssstylesheet
I.CSSStyleSheetInit:#dictdef-cssstylesheetinit
I.ElementCSSInlineStyle:#elementcssinlinestyle
I.LinkStyle:#linkstyle
I.MediaList:#medialist
I.StyleSheet:#stylesheet
I.StyleSheetList:#stylesheetlist

I.CSSMediaRule:~CSSCOND#cssmediarule
I.CSSFontFaceRule:~CSSFONT#cssfontfacerule
I.CSSFontFeatureValuesRule:~CSSFONT#cssfontfeaturevaluesrule
I.CSSKeyframeRule:~CSSANIM#csskeyframerule
I.CSSKeyframesRule:~CSSANIM#csskeyframesrule
I.CSSSupportsRule:~CSSCOND#csssupportsrule
I.CSSCounterStyleRule:~CSSCOUNTER#csscounterstylerule

I.CSSPseudoElement:~CSSPSEUDO#csspseudoelement

I.Element:~DOM4#element
I.Document:~DOM4#document
I.DocumentOrShadowRoot:~DOM4#documentorshadowroot
I.Window:~WINDOW#window
I.HTMLElement:~HTMLdom#htmlelement
I.SVGElement:~SVGtypes#InterfaceSVGElement
I.MathMLElement:https://w3c.github.io/mathml-core/#dom-mathmlelement
I.ProcessingInstruction:~DOM4#processinginstruction

mc.CSSStyleSheet:#dom-cssstylesheet-cssstylesheet
m.new CSSStyleSheet:#dom-cssstylesheet-cssstylesheet

	m.cssText:#dom-cssstyledeclaration-csstext
	m.cssText:#dom-cssrule-csstext
m.mediaText:#dom-medialist-mediatext
m.StyleSheet.href:#dom-stylesheet-href
m.StyleSheet.media:#dom-stylesheet-media
m.CSS.escape:#dom-css-escape
m.getComputedStyle:#dom-window-getcomputedstyle
m.styleSheets:#dom-documentorshadowroot-stylesheets
m.adoptedStyleSheets:#dom-documentorshadowroot-adoptedstylesheets

m.~camel_cased_attr:#dom-cssstyleproperties-camel-cased-attribute
m.~webkit_cased_attr:#dom-cssstyleproperties-webkit-cased-attribute
m.~dashed_attr:#dom-cssstyleproperties-dashed-attribute

m.stringifier:#MediaList-stringification-behavior

mA.name:~CSSANIM#dom-csskeyframesrule-name
mA.keyText:~CSSANIM#dom-csskeyframerule-keytext
mA.style:~CSSANIM#dom-csskeyframerule-style

e.style:~HEmetadata#the-style-element

	●css
	＊t.selector:~SELECTORS4#typedef-selector
t.selector-list:~SELECTORS4#typedef-selector-list
t.pseudo-element-selector:~SELECTORS4#typedef-pseudo-element-selector
	selectors_group 生成規則:~TR/css3-selectors/#grammar
	// TODO
t.angle:~CSSVAL#angle-value
t.number:~CSSVAL#number-value
t.length:~CSSVAL#length-value
t.frequency:~CSSVAL#frequency-value
t.identifier:~CSSVAL#css-css-identifier
	~CSSSYN#typedef-ident-token
	~CSS22/syndata.html#value-def-identifier
t.integer:~CSSVAL#integer-value
t.percentage:~CSSVAL#percentage-value
t.resolution:~CSSVAL#resolution-value
t.string:~CSSVAL#string-value
t.time:~CSSVAL#time-value
t.url:~CSSVAL#url-value
t.family-name:~CSSFONT#family-name-value
t.color:~CSSCOLOR#typedef-color
t.page-selector-list:~CSSPAGE#typedef-page-selector-list
t.whitespace-token:~CSSSYN#typedef-whitespace-token
t.alpha-value:~CSSCOLOR#typedef-color-alpha-value
t.counter:~CSSLIST#typedef-counter
t.ratio:~CSSVAL#ratio-value
t.supports-condition:~CSSCOND#typedef-supports-condition
t.import-conditions:~CASCADE#typedef-import-conditions
t.block-contents:~CSSSYN#typedef-block-contents
t.page-selector-list:~CSSPAGE#typedef-page-selector-list

t.rect():~MASKING1#funcdef-clip-rect
	t.shape:~CSS22/visufx.html#value-def-shape
	~CSSSHAPE#typedef-basic-shape

	t.absolute-size:~XXXXX#typedef-
	t.border-width:~CSSBG#typedef-
		t.line-width:~CSSBG#typedef-line-width
	t.border-style:~CSSBG#typedef-
		t.line-style:~CSSBG#typedef-line-style
	t.bottom:~XXXXX#typedef-
	t.right:~XXXXX#typedef-
	t.left:~XXXXX#typedef-
	t.top:~XXXXX#typedef-
	t.generic-family:~CSSFONT#generic-family-value
	t.generic-voice:~CSSSPEECH#voice-family-generic-voice
	t.relative-size:~XXXXX#typedef-


p.line-height:~CSSINLINE#propdef-line-height
	p.line-height:~CSS2J#propdef-line-height
p.overflow:~CSSOVERFLOW3#propdef-overflow

p.width:~SIZING#propdef-width
p.height:~SIZING#propdef-height
p.margin-bottom:~CSSBOX#propdef-margin-bottom
p.margin-left:~CSSBOX#propdef-margin-left
p.margin-right:~CSSBOX#propdef-margin-right
p.margin-top:~CSSBOX#propdef-margin-top
p.margin:~CSSBOX#propdef-margin
p.padding-bottom:~CSSBOX#propdef-padding-bottom
p.padding-left:~CSSBOX#propdef-padding-left
p.padding-right:~CSSBOX#propdef-padding-right
p.padding-top:~CSSBOX#propdef-padding-top
p.padding:~CSSBOX#propdef-padding

p.block-size:~CSSLOGICAL#propdef-block-size
p.inline-size:~CSSLOGICAL#propdef-inline-size
p.margin-block-end:~CSSLOGICAL#propdef-margin-block-end
p.margin-block-start:~CSSLOGICAL#propdef-margin-block-start
p.margin-inline-end:~CSSLOGICAL#propdef-margin-inline-end
p.margin-inline-start:~CSSLOGICAL#propdef-margin-inline-start
p.padding-block-end:~CSSLOGICAL#propdef-padding-block-end
p.padding-block-start:~CSSLOGICAL#propdef-padding-block-start
p.padding-inline-end:~CSSLOGICAL#propdef-padding-inline-end
p.padding-inline-start:~CSSLOGICAL#propdef-padding-inline-start

p.inset-block-end:~CSSPOS#propdef-inset-block-end
p.inset-block-start:~CSSPOS#propdef-inset-block-start
p.inset-inline-end:~CSSPOS#propdef-inset-inline-end
p.inset-inline-start:~CSSPOS#propdef-inset-inline-start
p.bottom:~CSSPOS#propdef-bottom
p.left:~CSSPOS#propdef-left
p.right:~CSSPOS#propdef-right
p.top:~CSSPOS#propdef-top

p.display:~CSSDISP#propdef-display

p.border:~CSSBG#propdef-border
p.border-style:~CSSBG#propdef-border-style
p.border-color:~CSSBG#propdef-border-color
p.border-width:~CSSBG#propdef-border-width
p.border-bottom-color:~CSSBG#propdef-border-bottom-color
p.border-left-color:~CSSBG#propdef-border-left-color
p.border-right-color:~CSSBG#propdef-border-right-color
p.border-top-color:~CSSBG#propdef-border-top-color
	~CSSWG/css-borders-4/

p.border-block-end-color:~CSSLOGICAL#propdef-border-block-end-color
p.border-block-start-color:~CSSLOGICAL#propdef-border-block-start-color
p.border-inline-end-color:~CSSLOGICAL#propdef-border-inline-end-color
p.border-inline-start-color:~CSSLOGICAL#propdef-border-inline-start-color

p.font-size:~CSSFONT#propdef-font-size

p.background-color:~CSSBG#propdef-background-color

p.box-shadow:~CSSBG#propdef-box-shadow
p.caret-color:~CSSUI#propdef-caret-color
p.color:~CSSCOLOR#propdef-color
p.outline-color:~CSSUI#propdef-outline-color
p.-webkit-transform:~COMPAT#propdef--webkit-transform

	at.charset:~CSSSYN#at-ruledef-charset
at.import:~CASCADE#at-ruledef-import
at.media:~CSSCOND#at-ruledef-media
at.namespace:~CSSNS#at-ruledef-namespace
at.page:~CSSPAGE#at-ruledef-page
	at.font-face:~CSSFONT#at-font-face-rule

d.width:~MQ5#descdef-media-width
d.height:~MQ5#descdef-media-height
d.device-width:~MQ5#descdef-media-device-width
d.device-height:~MQ5#descdef-media-device-height
d.orientation:~MQ5#descdef-media-orientation
d.aspect-ratio:~MQ5#descdef-media-aspect-ratio
d.device-aspect-ratio:~MQ5#descdef-media-device-aspect-ratio
d.color:~MQ5#descdef-media-color
d.color-index:~MQ5#descdef-media-color-index
d.monochrome:~MQ5#descdef-media-monochrome
d.resolution:~MQ5#descdef-media-resolution
d.scan:~MQ5#descdef-media-scan
d.grid:~MQ5#descdef-media-grid

d.font-family:~CSSFONT#descdef-font-face-font-family
d.font-variant:~CSSFONT#descdef-font-face-font-variant
d.font-feature-settings:~CSSFONT#descdef-font-face-font-feature-settings
d.font-stretch:~CSSFONT#font-face-font-stretch
d.font-width:~CSSFONT#descdef-font-face-font-width
d.src:~CSSFONT#descdef-font-face-src
d.unicode-range:~CSSFONT#descdef-font-face-unicode-range
d.font-weight:~CSSFONT#descdef-font-face-font-weight
d.font-style:~CSSFONT#descdef-font-face-font-style
	d.font-variant:~TR/css-fonts-4/#descdef-font-face-font-variant

pe.before:~CSSPSEUDO#selectordef-before
pe.after:~CSSPSEUDO#selectordef-after
	~CSSWG/selectors-3/#sel-before
	~CSSWG/selectors-3/#sel-after
pe.slotted():~CSSSCOPING#selectordef-slotted
pe.part():~CSSSHADOWPARTS#selectordef-part

ps.lang():~SELECTORS4#lang-pseudo
ps.nth-child():~SELECTORS4#nth-child-pseudo
ps.nth-last-child():~SELECTORS4#nth-last-child-pseudo
ps.nth-of-type():~SELECTORS4#nth-of-type-pseudo
ps.nth-last-of-type():~SELECTORS4#nth-last-of-type-pseudo
ps.not():~SELECTORS4#negation-pseudo


	●
h.Default-Style:#http-default-style
	<code>Default-Style</code>
h.Link:~HTTPweblink#field.link
	h.Link:~RFCx/rfc5988#section-5

r.DOM:#biblio-whatwg-dom
r.ENCODING:#biblio-whatwg-encoding
r.URL:#biblio-whatwg-url

sub.大小無視:#ascii-case-insensitive

~CSS~ssを作成する:#create-a-css-style-sheet
~CSS~ssを追加する:#add-a-css-style-sheet
~CSS~ssを除去する:#remove-a-css-style-sheet

結付けられた~CSS~ss:#associated-css-style-sheet
媒体~query~collection:#medialist-collection-of-media-queries
	compare-media-queries:比較
媒体~queryを比較する:#compare-media-queries
~MediaList~objを作成する:#create-a-medialist-object
~CSS~ss~list:#documentorshadowroot-document-or-shadow-root-css-style-sheets
最終-~CSS~ss~list:#documentorshadowroot-final-css-style-sheets

解決d値:#resolved-value
解決d値は特別:#resolved-value-special-case-property
~CSS規則:#css-rule
~CSS規則~listに規則を挿入する:#insert-a-css-rule
~CSS規則~listから規則を除去する:#remove-a-css-rule

~supportされる~CSS~prop:#supported-css-property
~CSS~prop名に変換する:#idl-attribute-to-css-property
~IDL属性~名に変換する:#css-property-to-idl-attribute

~style属性を更新する:#update-style-attribute-for
指定d順序:#concept-declarations-specified-order
選好d順序:#concept-shorthands-preferred-order

~CSS~ss:#css-style-sheet
持続的~CSS~ss:#persistent-css-style-sheet
~CSS宣言を設定する:#set-a-css-declaration

	//css-declaration-
~CSS宣言:#css-declaration
~CSS宣言~block:#css-declaration-block
~prop名:#css-declaration-property-name
値:#css-declaration-value
~importantか:#css-declaration-important-flag
文字大小区別か:#css-declaration-case-sensitive-flag

	//cssstyledeclaration-
dB.算出-済みか:#cssstyledeclaration-computed-flag
dB.読専か:#cssstyledeclaration-readonly-flag
dB.宣言~群:#cssstyledeclaration-declarations
dB.親~CSS規則:#cssstyledeclaration-parent-css-rule
dB.所有者~node:#cssstyledeclaration-owner-node
dB.更新-中か:#cssstyledeclaration-updating-flag

	//concept-css-style-sheet_
ss.種別:#concept-css-style-sheet-type
ss.所在:#concept-css-style-sheet-location
ss.親~CSS~ss:#concept-css-style-sheet-parent-css-style-sheet
ss.所有者~node:#concept-css-style-sheet-owner-node
ss.所有者~CSS規則:#concept-css-style-sheet-owner-css-rule
ss.媒体:#concept-css-style-sheet-media
ss.~title:#concept-css-style-sheet-title
ss.代替-か:#concept-css-style-sheet-alternate-flag
ss.不能化されるか:#concept-css-style-sheet-disabled-flag
ss.~CSS規則~list:#concept-css-style-sheet-css-rules
ss.生成元cleanか:#concept-css-style-sheet-origin-clean-flag
ss.構築子を経たか:#concept-css-style-sheet-constructed-flag
ss.改変は許容しないか:#concept-css-style-sheet-disallow-modification-flag
ss.構築元~文書:#concept-css-style-sheet-constructor-document
ss.~ss基底~URL:#concept-css-style-sheet-stylesheet-base-url

	構築-済みな~CSSStyleSheetを作成する:#create-a-constructed-cssstylesheet
	→ new CSSStyleSheet
	~CSS規則~群を同期的に置換する:#synchronously-replace-the-rules-of-a-cssstylesheet
	→ replaceSync

	//escape-a-
文字を符号位置として~escapeする:#escape-a-character-as-code-point
文字を~escapeする:#escape-a-character

	//parse-a-
~CSS宣言~blockとして構文解析する:#parse-a-css-declaration-block
~CSS~page選択子~listとして構文解析する:#parse-a-list-of-css-page-selectors
~CSS規則として構文解析する:#parse-a-css-rule
~CSS値として構文解析する:#parse-a-css-value
選択子~listとして構文解析する:#parse-a-group-of-selectors
媒体~query~listとして構文解析する:#parse-a-media-query-list
媒体~queryとして構文解析する:#parse-a-media-query

	// concept-css-rule_
親~規則:#concept-css-rule-parent-css-rule
親~ss:#concept-css-rule-parent-css-style-sheet
~text:#concept-css-rule-text
種別:#concept-css-rule-type
子~規則~list:#concept-css-rule-child-css-rules

	// serialize-a-
~commaで分離して直列化する:#serialize-a-comma-separated-list
空白で分離して直列化する:#serialize-a-whitespace-separated-list
識別子を直列化する:#serialize-an-identifier
宣言~群を直列化する:#serialize-a-css-declaration-block
~CSS宣言を直列化する:#serialize-a-css-declaration
~CSS~page選択子~listを直列化する:#serialize-a-list-of-css-page-selectors

~CSS規則を直列化する:#serialize-a-css-rule
~CSS成分~値を直列化する:#serialize-a-css-component-value
~CSS値を直列化する:#serialize-a-css-value
下位prop~listを直列化する:#serialize-a-css-longhands
選択子~listを直列化する:#serialize-a-group-of-selectors
媒体~特能~値を直列化する:#serialize-a-media-feature-value
媒体~query~listを直列化する:#serialize-a-media-query-list
媒体~queryを直列化する:#serialize-a-media-query
選択子を直列化する:#serialize-a-selector
単純-選択子を直列化する:#serialize-a-simple-selector
関数を直列化する:#css-serialize-a-function
文字列を直列化する:#serialize-a-string
~CSS~URLに直列化する:#serialize-a-url
~LOCALに直列化する:#serialize-a-local

	// *-css-style-sheet-set-
~CSS~ss集合:#css-style-sheet-set
~CSS~ss集合~名:#css-style-sheet-set-name
可能化された~CSS~ss集合:#enabled-css-style-sheet-set
~CSS~ss集合を可能化する:#enable-a-css-style-sheet-set
~CSS~ss集合を選択する:#select-a-css-style-sheet-set
ss.選択した:#select-a-css-style-sheet-set
最後の~CSS~ss集合~名:#last-css-style-sheet-set-name
選好される~CSS~ss集合~名:#preferred-css-style-sheet-set-name
選好される~CSS~ss集合~名を変更する:#change-the-preferred-css-style-sheet-set-name

~CSS~ss資源を~fetchする:#fetch-a-css-style-sheet
	unset:#unset
	set:#set


~supportされる~style付け言語:#supported-styling-language
~CSS~style規則:#css-style-rule
~prolog:#prolog


	●用語（ CSS
正準的~順序:#_canonical-order

~CSS~pixel:~CSSVAL#px
~CSS識別子:~CSSVAL#css-css-identifier
~keyword:~CSSVAL#css-keyword
~CSS全域~keyword:~CSSVAL#css-wide-keywords

有位置:~CSSPOS#positioned-box

~cascaded値:~CASCADE#cascaded-value
指定d値:~CASCADE#specified-value
宣言d値:~CASCADE#declared-value
算出d値:~CASCADE#computed-value
使用~値:~CASCADE#used-value
略式~prop:~CASCADE#shorthand-property
下位prop:~CASCADE#longhand
~cascade層:~CASCADE#cascade-layers
ly.名前:~CASCADE#layer-name

選択子:~SELECTORS4#selector
選択子~list:~SELECTORS4#selector-list
	group of selectors:
結合子:~SELECTORS4#selector-combinator
複階-選択子:~SELECTORS4#complex
複合-選択子:~SELECTORS4#compound
単純-選択子:~SELECTORS4#simple
全称~選択子:~SELECTORS4#universal-selector
属性~選択子:~SELECTORS4#attribute-selector
ID 選択子:~SELECTORS4#id-selector
型~選択子:~SELECTORS4#type-selector
~class選択子:~SELECTORS4#class-selector
疑似類:~SELECTORS4#pseudo-class
疑似要素:~SELECTORS4#pseudo-element

~ns接頭辞:~CSSNS#namespace-prefix
既定の~ns:~CSSNS#default-namespace
~null~ns:~CSSNS#null-namespace
	~CSSNS#terminology
~ns名:~CSSNS#declaration

入子な宣言~列が成す規則:~CSSNESTING#nested-declarations-rule

媒体~型:~MQ5#media-type
媒体~query:~MQ5#media-query
媒体~query~list:~MQ5#media-query-list
媒体~特能:~MQ5#media-feature

~page選択子:~CSSPAGE#page-selectors
~margin~at-規則:~CSSPAGE#margin-at-rules


空白:~CSSSYN#whitespace
無視される:~CSSSYN#css-ignored
	無視される:~CSS22/syndata.html#ignore
環境~符号化法:~CSSSYN#environment-encoding
文法に則って構文解析-:~CSSSYN#css-parse-something-according-to-a-css-grammar

規則を構文解析する:~CSSSYN#parse-a-rule
~stylesheetの内容を構文解析する:~CSSSYN#parse-a-stylesheets-contents
~blockの内容を構文解析する:~CSSSYN#parse-a-blocks-contents
成分~値~listを構文解析する:~CSSSYN#parse-a-list-of-component-values

~custom~prop:~CSSVAR#custom-property
~custom~prop名:~CSSVAR#custom-property
無効が保証される値:~CSSVAR#guaranteed-invalid-value

平坦~tree:~CSSSCOPING#flat-tree

論理-~prop~group:~CSSLOGICAL#logical-property-group
対応付け~logic:~CSSLOGICAL#mapping-logic

	●用語（外部

xml-stylesheet 処理命令:~XMLSS#dt-xml-stylesheet
疑似属性:~XMLSS#dt-pseudo-attribute
xmlss.charset:~XMLSS#PA-charset
xmlss.href:~XMLSS#PA-href
xmlss.title:~XMLSS#PA-title
xmlss.alternate:~XMLSS#PA-alternate
xmlss.type:~XMLSS#PA-type
xmlss.media:~XMLSS#PA-media

~supportする~prop~index:~WEBIDL#dfn-supported-property-indices
識別子:~WEBIDL#dfn-identifier
観測-可能な配列~属性の有index値を設定する:~WEBIDL#observable-array-attribute-set-an-indexed-value
~backしている~list:~WEBIDL#observable-array-attribute-backing-list

~list:~INFRA#list
~size:~INFRA#list-size
~cloneする:~INFRA#list-clone
除去する:~INFRA#list-remove
付加する:~INFRA#list-append
set.付加する:~INFRA#set-append
符号単位:~INFRA#code-unit
~surrogate:~INFRA#surrogate
	符号位置:~INFRA#code-point
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII大文字~化する:~INFRA#ascii-uppercase
~ASCII 16 進~数字（小文字）:~INFRA#ascii-lower-hex-digit
連結する:~INFRA#string-concatenate
文字大小区別:~INFRA#string-is
	https://w3c.github.io/i18n-glossary/#dfn-case-sensitive

新たな~promise:~WEBIDLjs#a-new-promise
~promiseを却下する:~WEBIDLjs#reject
~promiseを解決する:~WEBIDLjs#resolve

~field値:~HTTPinfra#field-value

~labelから符号化法を取得する:~ENCODING#concept-encoding-get

~URL:~URL1#concept-url
絶対~URL文字列:~URL1#absolute-url-string
~URL構文解析する:~URL1#concept-url-parser
~URLを直列化する:~URL1#concept-url-serializer

~fetching:~FETCH#concept-fetch
~fetch:~FETCH#concept-fetch
i.応答の本体~終了~時の処理n:~FETCH#fetch-processresponseendofbody
応答:~FETCH#concept-response
~network~error:~FETCH#concept-network-error
要請:~FETCH#concept-request
rq.~URL:~FETCH#concept-request-url
rq.生成元:~FETCH#concept-request-origin
rq.~referrer:~FETCH#concept-request-referrer

~tree順序:~DOM4#concept-tree-order
文書~tree内:~DOM4#in-a-document-tree
過去互換~mode:~DOM4#concept-document-quirks
~node文書:~DOM4#concept-node-document
子:~DOM4#concept-tree-child
doc.~URL:~DOM4#concept-document-url
	~address:~DOM4#concept-document-url
	~address:~HTMLdom#the-document%27s-address
~node:~DOM4#concept-node
~data:~DOM4#concept-cd-data
内容~属性:~DOM4#concept-attribute
	投出:~DOM4#concept-throw
先行-:~DOM4#concept-tree-preceding
後続:~DOM4#concept-tree-following
文書:~DOM4#concept-document
doc.符号化法:~DOM4#concept-document-encoding
属性~変更-時の手続き:~DOM4#concept-element-attributes-change-ext
属性を~nsと局所~名により取得する:~DOM4#concept-element-attributes-get-by-namespace
属性~値を設定する:~DOM4#concept-element-attributes-set-value
接続されて:~DOM4#connected
~shadowも含めた根:~DOM4#concept-shadow-including-root

並列的:~HTMLINFRA#in-parallel
~HTML要素:~HTMLINFRA#html-elements

~CORS同一-生成元:~HTMLurl#cors-same-origin
文書~基底~URL:~HTMLurl#document-base-url
	誤）lO.基底~URL:~HEmetadata#link-options-base-url

Content-Type ~metadata:~HTMLurl#content-type

生成元:~ORIGIN#concept-origin

現在の大域~obj:~WAPI#current-global-object
結付けられた文書:~WINDOW#concept-document-window
~scriptを阻んでいる~ss:~HEmetadata#a-style-sheet-that-is-blocking-scripts
~scriptを阻んでいる~ssを供与して:~HEmetadata#contributes-a-script-blocking-style-sheet
~scriptを阻んでいる~ss集合:~HEmetadata#script-blocking-style-sheet-set
閲覧~文脈:~HTMLds#browsing-context
~top-level閲覧~文脈:~HTMLds#top-level-browsing-context
属する閲覧~文脈:~HTMLds#concept-document-bc
bc.容器:~BROWSERS#bc-container
閲覧~文脈~容器:~BROWSERS#browsing-context-container
具現化されて:~HTMLrendering#being-rendered

●●ref_key_map
CSS3CONDITIONAL:CSSCONDITIONAL3
CSS3CASCADE:CSSCASCADE3
CSS3PAGE:CSSPAGE3
CSS3SYN:CSSSYNTAX3
MEDIAQUERIES:MEDIAQUERIES4

●●ref_normative

[CSS-ANIMATIONS-1]
    David Baron; et al. ＜CSS Animations Level 1＞. URL: https://drafts.csswg.org/css-animations/
[CSS-BACKGROUNDS-3]
    Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. URL: https://drafts.csswg.org/css-backgrounds/
[CSS-BORDERS-4]
    ＜CSS Borders and Box Decorations Module Level 4＞. Editor's Draft. URL: https://drafts.csswg.org/css-borders-4/
[CSS-BOX-4]
    Elika Etemad. ＜CSS Box Model Module Level 4＞. URL: https://drafts.csswg.org/css-box-4/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-COLOR-4]
    Chris Lilley; Tab Atkins Jr.; Lea Verou. ＜CSS Color Module Level 4＞. URL: https://drafts.csswg.org/css-color-4/
[CSS-COLOR-5]
    Chris Lilley; et al. ＜CSS Color Module Level 5＞. URL: https://drafts.csswg.org/css-color-5/
[CSS-COUNTER-STYLES-3]
    Tab Atkins Jr.. ＜CSS Counter Styles Level 3＞. URL: https://drafts.csswg.org/css-counter-styles/
[CSS-DISPLAY-4]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Display Module Level 4＞. URL: https://drafts.csswg.org/css-display/
[CSS-FONTS-4]
    Chris Lilley. ＜CSS Fonts Module Level 4＞. URL: https://drafts.csswg.org/css-fonts-4/
[CSS-FONTS-5]
    Chris Lilley. ＜CSS Fonts Module Level 5＞. URL: https://drafts.csswg.org/css-fonts-5/
[CSS-INLINE-3]
    Elika Etemad. ＜CSS Inline Layout Module Level 3＞. URL: https://drafts.csswg.org/css-inline-3/
[CSS-LISTS-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Lists and Counters Module Level 3＞. URL: https://drafts.csswg.org/css-lists-3/
[CSS-LOGICAL-1]
    Rossen Atanassov; Elika Etemad. ＜CSS Logical Properties and Values Level 1＞. URL: https://drafts.csswg.org/css-logical-1/
[CSS-NAMESPACES-3]
    Elika Etemad. ＜CSS Namespaces Module Level 3＞. URL: https://drafts.csswg.org/css-namespaces/
[CSS-NESTING-1]
    Tab Atkins Jr.; Adam Argyle. ＜CSS Nesting Module＞. URL: https://drafts.csswg.org/css-nesting/
[CSS-OVERFLOW-3]
    Elika Etemad; Florian Rivoal. ＜CSS Overflow Module Level 3＞. URL: https://drafts.csswg.org/css-overflow-3/
[CSS-POSITION-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Positioned Layout Module Level 3＞. URL: https://drafts.csswg.org/css-position-3/
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Scoping Module Level 1＞. URL: https://drafts.csswg.org/css-scoping/
[CSS-SHADOW-PARTS-1]
    Tab Atkins Jr.; Fergal Daly. ＜CSS Shadow Parts＞. URL: https://drafts.csswg.org/css-shadow-parts/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. URL: https://drafts.csswg.org/css-sizing-3/
[CSS-UI-4]
    Florian Rivoal. ＜CSS Basic User Interface Module Level 4＞. URL: https://drafts.csswg.org/css-ui-4/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-VARIABLES-1]
    Tab Atkins Jr.. ＜CSS Custom Properties for Cascading Variables Module Level 1＞. URL: https://drafts.csswg.org/css-variables/
[CSS-VARIABLES-2]
    ＜CSS Custom Properties for Cascading Variables Module Level 2＞. Editor's Draft. URL: https://drafts.csswg.org/css-variables-2/
[CSS21]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSS3-CONDITIONAL]
    Chris Lilley; David Baron; Elika Etemad. ＜CSS Conditional Rules Module Level 3＞. URL: https://drafts.csswg.org/css-conditional-3/
[CSS3CASCADE]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 3＞. URL: https://drafts.csswg.org/css-cascade-3/
[CSS3PAGE]
    Elika Etemad. ＜CSS Paged Media Module Level 3＞. URL: https://drafts.csswg.org/css-page-3/
[CSS3SYN]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ENCODING]
    Anne van Kesteren. ＜Encoding Standard＞. Living Standard. URL: https://encoding.spec.whatwg.org/
[FETCH]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[I18N-GLOSSARY]
    Richard Ishida; Addison Phillips. ＜Internationalization Glossary＞. URL: https://w3c.github.io/i18n-glossary/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MathML-Core]
    David Carlisle; Frédéric Wang. ＜MathML Core＞. URL: https://w3c.github.io/mathml-core/
[MEDIAQUERIES]
    Florian Rivoal; Tab Atkins Jr.. ＜Media Queries Level 4＞. URL: https://drafts.csswg.org/mediaqueries-4/
[MEDIAQUERIES-5]
    Dean Jackson; et al. ＜Media Queries Level 5＞. URL: https://drafts.csswg.org/mediaqueries-5/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-3]
    Tantek Çelik; et al. ＜Selectors Level 3＞. URL: https://drafts.csswg.org/selectors-3/
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[SVG2]
    Amelia Bellamy-Royds; et al. ＜Scalable Vector Graphics (SVG) 2＞. URL: https://svgwg.org/svg2-draft/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/
[XML]
    Tim Bray; et al. ＜Extensible Markup Language (XML) 1.0 (Fifth Edition)＞. 26 November 2008. REC. URL: https://www.w3.org/TR/xml/
[XML-STYLESHEET]
    James Clark; Simon Pieters; Henry Thompson. ＜Associating Style Sheets with XML documents 1.0 (Second Edition)＞. 28 October 2010. REC. URL: https://www.w3.org/TR/xml-stylesheet/

●●ref_informative

[COMPAT]
    Mike Taylor. ＜Compatibility Standard＞. Living Standard. URL: https://compat.spec.whatwg.org/
[SVG11]
    Erik Dahlström; et al. ＜Scalable Vector Graphics (SVG) 1.1 (Second Edition)＞. 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Object Model (CSSOM)</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/cssom-1/
公表履歴
	https://www.w3.org/standards/history/cssom-1/
旧公表バージョン
	https://www.w3.org/TR/2000/REC-DOM-Level-2-Style-20001113/

フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/cssom-1">CSSWG Issues Repository</a>

編集
	<a href="mailto:daniel.glazman@disruptive-innovations.com">Daniel Glazman</a> (<a href="http://disruptive-innovations.com/">Disruptive Innovations</a>)
	<a href="mailto:emilio@mozilla.com">Emilio Cobos Álvarez</a> (Mozilla)
前任編集者
	<a href="mailto:simonp@opera.com">Simon Pieters</a> (Opera Software AS)
	<a href="https://www.w3.org/wiki/User:Gadams">Glenn Adams</a> (Cox Communications, Inc.) <a href="mailto:glenn.adams@cos.com">glenn.adams@cos.com</a>
	<a href="https://annevankesteren.nl/">Anne van Kesteren</a> (Opera Software ASA) <a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/cssom-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/cssom-1

旧来の課題リスト
	<a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=CSS&amp;component=CSSOM&amp;resolution=---">Bugzilla</a>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>CSS オブジェクトモデル（ CSSOM ） — CSS Object Model</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
~CSSOMは、
`Media Queries^cite, `Selectors^cite, および~CSS自身のための（汎用の構文解析／直列化の規則も含めた）~APIを定義する。
◎
CSSOM defines APIs (including generic parsing and serialization rules) for Media Queries, Selectors, and of course CSS itself.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、
編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
この文書は <abbr title="Cascading Style Sheet">CSS</abbr> Object Model
（以下， “<abbr title="CSS Object Model">CSSOM</abbr>” ）
の中核を成す特能を正式に指定する。
~CSSOMに基づく他の仕様, および他の~CSSに関係する仕様は、
これらの特能に対する拡張を定義する。
◎
This document formally specifies the core features of the CSS Object Model (CSSOM). Other documents in the CSSOM family of specifications as well as other CSS related specifications define extensions to these core features.
</p>

<p>
~CSSOMの中核をなす特能は、
作者~定義な~scriptから~styleに関係する状態~情報への~accessおよび操作を可能にするための，基本的な能力を供することを~~目的とする。
◎
The core features of the CSSOM are oriented towards providing basic capabilities to author-defined scripts to permit access to and manipulation of style related state information and processes.
</p>

<p>
以下で定義される特能は、
~W3C~DOM~WGの手による先行の仕様
— 首に `DOM$r —
に基づいている。
この文書の目的は：
◎
The features defined below are fundamentally based on prior specifications of the W3C DOM Working Group, primarily [DOM].＼
The purposes of the present document are＼
</p>
<ul>
	<li>
（~testし易さと相互運用能を改善するため）より技術的な~~詳細を供して，先行の仕事を改善する。
◎
(1) to improve on that prior work by providing more technical specificity (so as to improve testability and interoperability),＼
</li>
	<li>
限られた~~範囲にしか実装されておらず，
この文脈において もはや本質的とは見なされていない一部の特能を、
非推奨にする, または除去する。
◎
(2) to deprecate or remove certain less-widely implemented features no longer considered to be essential in this context, and＼
</li>
	<li>
広く実装されてきている, あるいはそうなるものと予期されている，ある種の拡張を新たに指定する。
◎
(3) to newly specify certain extensions that have been or expected to be widely implemented.
</li>
</ul>

	</section>
	<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

<p>
加えて、
次に挙げる記法も利用する：
</p>

<ul>
	<li>
~SP は、
`1 個の^em［
文字 `0020^U0 `SPACE^cn
］を表す。
</li>
	<li>
原文には明言されていないが、
この仕様に現れる改行文字（ `newline^en ）は，
おそらく `000A^U0 (LF) を指す。
</li>
	<li>
`大小無視@sub
— この表記が添えられた［
~EQ／~NEQ／~IN／~NIN
］は、
`~ASCII大小無視$による比較に基づくことを意味する。
</li>
	<li>
`Document$I ~objを指して，単に`文書$とも記すことにする。
</li>
	<li>
整数~index %~index に対する “%~index 番” という表記は、
0 番から数えるとする。
</li>
	<li>
原文の語 `group of selectors^en （ “選択子たちが成す~group” ）は，
`Selectors Level 3^cite までの呼称によるが、
この訳では， `Selectors Level 4^cite に基づく呼称 “選択子~list”
（ `list of selectors^en ）
に変更している。
</li>
	<li>
~prop（特に，この仕様においては、略式~prop）に対する
`正準的~順序@
とは、
その~propの定義~表tに指示されるそれを表す。
</li>
</ul>

	</section>
	<section id="terminology">
<h2 title="Terminology">2. 各種用語</h2>

<p>
この仕様は、
次に挙げる文書の各種用語を使役している
⇒
`DOM$r
`HTML$r
`CSS3SYN$r
`ENCODING$r
`URL$r
`FETCH$r
`XML-STYLESHEET$r
`XML$r
◎
This specification employs certain terminology from the following documents: DOM, HTML, CSS Syntax, Encoding, URL, Fetch, Associating Style Sheets with XML documents and XML. [DOM] [HTML] [CSS3SYN] [ENCODING] [URL] [FETCH] [XML-STYLESHEET] [XML]
◎
When this specification talks about object A where A is actually an interface, it generally means an object implementing interface A.
◎
The terms set and unset to refer to the true and false values of binary flags or variables, respectively. These terms are also used as verbs in which case they refer to mutating some value to make it true or false, respectively.
</p>

<p>
`~supportされる~style付け言語@
は~CSSを指す。
◎
The term supported styling language refers to CSS.
</p>

<p class="note">注記：
UA が他の~style付け言語も~supportするようになった場合，この仕様も必要に応じて更新されることが予期されている。
◎
Note: If another styling language becomes supported in user agents, this specification is expected to be updated as necessary.
</p>

<p>
`~supportされる~CSS~prop@
は、
~UAが実装する~CSS~propであって，~vendor接頭辞~付きの~propも含まれるが、
`~custom~prop$は除外される。
`~supportされる~CSS~prop$は、
この仕様における比較~目的においては，小文字~化するモノトスル。
◎
The term supported CSS property refers to a CSS property that the user agent implements, including any vendor-prefixed properties, but excluding custom properties. A supported CSS property must be in its lowercase form for the purpose of comparisons in this specification.
</p>

<p>
この仕様においては、
どの要素にも［
`before$pe, `after$pe
］疑似要素は存在するものと見做される
— それ用の~boxは生成されないとしても。
◎
In this specification the ::before and ::after pseudo-elements are assumed to exist for all elements even if no box is generated for them.
</p>

<p>
~IDL~interface~member（~method／属性）が別の~memberを~callするとき†は、
~UAは，~memberの内部~APIを呼出すモノトスル
— すなわち、
作者は~custom ECMAScript［
~prop／関数
］で上書きして，~memberのふるまいを変更することはできない。
【† この訳においては、 “~obj上の `foo^m ~method手続き( 引数… )” （ `foo^m は~memberの名前）のように記される。】
◎
When a method or an attribute is said to call another method or attribute, the user agent must invoke its internal API for that attribute or method so that e.g. the author can’t change the behavior by overriding attributes or methods with custom properties or functions in ECMAScript.
</p>

<p>
他が言明されない限り、
文字列の比較は `文字大小区別$で行われる。
◎
Unless otherwise stated, string comparisons are done in a case-sensitive manner.
</p>

		<section id="common-serializing-idioms">
<h3 title="Common Serializing Idioms">2.1. 直列化-時の成句的な手続き</h3>

<div class="algo">
<p>
`文字を~escapeする@
~algoは、
所与の
( 文字 %c )
に対し
⇒
~RET 次を順に`連結する$
⇒＃
❝\,
%c
◎
To escape a character means to create a string of "\" (U+005C), followed by the character.
</p>
</div>

<div class="algo">
<p>
`文字を符号位置として~escapeする@
~algoは、
所与の
( 文字 %c )
に対し
⇒
~RET 次を順に`連結する$
⇒＃
❝\,
基数 16 の下で， %c の Unicode 符号位置を最小個数の`~ASCII 16 進~数字（小文字）$で表現する文字~並び,
~SP
◎
To escape a character as code point means to create a string of "\" (U+005C), followed by the Unicode code point as the smallest possible number of hexadecimal digits in the range 0-9 a-f (U+0030 to U+0039 and U+0061 to U+0066) to represent the code point in base 16, followed by a single SPACE (U+0020).
</p>
</div>

<div class="algo">
<p>
`識別子を直列化する@
~algoは、
所与の
( 文字列 %入力 )
に対し：
◎
To serialize an identifier means to create a string represented by the concatenation of, for each character of the identifier:
</p>

<p class="trans-note">【
これは`~CSS識別子$を作成する。
】</p>

<ol>
	<li>
~IF［
%入力 ~EQ ❝-
］
⇒
~RET `文字を~escapeする$( ❝- )
◎
↓↓</li>
	<li>
%結果 ~LET 空~文字列
◎
↑</li>
	<li>
<p>
%入力 を成す
~EACH( 文字 %c )
に対し，先頭から順に
⇒
%結果 に［
%c に応じて，次に与える文字列
］を付加する：
◎
↑</p>
		<dl class="switch">
			<dt>`0000^U0 `NULL^cn</dt>
			<dd>
`FFFD^U0 `REPLACEMENT CHARACTER^cn
◎
If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
</dd>

			<dt>`0001^U0 〜 `001F^U0</dt>
			<dt>`007F^U0</dt>
			<dd>
`文字を符号位置として~escapeする$( %c )
◎
If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F, then the character escaped as code point.
</dd>

			<dt>❝0 〜 ❝9</dt>
			<dd>
				<ol>
					<li>
~IF［
これは初回の~~反復である
］
⇒
`文字を符号位置として~escapeする$( %c )
</li>
					<li>
~ELIF［
これは 2 回目の~~反復である
］~AND［
%入力 の最初の文字 ~EQ ❝-
］
⇒
`文字を~escapeする$( %c )
</li>
					<li>
~ELSE
⇒
%c
</li>
			</ol>
◎
If the character is the first character and is in the range [0-9] (U+0030 to U+0039), then the character escaped as code point.
◎
If the character is the second character and is in the range [0-9] (U+0030 to U+0039) and the first character is a "-" (U+002D), then the character escaped as code point.
◎
↓
◎
↑↑
If the character is the first character and is a "-" (U+002D), and there is no second character, then the escaped character.
</dd>

			<dt>`0080^U0 以上</dt>
			<dt>❝-</dt>
			<dt>❝_</dt>
			<dt>❝A 〜 ❝Z</dt>
			<dt>❝a 〜 ❝z</dt>
			<dd>
%c
◎
If the character is not handled by one of the above rules and is greater than or equal to U+0080, is "-" (U+002D) or "_" (U+005F), or is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to U+005A), or [a-z] (U+0061 to U+007A), then the character itself.
</dd>

			<dt>その他</dt>
			<dd>
`文字を~escapeする$( %c )
◎
Otherwise, the escaped character.
</dd>

		</dl>
	</li>
	<li>
~RET %結果
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
`関数を直列化する@
~algoは、
所与の
( %関数 )
に対し：
</p>
<ol>
	<li>
%名前 ~LET `~ASCII小文字~化する$( `識別子を直列化する$( %関数 の名前 ) )
</li>
	<li>
%内容 ~LET %関数 の内容を %関数 の定義により指定されたとおり
— あるいは【指定されてないならば】，
（`~CSS値を直列化する$~algoにより捕捉される原則と同様に）
最短な形に —
直列化した結果
</li>
	<li>
~RET 次を順に`連結する$
⇒＃
%名前,
❝(,
%内容,
❝)
</li>
</ol>
◎
To serialize a function func, returning a string:
• Let s be an empty string.
• Serialize an identifier from func’s name, ASCII lowercased, and append the result to s.
• Append "(" (U+0028) to s.
• Serialize func’s contents, either as specified by the definition of func, or in the shortest form possible (akin to the principles captured by serialize a CSS value). Append the result to s.
• Append ")" (U+0029) to s.
• Return s.
</div>

<div class="algo">
<p>
`文字列を直列化する@
~algoは、
所与の
( 文字列 %入力 )
に対し：
◎
To serialize a string means＼
</p>

<p class="trans-note">【
これは、
`string$t 値を作成する。
】</p>

<ol>
	<li>
%結果 ~LET ❝"
◎
to create a string represented by '"' (U+0022), followed by＼
</li>
	<li>
<p>
%入力 を成す
~EACH( 文字 %c )
に対し，先頭から順に
⇒
%結果 に［
%c に応じて，次に与える文字列
］を付加する
⇒＃
`0000^U0 NULL ならば `FFFD^U0 `REPLACEMENT CHARACTER^cn ／
{ `0001^U0 〜 `001F^U0, `007F^U0 } ならば `文字を符号位置として~escapeする$( %c ) ／
{ ❝", ❝\ } ならば `文字を~escapeする$( %c ) ／
~ELSE_  %c
◎
the result of applying the rules below to each character of the given string, followed by '"' (U+0022):
◎
If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
◎
If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F, the character escaped as code point.
◎
If the character is '"' (U+0022) or "\" (U+005C), the escaped character.
◎
Otherwise, the character itself.
</li>
	<li>
%結果 に ❝" を付加する
◎
↑</li>
	<li>
~RET %結果
◎
↑</li>
</ol>

<p class="note">注記：
❝' は~escapeされない。
文字列は常に ❝" で括られた~~形で直列化されるので。
◎
Note: "'" (U+0027) is not escaped because strings are always serialized with '"' (U+0022).
</p>
</div>

<div class="algo">
<p>
`~CSS~URLに直列化する@
~algoは、
所与の
( 文字列 %~URL )
に対し
⇒
~RET 次を順に`連結する$
⇒＃
`url(^l,
`文字列を直列化する$( %~URL ),
❝)
◎
To serialize a URL means to create a string represented by "url(", followed by the serialization of the URL as a string, followed by ")".
</p>
</div>

<div class="algo">
<p>
`~LOCALに直列化する@
~algoは、
所与の
( 文字列 %local )
に対し
⇒
~RET 次を順に`連結する$
⇒＃
`local(^l,
`文字列を直列化する$( %local ),
❝)
◎
To serialize a LOCAL means to create a string represented by "local(", followed by the serialization of the LOCAL as a string, followed by ")".
</p>
</div>

<div class="algo">
<p>
`~commaで分離して直列化する@
~algoは、
所与の
( 文字列~list %~list )
に対し
⇒
~RET %~list を `, ^l （すなわち［
❝, ~SP
］並び）で`連結する$
◎
To serialize a comma-separated list concatenate all items of the list in list order while separating them by ", ", i.e., COMMA (U+002C) followed by a single SPACE (U+0020).
</p>
</div>

<div class="algo">
<p>
`空白で分離して直列化する@
~algoは、
所与の
( 文字列~list %~list )
に対し
【この用語は利用されていない】
⇒
~RET %~list を ~SP で`連結する$
◎
To serialize a whitespace-separated list concatenate all items of the list in list order while separating them by " ", i.e., a single SPACE (U+0020).
</p>

<p class="note">注記：
上の規則に則って~listを直列化する際には、
その先頭／末尾に余分な空白は挿入されない。
他が言明されない限り、
空~listは，空~文字列に直列化される。
◎
Note: When serializing a list according to the above rules, extraneous whitespace is not inserted prior to the first item or subsequent to the last item. Unless otherwise specified, an empty list is serialized as the empty string.
</p>
</div>

		</section>
	</section>
	<section id="cssomstring-type">
<h2 title="CSSOMString">3. `CSSOMString^I</h2>

<p>
~CSSOM~interfaceにおいては、
ほとんどの文字列に
`CSSOMString@I
型が利用される。
各~実装は、
それを［
`USVString$I, `DOMString$I
］いずれかとして定義することを選ぶことになる：
◎
Most strings in CSSOM interfaces use the CSSOMString type. Each implementation chooses to define it as either USVString or DOMString:
</p>

<pre class="idl">
typedef `USVString$ CSSOMString;
</pre>

<p>
あるいは：
◎
Or, alternatively:
</p>

<pre class="idl">
typedef DOMString CSSOMString;
</pre>

<div class="note">

<p>
注記：
この相違が~web内容から観測-可能になるのは、
`~surrogate$符号単位が孕まれるときに限られる。
`DOMString$I は それらを保全する一方で、
`USVString$I は それらを `FFFD^U0 `REPLACEMENT CHARACTER^cn に置換する。
◎
The difference is only observable from web content when surrogate code units are involved. DOMString would preserve them, whereas USVString would replace them with U+FFFD REPLACEMENT CHARACTER.
</p>

<p>
実装は、
実質的に，この置換を行うか行わないか選べることになる。
◎
This choice effectively allows implementations to do this replacement, but does not require it.
</p>

<p>
`USVString$I を利用すれば、
実装は，~memory内で文字列を内部的に表現するときに~UTF-8を利用-可能になる。
特定的には，`~surrogate$符号位置は、
きちんと形成された~UTF-8には許容されないので，実質的にこの置換が要求される。
◎
Using USVString enables an implementation to use UTF-8 internally to represent strings in memory. Since well-formed UTF-8 specifically disallows surrogate code points, it effectively requires this replacement.
</p>

<p>
他方，文字列を 16 ~bitな`符号単位$として内部的に表現する実装は、
この置換を行う~cost避けることを選好するかもしれない。
◎
On the other hand, implementations that internally represent strings as 16-bit code units might prefer to avoid the cost of doing this replacement.
</p>
</div>

	</section>
	<section id="media-queries">
<h2 title="Media Queries">4. 媒体~query</h2>

<p>
`媒体~query$は `MEDIAQUERIES$r にて定義される。
この節では、
~APIや直列化~形も含めた，`媒体~query$を取り巻く種々の概念を定義する。
◎
Media queries are defined by [MEDIAQUERIES]. This section defines various concepts around media queries, including their API and serialization form.
</p>

		<section id="parsing-media-queries">
<h3 title="Parsing Media Queries">4.1. 媒体~queryの構文解析-法</h3>

<div class="algo">
<p>
`媒体~query~listとして構文解析する@
~algoは
`MEDIAQUERIES$r にて定義される
【`参照＠~MQ5#mq-syntax$】
。
それは、
所与の
( `媒体~query~list$用の文字列 )
に対し，`媒体~query$たちが成す~listを返す。
◎
To parse a media query list for a given string s into a media query list is defined in the Media Queries specification. Return the list of media queries that the algorithm defined there gives.
</p>

<p class="note">注記：
結果が “無視される” `媒体~query$は、
`not all^l に転換されることになる。
◎
Note: A media query that ends up being "ignored" will turn into "not all".
</p>
</div>

<div class="algo">
<p>
`媒体~queryとして構文解析する@
~algoは、
所与の
( 文字列 %文字列 )
に対し，［
~NULL ／ `媒体~query$
］を返す：
◎
To parse a media query for a given string s means to follow＼
</p>
<ol>
	<li>
%~query~list ~LET `媒体~query~listとして構文解析する$( %文字列 )
◎
the parse a media query list steps and＼
</li>
	<li>
~IF［
%~query~list の`~size$ ~NEQ 1
］
⇒
~RET ~NULL
◎
return null if more than one media query is returned or＼
</li>
	<li>
~RET %~query~list[ 0 ]
◎
a media query if a single media query is returned.
</li>
</ol>

<p class="note">注記：
ここでも， “無視される” `媒体~query$は、
`not all^l に転換されることになる。
◎
Note: Again, a media query that ends up being "ignored" will turn into "not all".
</p>
</div>

		</section>
		<section id="serializing-media-queries">
<h3 title="Serializing Media Queries">4.2. 媒体~queryの直列化-法</h3>

<div class="algo">
<p>
`媒体~query~listを直列化する@
~algoは、
所与の
( `媒体~query~list$ %~list )
に対し：
</p>

<ol>
	<li>
%結果~list ~LET %~list 内の各~itemに
`媒体~queryを直列化する$
を適用して得られる同順の~list
</li>
	<li>
~RET `~commaで分離して直列化する$( %結果~list )
</li>
</ol>

◎
To serialize a media query list run these steps:
• If the media query list is empty, then return the empty string.
• Serialize each media query in the list of media queries, in the same order as they appear in the media query list, and then serialize the list.
</div>

<div class="algo">
<p>
`媒体~queryを直列化する@
~algoは、
所与の
( `媒体~query$ %媒体~query )
に対し：
◎
To serialize a media query let s be the empty string, run the steps below:
</p>

<ol>
	<li>
%文字列 ~LET 空~文字列
◎
↑</li>
	<li>
~IF［
%媒体~query は否定形である
］
⇒
%文字列 に次を順に付加する
⇒＃
`not^l,
~SP
◎
If the media query is negated append "not", followed by a single SPACE (U+0020), to s.
</li>
	<li>
%型 ~LET `~ASCII小文字~化する$( `識別子を直列化する$( %媒体~query の`媒体~型$ ) )
◎
Let type be the serialization as an identifier of the media type of the media query, converted to ASCII lowercase.
</li>
	<li>
~IF［
%媒体~query に`媒体~特能$を包含していない
］
⇒
~RET 次を順に`連結する$
⇒＃
%文字列,
%型
◎
If the media query does not contain media features append type, to s, then return s.
</li>
	<li>
~IF［
%型 ≠ `all^l
］~OR［
%媒体~query は否定形である
］
⇒
%文字列 に次を順に付加する
⇒＃
%型,
~SP,
`and^l,
~SP
◎
If type is not "all" or if the media query is negated append type, followed by a single SPACE (U+0020), followed by "and", followed by a single SPACE (U+0020), to s.
</li>
	<li>
<p>
%媒体~query を成す
~EACH( `媒体~特能$ %特能 )
に対し：
◎
Then, for each media feature:
</p>
		<ol>
			<li>
%文字列 に次を順に付加する
⇒＃
❝(,
`~ASCII小文字~化する$( %特能 の名前 )
◎
Append a "(" (U+0028), followed by the media feature name, converted to ASCII lowercase, to s.
</li>
			<li>
~IF［
%特能 に値は与えられている
］
⇒
%文字列 に次を順に付加する
⇒＃
❝:,
~SP,
`媒体~特能~値を直列化する$( %特能 の値 )
◎
If a value is given append a ":" (U+003A), followed by a single SPACE (U+0020), followed by the serialized media feature value, to s.
</li>
			<li>
%文字列 に ❝) を付加する
◎
Append a ")" (U+0029) to s.
</li>
			<li>
~IF［
この~~反復は最後でない
］
⇒
%文字列 に次を順に付加する
⇒＃
~SP,
`and^l,
~SP
◎
If this is not the last media feature append a single SPACE (U+0020), followed by "and", followed by a single SPACE (U+0020), to s.
</li>
		</ol>
	</li>
	<li>
~RET %文字列
◎
Return s.
</li>
</ol>
</div>

<div class="example">
<p>
例を示す（長い行は折り~~返されている）：
◎
Here are some examples of input (first column) and output (second column):
</p>

<table><thead>
<tr><th>入力
<th>出力
<tbody>

<tr><td>`not screen and (min-WIDTH:5px) AND (max-width:40px)^css
<td>`not screen and (min-width: 5px) and (max-width: 40px)^css

<tr><td>`all and (color) and (color)^css
<td>`(color) and (color)^css
</table>
</div>

			<section id="serializing-media-feature-values">
<h4 title="Serializing Media Feature Values">4.2.1. 媒体~特能~値の直列化-法</h4>

<p class="issue">
これは~CSS値の直列化に対応付けることを通して定義されるべきであろう
— その上で，`媒体~特能$については~CSS値を通して定義されるように。
◎
This should probably be done in terms of mapping it to serializing CSS values as media features are defined in terms of CSS values after all.
</p>

<p>
`媒体~特能~値を直列化する@
~algoは、
所与の
( 名前 %v の`媒体~特能$の値 )
に対し
⇒
~RET ［
次の表tの 1 列目にて %v に一致する行の 2 列目に与える形式
］を利用して直列化した結果：
◎
To serialize a media feature value named v locate v in the first column of the table below and use the serialization format described in the second column:
</p>

<div>
<table>
<caption>
【表t内の "..." は、未策定を表すと見受けられる。】
</caption>
<thead>
<tr><th>`媒体~特能$
<th>直列化
<tbody><tr><td>`width$d
<td>...

<tr><td>`height$d
<td>...

<tr><td>`device-width$d
<td>...

<tr><td>`device-height$d
<td>...

<tr><td>`orientation$d
<td>
値に応じて
⇒＃
`portrait^v ならば `portrait^l ／
`landscape^v ならば `landscape^l
<tr><td>`aspect-ratio$d
<td>...

<tr><td>`device-aspect-ratio$d
<td>...

<tr><td>`color$d
<td>...

<tr><td>`color-index$d
<td>...

<tr><td>`monochrome$d
<td>...

<tr><td>`resolution$d
<td>...

<tr><td>`scan$d
<td>
値に応じて
⇒＃
`progressive^v ならば `progressive^l ／
`interlace^v ならば `interlace^l
<tr><td>`grid$d
<td>...
</table>
◎
Media Feature｜Serialization
width｜...
height｜...
device-width｜...
device-height｜...
orientation｜If the value is portrait: "portrait". If the value is landscape: "landscape".
aspect-ratio｜...
device-aspect-ratio｜...
color｜...
color-index｜...
monochrome｜...
resolution｜...
scan｜If the value is progressive: "progressive". If the value is interlace: "interlace".
grid｜... 
</div>

<p>
他の仕様は、
この表tを拡張できる。
また，~vendor接頭辞~付きの`媒体~特能$は、
~customな直列化~形式を持ち得る。
◎
Other specifications can extend this table and vendor-prefixed media features can have custom serialization formats as well.
</p>

			</section>
		</section>
		<section id="comparing-media-queries">
<h3 title="Comparing Media Queries">4.3. 媒体~queryの比較-法</h3>

<p>
`媒体~queryを比較する@
~algoは、
所与の
2 個の`媒体~query$ ( %m1, %m2 )
に対し
⇒
~RET ~IS［
`媒体~queryを直列化する$( %m1 ) ~EQ `媒体~queryを直列化する$( %m2 )
］
◎
To compare media queries m1 and m2 means to serialize them both and return true if they are a case-sensitive match and false if they are not.
</p>
		</section>
		<section id="the-medialist-interface">
<h3 title="The MediaList Interface">4.4. `MediaList^I ~interface</h3>

<p>
`MediaList$I ~interfaceを実装する~objには，
`媒体~query~collection@
が結付けられる。
◎
An object that implements the MediaList interface has an associated collection of media queries.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `MediaList@I {
  `stringifier@m attribute [`LegacyNullToEmptyString$] `CSSOMString$ `mediaText$m;
  readonly attribute `unsigned long$ `length$m;
  getter `CSSOMString$? `item$m(`unsigned long$ %index);
  `undefined$ `appendMedium$m(`CSSOMString$ %medium);
  `undefined$ `deleteMedium$m(`CSSOMString$ %medium);
};
</pre>

<p>
~objが`~supportする~prop~index$は、
0 以上［
~collectionで表現される`媒体~query~collection$に含まれている媒体~queryの総数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of media queries in the collection of media queries represented by the collection. If there are no such media queries, then there are no supported property indices.
</p>

<div class="algo">
<p>
`~MediaList~objを作成する@
~algoは、
所与の
( 文字列 %~text )
に対し：
◎
To create a MediaList object with a string text, run the following steps:
</p>

<ol>
	<li>
%MediaList ~LET 新たな `MediaList$I ~obj
◎
Create a new MediaList object.
</li>
	<li>
%MediaList の `mediaText$m 属性 ~SET %~text
◎
Set its mediaText attribute to text.
</li>
	<li>
~RET %MediaList
◎
Return the newly created MediaList object.
</li>
</ol>
</div>

<p>
`mediaText@m
の：
◎
↓</p>
<ul>
	<li class="algo">
取得子~手続きは
⇒
~RET `媒体~query~listを直列化する$( コレの`媒体~query~collection$ )
◎
The mediaText attribute, on getting, must return a serialization of the collection of media queries.＼
</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
Setting the mediaText attribute must run these steps:
</p>
		<ol>
			<li>
コレの`媒体~query~collection$を空にする
◎
Empty the collection of media queries.
</li>
			<li>
~IF［
所与の値 ~EQ 空~文字列
］
⇒
~RET
◎
If the given value is the empty string, then return.
</li>
			<li>
コレの`媒体~query~collection$に，次の結果を成す すべての媒体~queryを付加する
⇒
`媒体~query~listとして構文解析する$( 所与の値 )
◎
Append all the media queries as a result of parsing the given value to the collection of media queries.
</li>
		</ol>
	</li>
</ul>

<div class="algo">
`item(index)@m
~method手続きは
⇒
~RET ［
%index が範囲~外ならば ~NULL ／
~ELSE_ 次の結果
］
⇒
`媒体~query~listを直列化する$( コレの`媒体~query~collection$内の %index 番の`媒体~query$ )
◎
The item(index) method must return a serialization of the media query in the collection of media queries given by index, or null, if index is greater than or equal to the number of media queries in the collection of media queries.
</div>

<div class="algo">
`length@m
取得子~手続きは
⇒
~RET コレの`媒体~query~collection$に含まれる`媒体~query$の個数
◎
The length attribute must return the number of media queries in the collection of media queries.
</div>

<div class="algo">
<p>
`appendMedium(medium)@m
~method手続きは：
◎
The appendMedium(medium) method must run these steps:
</p>
<ol>
	<li>
%m ~LET `媒体~queryとして構文解析する$( %medium )
◎
Let m be the result of parsing the given value.
</li>
	<li>
~IF［
%m ~EQ ~NULL
］
⇒
~RET
◎
If m is null, then return.
</li>
	<li>
コレの`媒体~query~collection$を成す
~EACH( %n )
に対し
⇒
~IF［
`媒体~queryを比較する$( %m, %n ) ~EQ ~T
］
⇒
~RET
◎
If comparing m with any of the media queries in the collection of media queries returns true, then return.
</li>
	<li>
コレの`媒体~query~collection$に %m を付加する
◎
Append m to the collection of media queries.
</li>
</ol>
</div>

<div class="algo">
<p>
`deleteMedium(medium)@m
~method手続きは：
◎
The deleteMedium(medium) method must run these steps:
</p>
<ol>
	<li>
%m ~LET `媒体~queryとして構文解析する$( %medium )
◎
Let m be the result of parsing the given value.
</li>
	<li>
~IF［
%m ~EQ ~NULL
］
⇒
~RET
◎
If m is null, then return.
</li>
	<li>
%除去されたか ~LET ~F
◎
↓</li>
	<li>
コレの`媒体~query~collection$を成す
~EACH( %n )
に対し
⇒
~IF［
`媒体~queryを比較する$( %m, %n ) ~EQ ~T
］
⇒＃
%n をコレの`媒体~query~collection$から除去する；
%除去されたか ~SET ~T
◎
Remove any media query from the collection of media queries for which comparing the media query with m returns true.＼
</li>
	<li>
~IF［
%除去されたか ~EQ ~F
］
⇒
~THROW `NotFoundError$E
◎
If nothing was removed, then throw a NotFoundError exception.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="selectors">
<h2 title="Selectors">5. 選択子</h2>

<p>
`選択子$は `Selectors^cite 仕様にて定義される。
この節では主にそれらを直列化する方法を定義する。
◎
Selectors are defined in the Selectors specification. This section mainly defines how to serialize them.
</p>

		<section id="parsing-selectors">
<h3 title="Parsing Selectors">5.1. 選択子の構文解析-法</h3>

<div class="algo">
<p>
`選択子~listとして構文解析する@
~algoは、
所与の
( 文字列 %値 )
に対し：
</p>

<ol>
	<li>
%結果 ~LET %値 を `selector-list$t の`文法に則って構文解析-$した結果 
</li>
	<li>
~RET［
%結果 ~NEQ `失敗^i ならば %結果 ／
~ELSE_ ~NULL
］
</li>
</ol>

◎
To parse a group of selectors means to parse the value using the selectors_group production defined in the Selectors specification and return either a group of selectors if parsing did not fail or null if parsing did fail.
</div>

		</section>
		<section id="serializing-selectors">
<h3 title="Serializing Selectors">5.2. 選択子の直列化-法</h3>

<div class="algo">
<p>
`選択子~listを直列化する@
~algoは、
所与の
( `選択子~list$ %~list )
に対し
⇒
~RET `~commaで分離して直列化する$( %~list 内の各~itemに `選択子を直列化する$を適用して得られる同順の~list )
◎
To serialize a group of selectors serialize each selector in the group of selectors and then serialize a comma-separated list of these serializations.
</p>
</div>

<div class="algo">
<p>
`選択子を直列化する@
~algoは、
所与の
( `複階-選択子$ %複階-選択子 )
に対し，文字列を返す：
◎
To serialize a selector＼
</p>
<ol>
	<li>
%結果 ~LET 空~文字列
◎
let s be the empty string,＼
</li>
	<li>
<p>
%複階-選択子 を成す
~EACH( `複合-選択子$ %複合-選択子 )
に対し，順に：
◎
run the steps below for each part of the chain of the selector, and finally return s:
</p>
		<ol>
			<li>
~IF［
%複合-選択子 は 1 個の`全称~選択子$のみからなる
］
⇒
%結果 に次を付加する
⇒
`単純-選択子を直列化する$( %複合-選択子 )
◎
If there is only one simple selector in the compound selectors which is a universal selector, append the result of serializing the universal selector to s.
</li>
			<li>
~ELSE
⇒
%複合-選択子 を成す
~EACH( `単純-選択子$ %単純-選択子 )
に対し
⇒
~IF［
%単純-選択子 は`全称~選択子$でない
］~OR［
%単純-選択子 の`~ns接頭辞$は`既定の~ns$でない~nsに対応する
］
⇒
%結果 に次を付加する
⇒
`単純-選択子を直列化する$( %単純-選択子 )
◎
Otherwise, for each simple selector in the compound selectors that is not a universal selector of which the namespace prefix maps to a namespace that is not the default namespace serialize the simple selector and append the result to s.
</li>
			<li>
<p>
~IF［
%複合-選択子 は %複階-選択子 内の最後の`複合-選択子$でない
］：
</p>
				<ol>
					<li>
%結果 に ~SP を付加する
</li>
					<li>
%結合子 ~LET %複合-選択子 と次の`複合-選択子$の合間にある`結合子$
</li>
					<li>
~IF［
%結合子 は ~SP のみでない
］
⇒
%結果 に次を順に付加する
⇒＃
%結合子,
~SP
</li>
				</ol>

◎
If this is not the last part of the chain of the selector append a single SPACE (U+0020), followed by the combinator "&gt;", "+", "~", "&gt;&gt;", "||", as appropriate, followed by another single SPACE (U+0020) if the combinator was not whitespace, to s.
</li>
			<li>
~ELIF［
%複合-選択子 内に`疑似要素$がある
］
⇒
%結果 に次を順に付加する
⇒＃
`::^l,
その疑似要素の名前
◎
If this is the last part of the chain of the selector and there is a pseudo-element, append "::" followed by the name of the pseudo-element, to s.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
`単純-選択子を直列化する@
~algoは、
所与の
( `単純-選択子$ %選択子 )
に対し，
%選択子 の種別に応じて：
◎
To serialize a simple selector let s be the empty string, run the steps below, and finally return s:
</p>

<dl class="switch">
	<dt>`型~選択子$</dt>
	<dt>`全称~選択子$</dt>
	<dd>
		<ol>
			<li>
%名前 ~LET %選択子 に応じて
⇒＃
`型~選択子$であるならば `識別子を直列化する$( 要素~名 ) ／
`全称~選択子$であるならば ❝*
</li>
			<li>
%接頭辞 ~LET %選択子 の`~ns接頭辞$
</li>
			<li>
~IF［
%接頭辞 に対応する~ns ~EQ `既定の~ns$
］
⇒
~RET %名前
</li>
			<li>
%接頭辞 ~SET %接頭辞 に対応する~nsに応じて
⇒＃
`~null~ns$ならば空~文字列／
~ELSE_ `識別子を直列化する$( %接頭辞 )
</li>
			<li>
~RET 次を順に`連結する$
⇒＃
%接頭辞,
❝|,
%名前
</li>
		</ol>
◎
If the namespace prefix maps to a namespace that is not the default namespace and is not the null namespace (not in a namespace) append the serialization of the namespace prefix as an identifier, followed by a "|" (U+007C) to s.
◎
If the namespace prefix maps to a namespace that is the null namespace (not in a namespace) append "|" (U+007C) to s.
◎
If this is a type selector append the serialization of the element name as an identifier to s.
◎
If this is a universal selector append "*" (U+002A) to s.
</dd>

	<dt>`属性~選択子$</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET ❝[
◎
Append "[" (U+005B) to s.
</li>
			<li>
%接頭辞 ~LET %選択子 の`~ns接頭辞$
◎
↓</li>
			<li>
~IF［
%接頭辞 は`~null~ns$でない~nsに対応する
］
⇒
%結果 に次を順に付加する
⇒＃
`識別子を直列化する$( %接頭辞 ),
❝|
◎
If the namespace prefix maps to a namespace that is not the null namespace (not in a namespace) append the serialization of the namespace prefix as an identifier, followed by a "|" (U+007C) to s.
</li>
			<li>
%結果 に次を付加する
⇒
`識別子を直列化する$( %選択子 の属性~名 )
◎
Append the serialization of the attribute name as an identifier to s.
</li>
			<li>
<p>
~IF［
%選択子 に属性~値が指定されている
］：
</p>

				<ol>
					<li>
%結果 に［
%選択子 （`属性~選択子$）の種別に応じて，次のいずれか適切なもの
］を付加する
⇒＃
❝=,
`~=^l,
`|=^l,
"<code class="literal">^=</code>",
"<code class="literal">$=</code>",
`*=^l
</li>
					<li>
%結果 に次を付加する
⇒
`文字列を直列化する$( %選択子 の属性~値 )
</li>
			</ol>
◎
If there is an attribute value specified, append "=", "~=", "|=", "^=", "$=", or "*=" as appropriate (depending on the type of attribute selector), followed by the serialization of the attribute value as a string, to s.
</li>
			<li>
<p>
~IF［
属性~選択子 `has the case-sensitivity flag present^en†
］
⇒
%結果 に次を順に付加する
⇒＃
~SP,
❝i
◎
If the attribute selector has the case-sensitivity flag present, append " i" (U+0020 U+0069) to s.
</p>

<p class="trans-note">【†
属性~値の`文字大小は区別されない＠~SELECTORS4#attribute-case$ならば真
— “`case-sensitivity^en” と意味が正反対であるが。
】</p>

</li>

			<li>
%結果 に ❝] を付加する
◎
Append "]" (U+005D) to s.
</li>
			<li>
~RET %結果
◎
↑</li>
		</ol>
	</dd>

	<dt>`~class選択子$</dt>
	<dd>
~RET 次を順に`連結する$
⇒＃
❝.,
`識別子を直列化する$( %選択子 の class 名 )
◎
Append a "." (U+002E), followed by the serialization of the class name as an identifier to s.
</dd>

	<dt>`ID 選択子$</dt>
	<dd>
~RET 次を順に`連結する$
⇒＃
❝#,
`識別子を直列化する$( %選択子 の ID )
◎
Append a "#" (U+0023), followed by the serialization of the ID as an identifier to s.
</dd>

	<dt>`疑似類$</dt>
	<dd>
		<ol>
			<li>
%名前 ~LET 次を順に`連結する$
⇒＃
❝:,
%選択子 （`疑似類$）の名前
◎
↓</li>
			<li>
~IF［
%選択子 は引数をとる`疑似類$でない
］
⇒
~RET %名前
◎
If the pseudo-class does not accept arguments append ":" (U+003A), followed by the name of the pseudo-class, to s.
◎
Otherwise, append ":" (U+003A), followed by the name of the pseudo-class,＼
</li>
			<li>
<p>
%内容 ~LET %選択子 に応じて：
◎
↓ followed by "(" (U+0028),＼
followed by the value of the pseudo-class argument(s) determined as per below,＼
↓ followed by ")" (U+0029), to s.
</p>
				<dl class="switch">
					<dt>`lang()$ps</dt>
					<dd>
`~commaで分離して直列化する$( 各 引数に`文字列を直列化する$ を適用して得られる同順の~list )
◎
The serialization of a comma-separated list of each argument’s serialization as a string, preserving relative order.
</dd>

					<dt>`nth-child()$ps</dt>
					<dt>`nth-last-child()$ps</dt>
					<dt>`nth-of-type()$ps</dt>
					<dt>`nth-last-of-type()$ps</dt>
					<dd>
`CSS3SYN$r <a href="~CSSSYN#serializing-anb">§ `an+b^t の直列化-法</a>
を利用して，引数を直列化した結果
◎
The result of serializing the value using the rules to serialize an &lt;an+b&gt; value.
</dd>
					<dd class="trans-note">【
これらの疑似類の引数には "`of …^css" 以下を成す部分もあるが、
ここには述べられていない。
】</dd>

					<dt>`not()$ps</dt>
					<dd>
`選択子~listを直列化する$( 引数たち )
◎
The result of serializing the value using the rules for serializing a group of selectors.
</dd>
				</dl>
			</li>
			<li>
~RET 次を順に`連結する$
⇒＃
%名前,
❝(,
%内容,
❝)
◎
↑</li>
		</ol>
	</dd>
</dl>
</div>

		</section>
	</section>
	<section id="css-object-model">
<h2 title="CSS">6. ~CSS</h2>

		<section id="css-style-sheets">
<h3 title="CSS Style Sheets">6.1. ~CSS~ss</h3>

<p>
`~CSS~ss@
とは、
~CSS仕様にて定義される~ssを表現する抽象的な概念である。
~CSSOMにおいては、
`~CSS~ss$は `CSSStyleSheet$I ~objにより表現される。
◎
A CSS style sheet is an abstract concept that represents a style sheet as defined by the CSS specification. In the CSSOM a CSS style sheet is represented as a CSSStyleSheet object.
</p>

<div class="algo">
<p id="create-a-constructed-cssstylesheet">
`new CSSStyleSheet(options)@m
構築子~手続きは【！構築-済みな~CSSStyleSheetを作成する】：
</p>
<ol>
	<li>
%文書 ~LET `現在の大域~obj$†に`結付けられた文書$
【† [Exposed=Window] なので、これは `Window$I ~objになる。】
</li>
	<li>
%媒体~query ~LET %options[ `CSSStyleSheetInit^I1"`media$m1" ]
</li>
	<li>
~IF［
%媒体~query は `MediaList$I である（文字列でない）
］
⇒
%媒体~query ~SET `媒体~query~listを直列化する$( %媒体~query の`媒体~query~collection$ )
</li>
	<li>
コレの
⇒＃
`所在$ss ~SET %文書 の`文書~基底~URL$【！`基底~URL$lO】,
`~ss基底~URL$ss ~SET %options[ `CSSStyleSheetInit^I1"`baseURL$m1" ],
`親~CSS~ss$ss【！`親~ss$】 ~SET ~NULL,
`所有者~node$ss ~SET ~NULL,
`所有者~CSS規則$ss ~SET ~NULL,
`~title$ss ~SET 空~文字列,
`代替-か$ss ~SET ~F,
`生成元cleanか$ss ~SET ~T,
`構築子を経たか$ss ~SET ~T,
`構築元~文書$ss ~SET %文書,
`不能化されるか$ss ~SET %options[ `CSSStyleSheetInit^I1"`disabled$m1" ],
`媒体$ss ~SET `~MediaList~objを作成する$( %媒体~query )
</li>
</ol>
◎
CSSStyleSheet(options)
• When called, execute the steps to create a constructed CSSStyleSheet given options and return the result.
◎
To create a constructed CSSStyleSheet given CSSStyleSheetInit options, run these steps:
• Construct a new CSSStyleSheet object sheet.
• Set sheet’s location to the base URL of the associated Document for the current global object.
• Set sheet’s stylesheet base URL to the baseURL attribute value from options.
• Set sheet’s parent CSS style sheet to null.
• Set sheet’s owner node to null.
• Set sheet’s owner CSS rule to null.
• Set sheet’s title to the empty string.
• Unset sheet’s alternate flag.
• Set sheet’s origin-clean flag.
• Set sheet’s constructed flag.
• Set sheet’s Constructor document to the associated Document for the current global object.
• If the media attribute of options is a string, create a MediaList object from the string and assign it as sheet’s media. Otherwise, serialize a media query list from the attribute and then create a MediaList object from the resulting string and set it as sheet’s media.
• If the disabled attribute of options is true, set sheet’s disabled flag.
• Return sheet.
</div>

<p>
各`~CSS~ss$ %~ss には、
以下に挙げる状態~itemが結付けられる：
◎
A CSS style sheet has a number of associated state items:
</p>
<dl class="def-list">
	<dt>
`種別@ss
◎
type
</dt>
	<dd>
`text/css^l
◎
The literal string "text/css".
</dd>

	<dt>
`所在@ss
◎
location
</dt>
	<dd>
~NULL ／
ある文字列
— 作成-時に指定される。
◎
Specified when created.＼
</dd>
	<dd>
%~ss が埋込d`~CSS~ss$である場合は ~NULL になり、
他の場合は %~ss に対する最初の【すなわち，リダイレクト前の】要請の`絶対~URL文字列$になる。
%~ss が存続する限り，変化しない。
◎
The absolute-URL string of the first request of the CSS style sheet or null if the CSS style sheet was embedded. Does not change during the lifetime of the CSS style sheet.
</dd>

	<dt>
`親~CSS~ss@ss
◎
parent CSS style sheet
</dt>
	<dd>
~NULL ／ある`~CSS~ss$
— 作成-時に指定される。
◎
Specified when created.＼
</dd>
	<dd>
%~ss に親の`~CSS~ss$は［
在るならば それ ／
無いならば ~NULL
］になる。
◎
The CSS style sheet that is the parent of the CSS style sheet or null if there is no associated parent.
</dd>

	<dt>
`所有者~node@ss
◎
owner node
</dt>
	<dd>
~NULL ／
ある~DOM~node
【要素／ `ProcessingInstruction$I 】
— 作成-時に指定される。
◎
Specified when created.＼
</dd>
	<dd>
%~ss を結付けている~nodeは［
在るならば それ ／
無いならば ~NULL
］になる。
◎
The DOM node associated with the CSS style sheet or null if there is no associated DOM node.
</dd>
	<dd class="note">注記：
`~CSS~ss$ %~ss を`追加した＠#add-a-css-style-sheet$とき、
%~ss の`所有者~node$ssは， ~NULL でないならば［
それに`結付けられた~CSS~ss$ ~EQ %~ss
］を満たすことになる。
◎
（下からここに移動）
Note: The owner node of a CSS style sheet, if non-null, is the node whose associated CSS style sheet is the CSS style sheet in question, when the CSS style sheet is added.
</dd>

	<dt>
`所有者~CSS規則@ss
◎
owner CSS rule
</dt>
	<dd>
~NULL ／
ある`~CSS規則$
— 作成-時に指定される。
◎
Specified when created.＼
</dd>
	<dd>
%~ss の`親~CSS~ss$ssの中で，
%~ss の `inclusion^en 【 `import$at ？ 】
を生じさせた`~CSS規則$は［
在るならば それ ／
無いならば ~NULL
］になる。
◎
The CSS rule in the parent CSS style sheet that caused the inclusion of the CSS style sheet or null if there is no associated rule.
</dd>

	<dt>
`媒体@ss
◎
media
</dt>
	<dd>
ある `MediaList$I ~obj
— 作成-時に指定される。
◎
Specified when created. The MediaList object associated with the CSS style sheet.
</dd>
	<dd>
<p>
この~propに文字列が指定された場合、
`媒体$ssを次の結果に設定するモノトスル
⇒
`~MediaList~objを作成する$( その文字列 )
◎
If this property is specified to a string, the media must be set to the return value of invoking create a MediaList object steps for that string.
</dd>
	<dd>
<p>
この~propに %~ss の`所有者~node$ss %~node のある属性【ある［内容~属性／`疑似属性$］への参照】 %属性 が指定された場合、
次に従うモノトスル：
◎
If this property is specified to an attribute of the owner node,＼
</p>
		<ul>
			<li>
`媒体$ssを次の結果に設定する
⇒
`~MediaList~objを作成する$( %属性 の値† )
【† %~node が %属性 を有さない場合は空~文字列】
◎
the media must be set to the return value of invoking create a MediaList object steps for the value of that attribute.＼
</li>
			<li>
%属性 が［
設定-／変更-
］されたときは、
`媒体$ssの `MediaList^I1`mediaText$m1 属性を %属性 の新たな値に設定する。
◎
Whenever the attribute is set, changed or removed, the media’s mediaText attribute must be set to the new value of the attribute,＼
</li>
			<li>
%属性 が除去されたときは、
`媒体$ssの `MediaList^I1`mediaText$m1 属性を ~NULL に設定する。
◎
or to null if the attribute is absent.
</li>
		</ul>

<p class="note">注記：
`媒体$ssの `MediaList^I1`mediaText$m1 属性の値が変化しても，
%属性 は変化しない。
◎
Note: Changing the media’s mediaText attribute does not change the corresponding attribute on the owner node.
◎
Note: The owner node...（上に移動）
</p>
	</dd>

	<dt>
`~title@ss
◎
title
</dt>
	<dd>
ある文字列
— 作成-時に指定される。
◎
Specified when created.＼
</dd>
	<dd>
%~ss の~titleを与える。
空~文字列もとり得る。
◎
The title of the CSS style sheet, which can be the empty string.
</dd>
	<dd class="example">
<p>
次の例では、
各~ssの`~title$ssは，
1 個目は空~文字列でない／
2 個目, 3 個目は空~文字列になる。
◎
In the following, the title is non-empty for the first style sheet, but is empty for the second and third style sheets.
</p>

<pre class="lang-html">
&lt;style title="papaya whip"&gt;
  body { background: #ffefd5; }
&lt;/style&gt;
</pre>

<pre class="lang-html">
&lt;style title=""&gt;
  body { background: orange; }
&lt;/style&gt;
</pre>

<pre class="lang-html">
&lt;style&gt;
  body { background: brown; }
&lt;/style&gt;
</pre>

	</dd>
	<dd>
<p>
この~propに %~ss の`所有者~node$ss %~node の ある属性【ある［内容~属性／`疑似属性$］への参照】 %属性 が指定された場合、
次に従うモノトスル：
◎
If this property is specified to an attribute of the owner node,＼
</p>
		<ul>
			<li>
%~ss の`~title$ssを %属性 の値†に設定する。
【† %~node が %属性 を有さない場合は空~文字列】
◎
the title must be set to the value of that attribute.＼
</li>
			<li>
%属性 が［
設定-／変更-
］されたときは、
`~title$ssを %属性 の新たな値に設定する。
◎
Whenever the attribute is set, changed or removed, the title must be set to the new value of the attribute,＼
</li>
			<li>
%属性 が除去されたときは、
`~title$ssを空~文字列に設定する。
◎
or to the empty string if the attribute is absent.
</li>
		</ul>
	</dd>
	<dd class="note">注記：
~HTMLは、
~nodeが`文書~tree内$にある場合に限り，
`~title$ssを %~ss の`所有者~node$ssの属性から得るものと`指定する＠~HEmetadata#the-style-element:concept-css-style-sheet-title$。
◎
Note: HTML only specifies title to be an attribute of the owner node if the node is in in a document tree.
</dd>

	<dt>
`代替-か@ss
◎
alternate flag
</dt>
	<dd>
真偽値
— 作成-時に指定される。
既定では ~F とする。
◎
Specified when created. Either set or unset. Unset by default.
</dd>
	<dd class="example">
<p>
次の`~CSS~ss$の`代替-か$ssは ~T になる：
◎
The following CSS style sheets have their alternate flag set:
</p>

<pre class="lang-html">
&lt;?xml-stylesheet alternate="yes" title="x" href="data:text/css,…"?&gt;
</pre>

<pre class="lang-html">
&lt;link rel="alternate stylesheet" title="x" href="data:text/css,…"&gt;
</pre>
	</dd>

	<dt>
`不能化されるか@ss
◎
disabled flag
</dt>
	<dd>
真偽値
— 既定では ~F とする。
◎
Either set or unset. Unset by default.
</dd>
	<dd class="note">注記：
~F であっても， %~ss が具現化に実際に利用されるとは限らない。
◎
Note: Even when unset it does not necessarily mean that the CSS style sheet is actually used for rendering.
</dd>

	<dt>
`~CSS規則~list@ss
◎
CSS rules
</dt>
	<dd>
%~ss に結付けられた`~CSS規則$たちが成す~list。
◎
The CSS rules associated with the CSS style sheet.
</dd>

	<dt>
`生成元cleanか@ss
◎
origin-clean flag
</dt>
	<dd>
真偽値
— 作成-時に指定される。
◎
Specified when created. Either set or unset.＼
</dd>
	<dd>
~T ならば、
~APIには %~ss の`~CSS規則~list$ssを［
読取る／改変する
］ことが許容される。
◎
If it is set, the API allows reading and modifying of the CSS rules.
</dd>

	<dt>
`構築子を経たか@ss
◎
constructed flag
</dt>
	<dd>
真偽値
— 作成-時に指定される。
既定では ~F とする。
◎
Specified when created. Either set or unset. Unset by default.＼
</dd>
	<dd>
%~ss が~IDL定義な構築子を呼出して作成された場合、
~T になる。
◎
Signifies whether this stylesheet was created by invoking the IDL-defined constructor.
</dd>

	<dt>
`改変は許容しないか@ss
◎
disallow modification flag
</dt>
	<dd>
真偽値
— 既定では ~F とする。
◎
Either set or unset. Unset by default.＼
</dd>
	<dd>
~T ならば、
%~ss の`~CSS規則~list$ssに対する改変は許容されない。
◎
If set, modification of the stylesheet’s rules is not allowed.
</dd>

	<dt>
`構築元~文書@ss
◎
constructor document
</dt>
	<dd>
~NULL ／ `文書$
— 作成-時に指定される。
既定では ~NULL とする。
◎
Specified when created. The Document a constructed stylesheet is associated with. Null by default.＼
</dd>
	<dd>
~NULL 以外になるのは、［
%~ss の`構築子を経たか$ss ~EQ ~T
］の場合に限られる。
◎
Only non-null for stylesheets that have constructed flag set.
</dd>

	<dt>
`~ss基底~URL@ss
◎
stylesheet base URL
</dt>
	<dd>
~NULL ／
文字列
— 既定では ~NULL とする。
◎
↓</dd>
	<dd>
~NULL でないならば、
%~ss 内の相対~URLを解決するときに基底~URLとして利用される。
◎
The base URL to use when resolving relative URLs in the stylesheet.＼
</dd>
	<dd>
~NULL 以外になるのは、［
%~ss の`構築子を経たか$ss ~EQ ~T
］の場合に限られる。
◎
Null by default. Only non-null for stylesheets that have constructed flag set.
</dd>
</dl>

			<section id="the-stylesheet-interface">
<h4 title="The StyleSheet Interface">6.1.1. `StyleSheet^I ~interface</h4>

<p>
`StyleSheet$I ~interfaceは、
抽象的な基底~ssを表現する。
◎
The StyleSheet interface represents an abstract, base style sheet.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `StyleSheet@I {
  readonly attribute `CSSOMString$ `type$m;
  readonly attribute `USVString$? `href$m;
  readonly attribute (`Element$I or `ProcessingInstruction$I)? `ownerNode$m;
  readonly attribute `CSSStyleSheet$I? `parentStyleSheet$m;
  readonly attribute `DOMString$? `title$m;
  [`SameObject$, `PutForwards$=`mediaText$m] readonly attribute `MediaList$I `media$m;
  attribute `boolean$ `disabled$m;
};
</pre>

<div class="algo">
`type@m
取得子~手続きは
⇒
~RET コレの`種別$ss
◎
The type attribute must return the type.
</div>

<div class="algo">
`href@m
取得子~手続きは
⇒
~RET コレの`所在$ss
◎
The href attribute must return the location.
</div>

<div class="algo">
`ownerNode@m
取得子~手続きは
⇒
~RET コレの`所有者~node$ss
◎
The ownerNode attribute must return the owner node.
</div>

<div class="algo">
`parentStyleSheet@m
取得子~手続きは
⇒
~RET コレの`親~CSS~ss$ss
【を表現する `CSSStyleSheet$I ~obj】
◎
The parentStyleSheet attribute must return the parent CSS style sheet.
</div>

<div class="algo">
`title@m
取得子~手続きは
⇒
~RET ［
コレの`~title$ss ~NEQ 空~文字列ならば それ ／
~ELSE_ ~NULL
］
◎
The title attribute must return the title or null if title is the empty string.
</div>

<div class="algo">
`media@m
取得子~手続きは
⇒
~RET コレの`媒体$ss
◎
The media attribute must return the media.
</div>

<p>
`disabled@m
の：
◎
↓</p>
<ul>
	<li class="algo">
取得子~手続きは
⇒
~RET コレの`不能化されるか$ss
◎
The disabled attribute, on getting, must return true if the disabled flag is set, or false otherwise.＼
</li>
	<li class="algo">
設定子~手続きは
⇒
コレの`不能化されるか$ss ~SET 所与の値
◎
On setting, the disabled attribute must set the disabled flag if the new value is true, or unset the disabled flag otherwise.
</li>
</ul>

			</section>
			<section id="the-cssstylesheet-interface">
<h4 title="The CSSStyleSheet Interface">6.1.2. `CSSStyleSheet^I ~interface</h4>

<p>
`CSSStyleSheet$I ~interfaceは `~CSS~ss$を表現する。
◎
The CSSStyleSheet interface represents a CSS style sheet.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSStyleSheet@I : `StyleSheet$I {
  `CSSStyleSheet$mc(optional `CSSStyleSheetInit$I %options = {});
  readonly attribute `CSSRule$I? `ownerRule$m;
  [`SameObject$] readonly attribute `CSSRuleList$I `cssRules$m;
  `unsigned long$ `insertRule$m(`CSSOMString$ %rule, optional `unsigned long$ %index = 0);
  `undefined$ `deleteRule$m(`unsigned long$ %index);

  `Promise$&lt;`CSSStyleSheet$I&gt; `replace$m(`USVString$ %text);
  `undefined$ `replaceSync$m(`USVString$ text);
};

dictionary `CSSStyleSheetInit@I {
  `DOMString$ `baseURL@m = null;
  (`MediaList$I or `DOMString$) `media@m = "";
  `boolean$ `disabled@m = false;
};
</pre>

<!--＊ `CSSStyleSheet@I -->
<div class="algo">
<p>
`ownerRule@m
取得子~手続きは
⇒
~RET コレの`所有者~CSS規則$ss
【を表現する `CSSRule$I （（を継承する~interface）を実装する）~obj】
</p>
<p>
~NULL 以外の値を返す場合は、
どの取得-~accessに対しても，常に同じ値を返すモノトスル。
</p>
◎
The ownerRule attribute must return the owner CSS rule.＼
◎
If a value other than null is ever returned, then that same value must always be returned on each get access.
</div>

<div class="algo">
<p>
`cssRules@m
取得子~手続きは：
◎
The cssRules attribute must follow these steps:
</p>
<ol>
	<li>
~IF［
コレの`生成元cleanか$ss ~EQ ~F
］
⇒
~THROW `SecurityError$E
◎
If the origin-clean flag is unset, throw a SecurityError exception.
</li>
	<li>
<p>
~RET
コレの`~CSS規則~list$ssを表現する，読専かつ~liveな `CSSRuleList$I ~obj
◎
Return a read-only, live CSSRuleList object representing the CSS rules.
</p>

<p class="note">注記：
返される `CSSRuleList$I ~objは（~script側からは）読専であるが、
~liveなので，内容は時間~越しに変化し得る。
例えば，［
`insertRule()$m ／ `deleteRule()$m
］~methodの呼出ngによる変更は、
返された~objに反映される。
◎
Note: Even though the returned CSSRuleList object is read-only (from the perspective of client-authored script), it can nevertheless change over time due to its liveness status. For example, invoking the insertRule() or deleteRule() methods can result in mutations reflected in the returned object.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`insertRule(rule, index)@m
~method手続きは：
◎
The insertRule(rule, index) method must run the following steps:
</p>
<ol>
	<li>
~IF［
コレの`生成元cleanか$ss ~EQ ~F
］
⇒
~THROW `SecurityError$E
◎
If the origin-clean flag is unset, throw a SecurityError exception.
</li>
	<li>
~IF［
コレの`改変は許容しないか$ss ~EQ ~T
］
⇒
~THROW `NotAllowedError$E
◎
If the disallow modification flag is set, throw a NotAllowedError DOMException.
</li>
	<li>
%構文解析した規則 ~LET `規則を構文解析する$( %rule )
◎
Let parsed rule be the return value of invoking parse a rule with rule.
</li>
	<li>
~IF［
%構文解析した規則 ~EQ `構文~error^i
］
⇒
~THROW `SyntaxError$E
◎
If parsed rule is a syntax error, throw a SyntaxError DOMException.
</li>
	<li>
~IF［
%構文解析した規則 は `import$at 規則である
］~AND［
コレの`構築子を経たか$ss ~EQ ~T
］
⇒
~THROW `SyntaxError$E
◎
If parsed rule is an @import rule, and the constructed flag is set, throw a SyntaxError DOMException.
</li>
	<li>
~RET
`~CSS規則~listに規則を挿入する$( コレの`~CSS規則~list$ss, %rule, %index )
◎
Return the result of invoking insert a CSS rule rule in the CSS rules at index.
</li>
</ol>
</div>

<div class="algo">
<p>
`deleteRule(index)@m
~method手続きは：
◎
The deleteRule(index) method must run the following steps:
</p>
<ol>
	<li>
~IF［
コレの`生成元cleanか$ss ~EQ ~F
］
⇒
~THROW `SecurityError$E
◎
If the origin-clean flag is unset, throw a SecurityError exception.
</li>
	<li>
~IF［
コレの`改変は許容しないか$ss ~EQ ~T
］
⇒
~THROW `NotAllowedError$E
◎
If the disallow modification flag is set, throw a NotAllowedError DOMException.
</li>
	<li>
`~CSS規則~listから規則を除去する$( コレの`~CSS規則~list$ss, %index )
◎
Remove a CSS rule in the CSS rules at index.
</li>
</ol>
</div>

<div class="algo">
<p>
`replace(text)@m
~method手続きは：
◎
The replace(text) method must run the following steps:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a promise.
</li>
	<li>
~IF［
コレの`構築子を経たか$ss ~EQ ~F
］~OR［
コレの`改変は許容しないか$ss ~EQ ~T
］
⇒＃
`~promiseを却下する$( %~promise, `NotAllowedError$E 例外 )；
~RET %~promise
◎
If the constructed flag is not set, or the disallow modification flag is set, reject promise with a NotAllowedError DOMException and return promise.
</li>
	<li>
コレの`改変は許容しないか$ss ~SET ~T
◎
Set the disallow modification flag.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
In parallel, do these steps:
</p>
		<ol>
			<li>
%規則~list ~LET `~stylesheetの内容を構文解析する$( %text )
◎
Let rules be the result of running parse a stylesheet’s contents from text.
</li>
			<li>
~EACH( %~index ~IN { 0 〜 %規則~list の長さ ~MINUS 1 } )
に対し，降順に
【 %規則~list の長さは~loop中に 減少するので、降順に反復する】
⇒
~IF［
%規則~list[ %~index ] は `import$at 規則である
］
⇒
`~CSS規則~listから規則を除去する$( %規則~list, %~index )
◎
If rules contains one or more @import rules, remove those rules from rules.
</li>
			<li>
コレの`~CSS規則~list$ss ~SET %規則~list
◎
Set sheet’s CSS rules to rules.
</li>
			<li>
コレの`改変は許容しないか$ss ~SET ~F
◎
Unset sheet’s disallow modification flag.
</li>
			<li>
`~promiseを解決する$( %~promise, コレ )
◎
Resolve promise with sheet.
</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p id="synchronously-replace-the-rules-of-a-cssstylesheet">
`replaceSync(text)@m
~method手続きは【！~CSS規則~群を同期的に置換する( コレ, %text )】：
◎
The replaceSync(text) method must run the steps to synchronously replace the rules of a CSSStyleSheet on this CSSStyleSheet given text.
◎
To synchronously replace the rules of a CSSStyleSheet on sheet given text, run these steps:
</p>
<ol>
	<li>
~IF［
コレの`構築子を経たか$ss ~EQ ~F
］~OR［
コレの`改変は許容しないか$ss ~EQ ~T
］
⇒
~THROW `NotAllowedError$E
◎
If the constructed flag is not set, or the disallow modification flag is set, throw a NotAllowedError DOMException.
</li>
	<li>
%規則~list ~LET `~stylesheetの内容を構文解析する$( %text )
◎
Let rules be the result of running parse a stylesheet’s contents from text.
</li>
	<li>
~EACH( %~index ~IN { 0 〜 %規則~list の長さ } )
に対し，降順に
【 %規則~list の長さは~loop中に 減少するので、降順に反復する】
⇒
~IF［
%規則~list[ %~index ] は `import$at 規則である
］
⇒
`~CSS規則~listから規則を除去する$( %規則~list, %~index )
◎
If rules contains one or more @import rules, remove those rules from rules.
</li>
	<li>
コレの`~CSS規則~list$ss ~SET %規則~list
◎
Set sheet’s CSS rules to rules. 
</li>
</ol>
</div>

				<section id="legacy-css-style-sheet-members">
<h5 title="Deprecated CSSStyleSheet members">6.1.2.1. `CSSStyleSheet^I の非推奨にされた~member</h5>

<p class="note">注記：
これらの~memberは、
既存の~siteとの互換性を得るために要求される。
◎
Note: These members are required for compatibility with existing sites.
</p>

<pre class="idl">
partial interface `CSSStyleSheet$I {
  [`SameObject$] readonly attribute `CSSRuleList$I `rules$m;
  `long$ `addRule$m(optional `DOMString$ %selector = "undefined", optional `DOMString$ %style = "undefined", optional `unsigned long$ %index);
  `undefined$ `removeRule$m(optional `unsigned long$ %index = 0);
};
</pre>

<div class="algo">
`rules@m
取得子~手続きは
⇒
~RET コレ上の `cssRules$m 取得子~手続き()
◎
The rules attribute must follow the same steps as cssRules, and return the same object cssRules would return.
</div>

<div class="algo">
`removeRule(index)@m
~method手続きは
⇒
~RET コレ上の `deleteRule$m ~method手続き( %index )
◎
The removeRule(index) method must run the same steps as deleteRule().
</div>

<div class="algo">
<p>
`addRule(selector, block, optionalIndex)@m
~method手続きは：
◎
The addRule(selector, block, optionalIndex) method must run the following steps:
</p>
<ol>
	<li>
~IF［
%block ~NEQ 空~文字列
］
⇒
%block に ~SP を付加する
◎
↓</li>
	<li>
%rule ~LET 次を順に`連結する$
⇒＃
%selector,
` { ^l,
%block,
`}^l
◎
Let rule be an empty string.
◎
Append selector to rule.
◎
Append " { " to rule.
◎
If block is not empty, append block, followed by a space, to rule.
◎
Append "}" to rule
</li>
	<li>
~IF［
%optionalIndex ~EQ ε
］
⇒
%optionalIndex ~SET コレの`~CSS規則~list$ssを成す~CSS規則の個数
◎
Let index be optionalIndex if provided, or the number of CSS rules in the stylesheet otherwise.
</li>
	<li>
コレ上の `insertRule$m ~method手続き( %rule, %optionalIndex )
◎
Call insertRule(), with rule and index as arguments.
</li>
	<li>
~RET −1
◎
Return -1.
</li>
</ol>
</div>

<p class="advisement">
作者は、
これらの~memberを利用せずに，
標準な `CSSStyleSheet$I ~interfaceを利用するベキである
— その方が `CSSGroupingRule$I と一貫するので。
◎
Authors should not use these members and should instead use and teach the standard CSSStyleSheet interface defined earlier, which is consistent with CSSGroupingRule.
</p>

				</section>
			</section>
		</section>
		<section id="style-sheet-collections">
<h3 title="CSS Style Sheet Collections">6.2. ~CSS~ss~collection</h3>

<p>
各 `DocumentOrShadowRoot$I ~obj %O には、
次に挙げるものが結付けられる：
◎
Below various new concepts are defined that are associated with each DocumentOrShadowRoot object.
</p>
<dl class="def-list">
	<dt>
`~CSS~ss~list@
◎
Each DocumentOrShadowRoot has an associated list of zero or more CSS style sheets, named the document or shadow root CSS style sheets.＼
</dt>
	<dd class="trans-note">【
原文では “`document or shadow root CSS style sheets^en” だが、
長いので，この訳では `document or shadow root^en を省いて略記する。
】</dd>
	<dd>
<p>
順に，次に挙げる`~CSS~ss$を包含する~list：
◎
This is an ordered list that contains:
</p>
		<ol>
			<li>
~HTTP `Link$h ~headerから作成される`~CSS~ss$たち
— 当の~headerの`~field値$に現れる順序で
◎
Any CSS style sheets created from HTTP Link headers, in header order
</li>
			<li>
`DocumentOrShadowRoot$I ~objに結付けられた`~CSS~ss$たち
— 【各自の`所有者~node$ssの】`~tree順序$で
◎
Any CSS style sheets associated with the DocumentOrShadowRoot, in tree order 
</li>
		</ol>
	</dd>

	<dt>
`最終-~CSS~ss~list@
◎
Each DocumentOrShadowRoot has an associated list of zero or more CSS style sheets, named the final CSS style sheets.＼
</dt>
	<dd>
<p>
順に，次に挙げる`~CSS~ss$を包含する~list：
◎
This is an ordered list that contains:
</p>
		<ol>
			<li>
%O の`~CSS~ss~list$
◎
The document or shadow root CSS style sheets.
</li>
			<li>
%O の `adoptedStyleSheets$m を`~backしている~list$【！in array order】
◎
The contents of DocumentOrShadowRoot’s adoptedStyleSheets' backing list, in array order.
</li>
		</ol>
	</dd>
</dl>

<div class="algo">
<p>
`~CSS~ssを作成する@
~algoは：
◎
To create a CSS style sheet, run these steps:
</p>
<ol>
	<li>
%~ss ~LET 新たな`~CSS~ss$ ~obj
◎
Create a new CSS style sheet object＼
</li>
	<li>
%~ss の各種~propを指定された値に設定する
◎
and set its properties as specified.
</li>
	<li>
`~CSS~ss~list$に`~CSS~ssを追加する$( %~ss )
◎
Then run the add a CSS style sheet steps for the newly created CSS style sheet.
</li>
	<li>
~RET %~ss
</li>
</ol>

<p class="warning">
`生成元cleanか$ss ~EQ ~F の下では、
これにより，利用者の~intranetからの情報が公開され得る。
◎
If the origin-clean flag is unset, this can expose information from the user’s intranet.
</p>
</div>

<div class="algo">
<p>
`~CSS~ssを追加する@
~algoは、
所与の
( `~CSS~ss$ %~ss )
に対し：
◎
To add a CSS style sheet, run these steps:
</p>

<ol>
	<li>
%~ss を，`~CSS~ss~list$内の適切な所在に追加する
◎
Add the CSS style sheet to the list of document or shadow root CSS style sheets at the appropriate location.
</li>
	<li>
%所有者 ~LET %~ss の`所有者~node$ss
◎
↓</li>
	<li>
<p>
~IF［
%所有者 ~NEQ ~NULL
【この条件はこの訳による補完】
］~AND［
%所有者 は`~scriptを阻んでいる~ssを供与して$いる
］
⇒
%所有者 の`~node文書$の`~scriptを阻んでいる~ss集合$に %所有者 を`付加する$set【！#list-append】
◎
If the CSS style sheet’s owner node contributes a script-blocking style sheet, then user agents must append the owner node to its node document’s script-blocking style sheet set.
</p>

<p class="note">注記：
以降は、
`不能化されるか$ssについて処する。
◎
The remainder of these steps deal with the disabled flag.
</p>
	</li>
	<li>
~IF［
%~ss の`不能化されるか$ss ~EQ ~T
］
⇒
~RET
◎
If the disabled flag is set, then return.
</li>
	<li>
%~title ← %~ss の`~title$ss
◎
↓</li>
	<li>
~IF［
%~title ~NEQ 空~文字列
］~AND［
%~ss の`代替-か$ss ~EQ ~F
］~AND［
`選好される~CSS~ss集合~名$ ~EQ 空~文字列
］
⇒
`選好される~CSS~ss集合~名を変更する$( %~title )
◎
If the title is not the empty string, the alternate flag is unset, and preferred CSS style sheet set name is the empty string change the preferred CSS style sheet set name to the title.
</li>
	<li>
%集合~名 ~LET `最後の~CSS~ss集合~名$
◎
↓</li>
	<li>
~IF［
%集合~名 ~EQ ~NULL
］
⇒
%集合~名 ~SET `選好される~CSS~ss集合~名$ 
◎
↓</li>
	<li>
%~ss の`不能化されるか$ss ~SET ~IS［
%~title ~NIN { 空~文字列, %集合~名 }
］
◎
If any of the following is true, then unset the disabled flag and return:
• The title is the empty string.
• The last CSS style sheet set name is null and the title is a case-sensitive match for the preferred CSS style sheet set name.
• The title is a case-sensitive match for the last CSS style sheet set name.
◎
Set the disabled flag.
</li>
</ol>
</div>

<div class="algo">
<p>
`~CSS~ssを除去する@
~algoは、
所与の
( `~CSS~ss$ %~ss )
に対し：
◎
To remove a CSS style sheet, run these steps:
</p>

<ol>
	<li>
`~CSS~ss~list$から %~ss を除去する
◎
Remove the CSS style sheet from the list of document or shadow root CSS style sheets.
</li>
	<li>
%~ss の
⇒＃
`親~CSS~ss$ss ~SET ~NULL,
`所有者~node$ss ~SET ~NULL,
`所有者~CSS規則$ss ~SET ~NULL
◎
Set the CSS style sheet’s parent CSS style sheet, owner node and owner CSS rule to null.
</li>
</ol>
</div>

<p>
`持続的~CSS~ss@
とは、
`~CSS~ss~list$に属する`~CSS~ss$のうち，次を満たすものである
⇒
［
`~title$ss ~EQ 空~文字列
］~AND［
`代替-か$ss ~EQ ~F
］
◎
A persistent CSS style sheet is a CSS style sheet from the document or shadow root CSS style sheets whose title is the empty string and whose alternate flag is unset.
</p>

<p>
`~CSS~ss集合@
とは、［
`~CSS~ss~list$に属する`~CSS~ss$のうち，［
空~文字列でない`~title$ss
］が互いに一致するもの
］たちが成す，有順序~collectionである。
◎
A CSS style sheet set is an ordered collection of one or more CSS style sheets from the document or shadow root CSS style sheets which have an identical title that is not the empty string.
</p>

<p>
`~CSS~ss集合$に属する各`~CSS~ss$に共通な`~title$ssは、
`~CSS~ss集合~名@
と呼ばれる。
◎
A CSS style sheet set name is the title the CSS style sheet set has in common.
</p>

<p>
`~CSS~ss集合$は、
次を満たすならば
`可能化された~CSS~ss集合@
とされる
⇒
それを成す各`~CSS~ss$は、
次を満たす
⇒
`不能化されるか$ss ~EQ ~F
◎
An enabled CSS style sheet set is a CSS style sheet set of which each CSS style sheet has its disabled flag unset.
</p>

<div class="algo">
<p>
`~CSS~ss集合を可能化する@
~algoは、
所与の
( 文字列 %名前 )
に対し：
◎
To enable a CSS style sheet set with name name, run these steps:
</p>

<ol>
	<li>
`~CSS~ss~list$を成す
~EACH( `~CSS~ss$ %~ss )
に対し
⇒
~IF［
%~ss の`~title$ss ~NEQ 空~文字列
］
⇒
%~ss の`不能化されるか$ss ~SET ~IS［
%~ss の`~title$ss ~NEQ %名前
］
◎
If name is the empty string, set the disabled flag for each CSS style sheet that is in a CSS style sheet set and return.
◎
Unset the disabled flag for each CSS style sheet in a CSS style sheet set whose CSS style sheet set name is a case-sensitive match for name and set it for all other CSS style sheets in a CSS style sheet set.
</li>
</ol>
</div>

<div class="algo">
<p>
`~CSS~ss集合を選択する@
~algoは、
所与の
( 文字列 %名前 )
に対し：
◎
To select a CSS style sheet set with name name, run these steps:
</p>

<ol>
	<li>
`~CSS~ss集合を可能化する$( %名前 )
◎
enable a CSS style sheet set with name name.
</li>
	<li>
`最後の~CSS~ss集合~名$ ~SET %名前
◎
Set last CSS style sheet set name to name.
</li>
</ol>
</div>

<p>
`最後の~CSS~ss集合~名@
とは、［
どの`~CSS~ss集合$を最後に`選択した$ssか
］を決定するための概念である
— 初期~時には ~NULL とする。
◎
A last CSS style sheet set name is a concept to determine what CSS style sheet set was last selected. Initially its value is null.
</p>

<p>
`選好される~CSS~ss集合~名@
とは、［
どの`~CSS~ss$について，`不能化されるか$ssを ~F にする必要があるか
］を決定するための概念である
— 初期~時には空~文字列とする。
◎
A preferred CSS style sheet set name is a concept to determine which CSS style sheets need to have their disabled flag unset. Initially its value is the empty string.
</p>

<div class="algo">
<p>
`選好される~CSS~ss集合~名を変更する@ 
~algoは、
所与の
( 名前 %名前 )
に対し：
◎
To change the preferred CSS style sheet set name with name name, run these steps:
</p>

<ol>
	<li>
%current ~LET
`選好される~CSS~ss集合~名$
◎
Let current be the preferred CSS style sheet set name.
</li>
	<li>
`選好される~CSS~ss集合~名$ ~SET %名前
◎
Set preferred CSS style sheet set name to name.
</li>
	<li>
~IF［
%名前 ~NEQ %current
］~AND［
`最後の~CSS~ss集合~名$ ~EQ ~NULL
］
⇒
`~CSS~ss集合を可能化する$( %名前 )
◎
If name is not a case-sensitive match for current and last CSS style sheet set name is null enable a CSS style sheet set with name name.
</li>
</ol>
</div>

			<section id="the-http-default-style-header">
<h4 title="The HTTP Default-Style Header">6.2.1. ~HTTP `Default-Style^h ~header</h4>

<p>
~HTTP `Default-Style$h ~headerを利用すれば、
`選好される~CSS~ss集合~名$を設定して，［
（初期~時に）`可能化された~CSS~ss集合$とされる`~CSS~ss集合$は，どれになるか
］に波及させられる。
【この~headerの構文は、この仕様には指定されていない。】
◎
The HTTP Default-Style header can be used to set the preferred CSS style sheet set name influencing which CSS style sheet set is (initially) the enabled CSS style sheet set.
</p>

<p>
~UAは，次を行うモノトスル【いつ？】
⇒
~EACH( ~HTTP `Default-Style$h ~header %~header )
に対し，~headerが現れる順に
⇒
`選好される~CSS~ss集合~名を変更する$( %~header の値 )
◎
For each HTTP Default-Style header, in header order, the user agent must change the preferred CSS style sheet set name with name being the value of the header.
</p>

			</section>
			<section id="the-stylesheetlist-sequence">
<h4 title="The StyleSheetList Interface">6.2.2. `StyleSheetList^I ~interface</h4>

<p>
`StyleSheetList$I ~interfaceは`~CSS~ss$の有順序~collectionを表現する。
◎
The StyleSheetList interface represents an ordered collection of CSS style sheets.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `StyleSheetList@I {
  getter `CSSStyleSheet$I? `item$m(`unsigned long$ %index);
  readonly attribute `unsigned long$ `length$m;
};
</pre>

<p>
~objが`~supportする~prop~index$は、
0 以上［
~collectionで表現される~ssの総数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of CSS style sheets represented by the collection. If there are no such CSS style sheets, then there are no supported property indices.
</p>

<div class="algo">
`item(index)@m
~method手続きは
⇒
~RET コレの~collection内に %index 番の~ssは［
在るならば それ ／
無いならば ~NULL
］
◎
The item(index) method must return the indexth CSS style sheet in the collection. If there is no indexth object in the collection, then the method must return null.
</div>

<div class="algo">
`length@m
取得子~手続きは
⇒
~RET コレの~collectionで表現される~ssの総数
◎
The length attribute must return the number of CSS style sheets represented by the collection.
</div>

			</section>
			<section id="extensions-to-the-document-or-shadow-root-interface">
<h4 title="Extensions to the DocumentOrShadowRoot Interface Mixin">6.2.3. `DocumentOrShadowRoot^I ~interface~mixinに対する拡張</h4>

<pre class="idl">
partial interface mixin `DocumentOrShadowRoot$I {
  [`SameObject$] readonly attribute `StyleSheetList$I `styleSheets$m;
  attribute `ObservableArray$&lt;`CSSStyleSheet$I&gt; `adoptedStyleSheets$m;
};
</pre>

<div class="algo">
`styleSheets@m
取得子~手続きは
⇒
~RET コレの`~CSS~ss~list$を表現する `StyleSheetList$I ~collection
◎
The styleSheets attribute must return a StyleSheetList collection representing the document or shadow root CSS style sheets.
</div>

<div class="algo">
<p>
`adoptedStyleSheets@m
用の`観測-可能な配列~属性の有index値を設定する$
~algoは、
所与の
( %値, %~index )
に対し：
◎
The set an indexed value algorithm for adoptedStyleSheets, given value and index, is the following:
</p>
<ol>
	<li>
~IF［
%値 の`構築子を経たか$ss ~EQ ~F
］~OR［
%値 の`構築元~文書$ss ~NEQ コレの`~node文書$
］
⇒
~THROW `NotAllowedError$E
◎
If value’s constructed flag is not set, or its constructor document is not equal to this DocumentOrShadowRoot’s node document, throw a "NotAllowedError" DOMException.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="style-sheet-association">
<h3 title="Style Sheet Association">6.3. ~ssの結付け</h3>

<p>
この節では、
次を定義する
⇒＃
`~CSS~ss$の`所有者~node$ssが実装する必要がある~interface,
`xml-stylesheet 処理命令$に課される要件,
~link関係~型に `stylesheet^l を含む~HTTP `Link$h ~headerに課される要件
◎
This section defines the interface an owner node of a CSS style sheet has to implement and defines the requirements for xml-stylesheet processing instructions and HTTP Link headers when the link relation type is an ASCII case-insensitive match for "stylesheet".
</p>

			<section id="fetching-css-style-sheets">
<h4 title="Fetching CSS style sheets">6.3.1. ~CSS~ssの~fetch法</h4>

<div class="algo">
<p>
`~CSS~ss資源を~fetchする@
~algoは、
所与の
⇒＃
%構文解析した~URL,
%~referrer,
%文書,
%~parameter群 （これは、`要請$を作成する際の入力に利用される）,
%応答の処理n （これは、~fetchした結果の応答を取扱う）
◎終
に対し：
◎
To fetch a CSS style sheet with parsed URL parsed URL, referrer referrer, document document, optionally a set of parameters parameters (used as input to creating a request), and an algorithm for handling the response result processTheResponse that takes a response, follow these steps:
</p>
<ol>
	<li>
~Assert：
%応答の処理n は、
`応答$を受容する~algoである。
◎
↑</li>
	<li>
%生成元 ~LET %文書 の`生成元$
◎
Let origin be document’s origin.
</li>
	<li>
%要請 ~LET 次のようにされた，新たな`要請$
⇒＃
`~URL$rq ~SET %構文解析した~URL,
`生成元$rq ~SET %生成元,
`~referrer$rq ~SET %~referrer
◎
Let request be a new request, with the url parsed URL, origin origin, referrer referrer, and＼
</li>
	<li>
~IF［
%~parameter群 ~NEQ ε
］
⇒
%~parameter群 に従って， %要請 の他の~parameterを設定する
◎
if specified the set of parameters parameters.
</li>
	<li>
<p>
%要請 を`~fetch$する
— 次を与える下で：
◎
Fetch request,＼
</p>
		<ul>
			<li class="algo">
<p>
`応答の本体~終了~時の処理n$i ~SET 所与の
( `応答$ %応答 )
に対し，次を走らす手続き：
◎
with processResponseEndOfBody, given response, being the following steps:
</p>
				<ol>
					<li>
~IF［
%応答 ~EQ `~network~error$
］
⇒
~RET
◎
If response is a network error, return.
</li>
					<li>
<p>
~IF［
%応答 の`Content-Type ~metadata$は `~supportされる~style付け言語$でない
］：
</p>
							<ol>
								<li>
~IF［
%文書 は`過去互換~mode$下にある
］~AND［
%応答 は`~CORS同一-生成元$である
］
⇒
%応答 の`Content-Type ~metadata$を `text/css^c に変更する
</li>
								<li>
~ELSE
⇒
~RET
</li>
							</ol>
◎
If document is in quirks mode, response is CORS-same-origin and the Content-Type metadata of response is not a supported styling language change the Content-Type metadata of response to text/css.
◎
If response is not in a supported styling language, return.
</li>
					<li>
%応答の処理n( %応答 )
◎
Execute processTheResponse given response
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

			</section>
			<section id="the-linkstyle-interface">
<h4 title="The LinkStyle Interface">6.3.2. `LinkStyle^I ~mixin【！~interface】</h4>

<p>
~node %~node に
`結付けられた~CSS~ss@
とは、
`~CSS~ss~list$に属する`~CSS~ss$のうち［
その`所有者~node$ss ~EQ %~node
］を満たすものであり，
無い場合は ~NULL とする†。
そのような~nodeは、
`LinkStyle$I ~interfaceを実装するモノトスル。
◎
The associated CSS style sheet of a node is the CSS style sheet in the list of document or shadow root CSS style sheets of which the owner node is said node. This node must also implement the LinkStyle interface.
</p>

<p class="trans-note">【†
無い場合の ~NULL は、
他所を簡潔に述べるための，この訳による追加。
】</p>

<pre class="idl">
interface mixin `LinkStyle@I {
  readonly attribute `CSSStyleSheet$I? `sheet$m;
};
</pre>

<div class="algo">
<p>
`sheet@m
取得子~手続きは
⇒
~RET コレに`結付けられた~CSS~ss$
◎
The sheet attribute must return the associated CSS style sheet for the node or null if there is no associated CSS style sheet.
</p>

<div class="example">
<p>
次の例において、
~UAが~CSS（ `text/css^c ）を~supportしつつ，
（仮想の） `text/example-sheets^c は~supportしていないとする。
この場合、
前者の `style$e 要素の `sheet$m 属性は，~ssを表現する `StyleSheet$I ~objを返すが、
後者の `style$e 要素の `sheet$m 属性は，~NULL を返す。
◎
In the following fragment, the first style element has a sheet attribute that returns a StyleSheet object representing the style sheet, but for the second style element, the sheet attribute returns null, assuming the user agent supports CSS (text/css), but does not support the (hypothetical) ExampleSheets (text/example-sheets).
</p>

<pre class="lang-html">
&lt;style type="text/css"&gt;
  body { background:lime }
&lt;/style&gt;
</pre>
<pre class="lang-html">
&lt;style type="text/example-sheets"&gt;
  $(body).background := lime
&lt;/style&gt;
</pre>
</div>
</div>

<p class="note">注記：
~nodeが~ssを~~参照するかどうかは、
当該の~nodeの意味論を定義する仕様により定義される。
◎
Note: Whether or not the node refers to a style sheet is defined by the specification that defines the semantics of said node.
</p>
			</section>
			<section id="requirements-on-specifications">
<h4 title="Requirements on specifications">6.3.3. 仕様に課される要件</h4>

<p>
~DOMを通して~ssを結付ける新たな仕方を導入する仕様は、
どの~nodeが `LinkStyle$I ~interfaceを実装するかを定義するべきである。
その場合、
どの時点で`~CSS~ssを作成する$かも定義しなければナラナイ。
◎
Specifications introducing new ways of associating style sheets through the DOM should define which nodes implement the LinkStyle interface. When doing so, they must also define when a CSS style sheet is created.
</p>


			</section>
			<section id="requirements-on-user-agents-implementing-the-xml-stylesheet-processing-instruction">
<h4 title="Requirements on user agents Implementing the xml-stylesheet processing instruction">6.3.4. `xml-stylesheet 処理命令$を実装する~UAに課される要件</h4>

<pre class="idl">
`ProcessingInstruction$I includes `LinkStyle$I;
</pre>

<p>
`文書$ %文書 の
`~prolog@
とは、
次を満たす`~node$（たちが成す集合）を指す
⇒
［
%文書 の`子$である
］~AND［
それに`先行-$する `Element$I は無い
］
◎
The prolog refers to nodes that are children of the Document and are not following the Element child of the Document, if any.
</p>

<div class="algo">
<p>
`ProcessingInstruction$I `~node$ %~node が［
`~prolog$の一部を［
成すようになった／成さなくなった
］とき／
その`~data$が変化したとき
］には、
次を走らすモノトスル：
◎
When a ProcessingInstruction node node becomes part of the prolog, is no longer part of the prolog, or has its data changed, these steps must be run:
</p>

<ol>
	<li>
~IF［
この~algoの~instanceが
%~node に対し現在~走っている
］
⇒＃
その~instanceを中止する；
適用-可能なら，結付けられた`~fetching$も停止する
◎
If an instance of this algorithm is currently running for node, abort that instance, and stop the associated fetching if applicable.
</li>
	<li>
%~ss ~LET %~node に`結付けられた~CSS~ss$
◎
↓</li>
	<li>
~IF［
%~ss ~NEQ ~NULL
］
⇒
`~CSS~ssを除去する$( %~ss )
◎
If node has an associated CSS style sheet, remove it.
</li>
	<li>
~IF［
%~node は `xml-stylesheet 処理命令$でない
］
⇒
~RET
◎
If node is not an xml-stylesheet processing instruction, then return.
</li>
	<li>
%入力~URL ~LET ［
%~node は `href$xmlss `疑似属性$を有するならば その値 ／
~ELSE_ ε
］
◎
↓</li>
	<li>
~IF［
%入力~URL ~EQ ε
］
⇒
~RET
◎
If node does not have an href pseudo-attribute, then return.
</li>
	<li>
%~title ~LET ［
%~node は `title$xmlss `疑似属性$を有するならば その値 ／
~ELSE_ 空~文字列
］
◎
Let title be the value of the title pseudo-attribute or the empty string if the title pseudo-attribute is not specified.
</li>
	<li>
%代替-か ~LET ~IS［
%~node は `alternate$xmlss `疑似属性$を有していて，その値 ~EQ `yes^l
］
◎
↓</li>
	<li>
~IF［
%代替-か ~EQ ~T
］~AND［
%~title ~EQ 空~文字列
］
⇒
~RET
◎
If there is an alternate pseudo-attribute whose value is a case-sensitive match for "yes" and title is the empty string, then return.
</li>
	<li>
任意選択で
⇒
~IF［
%~node は `type$xmlss `疑似属性$を有していて，その値は`~supportされる~style付け言語$でない
］
⇒
~RET
◎
If there is a type pseudo-attribute whose value is not a supported styling language the user agent may return.
◎
↑Let input URL be the value specified by the href pseudo-attribute.
</li>
	<li>
%文書 ~LET %~node の`~node文書$
◎
Let document be node’s node document
</li>
	<li>
%基底~URL ~LET %文書 の`文書~基底~URL$
◎
Let base URL be document’s document base URL.
</li>
	<li>
%~referrer ~LET %文書 の`~URL$doc【！~address】
◎
Let referrer be document’s address.
</li>
	<li>
%構文解析した~URL ~LET `~URL構文解析する$( %入力~URL )
◎
Let parsed URL be the return value of invoking the URL parser with the string input URL and the base URL base URL.
</li>
	<li>
~IF［
%構文解析した~URL ~EQ `失敗^i
］
⇒
~RET
◎
If parsed URL is failure, then return.
</li>
	<li>
<p>
`~CSS~ss資源を~fetchする$( ↓ )
⇒＃
%構文解析した~URL,
%~referrer,
%文書,
ε,
下に与える応答を処理する~algo
◎
Fetch a CSS style sheet with parsed URL parsed URL, referrer referrer, document document, and processTheResponse given response being the following steps:
</p>

<div class="algo">
<p>
応答を処理する~algoは、
所与の
( `応答$ %応答 )
に対し：
◎
↑</p>
		<ol>
			<li>
<p>
%~ss ~LET 次の~propを伴う`~CSS~ssを作成する$：
◎
Create a CSS style sheet with the following properties:
</p>
				<ul>
					<li>
`所在$ss ~SET `~URLを直列化する$( %構文解析した~URL )
◎
location
• The result of invoking the URL serializer with parsed URL.
</li>
					<li>
`親~CSS~ss$ss ~SET ~NULL
◎
parent CSS style sheet
• null.
</li>
					<li>
`所有者~node$ss ~SET %~node
◎
owner node
• node.
</li>
					<li>
`所有者~CSS規則$ss ~SET ~NULL
◎
owner CSS rule
• null.
</li>
					<li>
`媒体$ss ~SET %~node は `media$xmlss `疑似属性$を有するならば その値 ／
~ELSE_ 空~文字列
◎
media
• The value of the media pseudo-attribute if any, or the empty string otherwise.
</li>
					<li>
`~title$ss ~SET %~title
◎
title
• title.
</li>
					<li>
`代替-か$ss ~SET %代替-か
◎
alternate flag
• Set if the alternate pseudo-attribute value is a case-sensitive match for "yes", or unset otherwise.
</li>
					<li>
`生成元cleanか$ss ~SET ~IS［
%応答 は`~CORS同一-生成元$である
］
◎
origin-clean flag
• Set if response is CORS-same-origin, or unset otherwise.
</li>
				</ul>
			</li>
			<li>
<p>
%~ss の`環境~符号化法$ ~SET 次を走らせた結果：
◎
The CSS environment encoding is the result of running the following steps:
</p>
				<ol>
					<li>
%charset ~LET ［
%~node 【！要素】は `charset$xmlss `疑似属性$を有するならば その値 ／
~ELSE_ ε
］
◎
↓</li>
					<li>
<p>
~IF［
%charset ~NEQ ε
］：
</p>
						<ol>
							<li>
%符号化法 ~SET `~labelから符号化法を取得する$( %charset )
</li>
							<li>
~IF［
%符号化法 ~NEQ `失敗^i
］
⇒
~RET %符号化法
</li>
						</ol>
◎
If the element has a charset pseudo-attribute, get an encoding from that pseudo-attribute’s value. If that succeeds, return the resulting encoding and abort these steps.
</li>
					<li>
~RET %文書 の`符号化法$doc
◎
Otherwise, return the document’s character encoding. [DOM]
</li>
				</ol>
			</li>
		</ol>
</div>
	</li>
</ol>
</div>

			</section>
			<section id="requirements-on-user-agents-implementing-the-http-link-header">
			
<h4 title="Requirements on user agents Implementing the HTTP Link Header">6.3.5. ~HTTP `Link^h ~headerを実装する~UAに課される要件</h4>

<div class="algo">
<p>
各~HTTP `Link$h ~headerに対しては、
次の手続きを走らすモノトスル：
◎
For each HTTP Link header＼
</p>
<ol>
	<li>
%~header値 ~LET `Link$h ~headerの値
◎
of which＼
</li>
	<li>
%関係~型~list ~LET ［
%~header値 の中の~link関係~型（ `relation-type^c ）たちが成す集合
］
◎
one of the link relation types＼
</li>
	<li>
~IF［
`stylesheet^l ~NIN `大小無視$sub %関係~型~list
］
⇒
~RET
◎
is an ASCII case-insensitive match for "stylesheet" these steps must be run:
</li>
	<li>
%~title ~LET ［
%~header値 の中に `title^l ~parameterは在るならば それらのうち最初のものの値 ／
無いならば 空~文字列
］
◎
Let title be the value of the first of all the title parameters. If there are no such parameters it is the empty string.
</li>
	<li>
~IF［
%~title ~EQ 空~文字列
］~AND［
`alternate^l ~IN `大小無視$sub %関係~型~list
］
⇒
~RET
◎
If one of the (other) link relation types is an ASCII case-insensitive match for "alternate" and title is the empty string, then return.
</li>
	<li>
<p>
%入力~URL ~LET %~header値 に指定された URI-Reference
◎
Let input URL be the value specified.
</p>

<p class="issue">
より詳細に規定する必要がある
◎
Be more specific
</p>
	</li>
	<li>
%文書 ~LET 当の文書
◎
↓</li>
	<li>
<p>
%基底~URL ~LET %文書 の`文書~基底~URL$
◎
Let base URL be the document’s document base URL.
</p>

<p class="issue">
この時点で文書~objは在るのか？
◎
Is there a document at this point?
</p>
	</li>
	<li>
%~referrer ~LET %文書 の`~URL$doc【！~address】
◎
Let referrer be the document’s address.
</li>
	<li>
%構文解析した~URL ~LET `~URL構文解析する$( %入力~URL )
◎
Let parsed URL be the return value of invoking the URL parser with the string input URL and the base URL base URL.
</li>
	<li>
~IF［
%構文解析した~URL ~EQ `失敗^i
］
⇒
~RET
◎
If parsed URL is failure, then return.
</li>
	<li>
<p>
`~CSS~ss資源を~fetchする$( ↓ )
⇒＃
%構文解析した~URL,
%~referrer,
%文書,
ε,
下に与える応答を処理する~algo
◎
Fetch a CSS style sheet with parsed URL parsed URL, referrer referrer, document being the document, and processTheResponse, given response, being the following steps:
</p>

<p class="issue">
~HTML構文解析器が過去互換~modeかどうかまだ裁定していなかった場合はどうする？
◎
What if the HTML parser hasn’t decided on quirks/non-quirks yet?
</p>

<div class="algo">
<p>
応答を処理する~algoは、
所与の
( `応答$ %応答 )
に対し，次の~propを伴う`~CSS~ssを作成する$：
◎
↑
◎
Create a CSS style sheet with the following properties:
</p>
		<ul>
			<li>
`所在$ss ~SET `~URLを直列化する$( %構文解析した~URL )
◎
location
• The result of invoking the URL serializer with parsed URL.
</li>
			<li>
`所有者~node$ss ~SET ~NULL
◎
owner node
• null.
</li>
			<li>
`親~CSS~ss$ss ~SET ~NULL
◎
parent CSS style sheet
• null.
</li>
			<li>
`所有者~CSS規則$ss ~SET ~NULL
◎
owner CSS rule
• null.
</li>
			<li>
`媒体$ss ~SET 最初の `media^c ~parameterの値
◎
media
• The value of the first media parameter.
</li>
			<li>
`~title$ss ~SET %~title
◎
title
• title.
</li>
			<li>
`代替-か$ss ~SET ~IS［
`alternate^l ~IN `大小無視$sub %関係~型~list
］
◎
alternate flag
• Set if one of the specified link relation type for this HTTP Link header is an ASCII case-insensitive match for "alternate", or false otherwise.
</li>
			<li>
`生成元cleanか$ss ~SET ~IS［
%応答 は`~CORS同一-生成元$である
］
◎
origin-clean flag
• Set if response is CORS-same-origin, or unset otherwise.
</li>
		</ul>
</div>
	</li>
</ol>
</div>

<div class="p">
<p>
この節の~~規則を利用して~HTTP `Link$h ~headerから参照される~ss %~ss のうち，所与の時点で 次のすべてを満たすものは、
`~scriptを阻んでいる~ss$とされる
— ~UA は、
そのような~ssをいつでも~give-upしてヨイ：
</p>

<ul>
	<li>
%~ss は、
その作成-時に可能化されている
</li>
	<li>
~UA は、
%~ss をまだ~give-upしていない
</li>
</ul>

<p class="trans-note">【
“~give-up” が正確に何を意味するかは、
この仕様には定義されていない。
この時点では~give-upしたとしても，
%~ss は後で読込まれて処理されるかもしれない。
】</p>
◎
A style sheet referenced by a HTTP Link header using the rules in this section is said to be a style sheet that is blocking scripts if the style sheet was enabled when created, and the user agent hasn’t given up on that particular style sheet yet. A user agent may give up on such a style sheet at any time.
</div>

			</section>
		</section>
		<section id="css-rules">
<h3 title="CSS Rules">6.4. ~CSS規則</h3>

<p>
`~CSS規則@
とは、
~CSS仕様にて定義される規則を表す，抽象的な概念である。
`~CSS規則$は、
`CSSRule$I ~interfaceを継承する~interfaceを実装する~objで表現される。
それには、
以下に挙げる状態~itemが結付けられる
【括弧内は、~itemに対応する `CSSRule^I の属性~member（この訳による補足）】
◎
A CSS rule is an abstract concept that denotes a rule as defined by the CSS specification. A CSS rule is represented as an object that implements a subclass of the CSSRule interface, and which has the following associated state items:
</p>

<dl class="def-list">
	<dt>
`種別@（ `type$m1 ）
◎
type
</dt>
	<dd>
特定0の［
規則の種別
］に結付けられる，負でない整数。
この~itemは、
規則の作成-時に初期化され，変更されることはない。
【 `CSSRule$I を継承する特定の~interfaceに対応する。】
◎
A non-negative integer associated with a particular type of rule. This item is initialized when a rule is created and cannot change.
</dd>

	<dt>
`~text@（ `cssText$m1 ）
◎
text
</dt>
	<dd>
~ss内で直に利用するのに適するような，規則の~text表現。
この~itemは規則の作成-時に初期化され，規則が存続する間 変更され得る。
◎
A text representation of the rule suitable for direct use in a style sheet. This item is initialized when a rule is created and can be changed.
</dd>

	<dt>
`親~規則@（ `parentRule$m1 ）
◎
parent CSS rule
</dt>
	<dd>
この規則を封入している別の`~CSS規則$への参照か, または ~NULL。
この~itemは規則の作成-時に［
そのような別の規則があるならばそれ ／
~ELSE_ ~NULL
］に初期化され，~NULLに変更され得る。
◎
A reference to an enclosing CSS rule or null. If the rule has an enclosing rule when it is created, then this item is initialized to the enclosing rule; otherwise it is null. It can be changed to null.
</dd>

	<dt>
`親~ss@（ `parentStyleSheet$m1 ）
◎
parent CSS style sheet
</dt>
	<dd>
親の`~CSS~ss$への参照か, または ~NULL。
この~itemは、
規則の作成-時に結付けられた~ssへの参照に初期化され，~NULLに変更され得る。
◎
A reference to a parent CSS style sheet or null. This item is initialized to reference an associated style sheet when the rule is created. It can be changed to null.
</dd>

	<dt>`子~規則~list@
◎
child CSS rules
</dt>
	<dd>
子 `~CSS規則$の~list。
この~listは変異し得る。
◎
A list of child CSS rules. The list can be mutated.
</dd>
</dl>

<p>
上の状態~itemに加え、
各`~CSS規則$には，その`種別$に則って他の状態~itemも結付けられ得る。
◎
In addition to the above state, each CSS rule may be associated with other state in accordance with its type.
</p>

<div class="algo">
<p>
`~CSS規則として構文解析する@
~algoは、
所与の
( 文字列 %文字列 )
に対し：
◎
To parse a CSS rule from a string string, run the following steps:
</p>

<ol>
	<li>
%規則 ~LET `規則を構文解析する$( %文字列 )
◎
Let rule be the return value of invoking parse a rule with string.
</li>
	<li>
~IF［
%規則 ~EQ `構文~error^i
］
⇒
~RET %規則
◎
If rule is a syntax error, return rule.
</li>
	<li>
%構文解析した規則 ~LET
適切な~CSS仕様に則って
%規則 を構文解析した上で，`無視される$ものは落とした結果
⇒
~IF［
%規則 全体が落とされた
］
⇒
~RET `構文~error^i
◎
Let parsed rule be the result of parsing rule according to the appropriate CSS specifications, dropping parts that are said to be ignored. If the whole rule is dropped, return a syntax error.
</li>
	<li>
~RET %構文解析した規則
◎
Return parsed rule. 
</li>
</ol>
</div>

<div class="algo">
<p>
`~CSS規則を直列化する@
~algoは、
所与の
( `~CSS規則$ %規則 )
に対し，その`種別$
【に対応する~interface】
に応じて：
◎
To serialize a CSS rule, perform one of the following in accordance with the CSS rule’s type:
</p>
<dl class="switch">
	<dt>`CSSStyleRule$I</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET 空~文字列
◎
Return the result of the following steps:
</li>
			<li>
%結果 に次を順に付加する
⇒＃
`選択子~listを直列化する$( %規則 が表現している`~CSS~style規則$の`選択子~list$ ),
~SP,
❝{
◎
Let s initially be the result of performing serialize a group of selectors on the rule’s associated selectors, followed by the string " {", i.e., a single SPACE (U+0020), followed by LEFT CURLY BRACKET (U+007B).
</li>
			<li>
%宣言~群 ~LET %規則 が表現している`~CSS~style規則$の`~CSS宣言~block$の`宣言~群$dB
【 `style$m1 】
◎
↓Let decls be the result of performing serialize a CSS declaration block on the rule’s associated declarations, or null if there are no such declarations.
</li>
			<li>
%子~規則~list ~LET %規則 の`子~規則~list$
【！`cssRules＠~CSSNESTING#dom-cssstylerule-cssrules$m ~list】
◎
↓Let rules be the result of performing serialize a CSS rule on each rule in the rule’s cssRules list, or null if there are no such rules.
</li>
			<li>
<p>
~IF［
%子~規則~list は空である
］：
</p>
				<ol>
					<li>
%結果 に ~SP 付加する
</li>
					<li>
~IF［
%宣言~群 は空でない
］
⇒
%結果 に次を順に付加する
⇒＃
`宣言~群を直列化する$( %宣言~群 ),
~SP
</li>
				</ol>
◎
If decls and rules are both null, append " }" to s (i.e. a single SPACE (U+0020)＼
↓followed by RIGHT CURLY BRACKET (U+007D)) and return s.
◎
If rules is null:
• Append a single SPACE (U+0020) to s
• Append decls to s
• Append " }" to s (i.e. a single SPACE (U+0020)＼
↓followed by RIGHT CURLY BRACKET (U+007D)).
• ↓Return s.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
~IF［
%宣言~群 は空でない
］
⇒
%結果 に次を順に付加する
⇒＃
改行文字,
~SP,
~SP,
`宣言~群を直列化する$( %宣言~群 )
◎
↑
◎
If decls is not null, prepend it to rules.
</li>
					<li>
<p>
%子~規則~list を成す
~EACH( %子~規則 )
に対し：
◎
For each rule in rules:
</p>
						<ol>
							<li>
%直列化 ~LET `~CSS規則を直列化する$( %子~規則 )
◎
↑</li>
							<li>
~IF［
%直列化 ~EQ 空~文字列
］
⇒
~CONTINUE
◎
If rule is the empty string, do nothing.
</li>
							<li>
%結果 に次を順に付加する
⇒＃
改行文字,
~SP,
~SP,
%直列化
◎
Otherwise:
• Append a newline followed by two spaces to s.
• Append rule to s.
</li>
						</ol>
					</li>
					<li>
%結果 に改行文字を付加する
◎
Append a newline＼
↓followed by RIGHT CURLY BRACKET (U+007D) to s.
◎
↓Return s.
</li>
				</ol>
			</li>
			<li>
%結果 に ❝} を付加する
◎
↑</li>
			<li>
~RET %結果
◎
↑</li>
		</ol>
	</dd>

	<dt>`CSSImportRule$I</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET 空~文字列
◎
The result of concatenating the following:
</li>
			<li>
%結果 に次を順に付加する
⇒＃
`@import^l,
~SP,
`~CSS~URLに直列化する$( %規則 の所在【 `href$m1 】 )
◎
The string "@import" followed by a single SPACE (U+0020).
◎
The result of performing serialize a URL on the rule’s location.
</li>
			<li>
~IF［
%規則 に結付けられた媒体~list %媒体~list
【 `media$m1 ／ `媒体~query~collection$ 】
は空でない
］
⇒
%結果 に次を順に付加する
⇒＃
~SP,
`媒体~query~listを直列化する$( %媒体~list )
◎
If the rule’s associated media list is not empty, a single SPACE (U+0020) followed by the result of performing serialize a media query list on the media list.
</li>
			<li>
%結果 に ❝; を付加する
◎
The string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
~RET %結果
◎
↑</li>
		</ol>
	</dd>
	<dd class="example">
<pre class="lang-css">
`import$at url(`import.css^l);
</pre>

<pre class="lang-css">
`import$at url(`print.css^l) print;
</pre>

	</dd>

	<dt>`CSSMediaRule$I</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET 空~文字列
◎
The result of concatenating the following:
</li>
			<li>
%結果 に次を順に付加する
⇒＃
`@media^l,
~SP,
`媒体~query~listを直列化する$( %規則 の媒体~query~list 【`媒体~query~collection$】 ),
~SP,
❝{
◎
The string "@media", followed by a single SPACE (U+0020).
◎
The result of performing serialize a media query list on rule’s media query list.
◎
A single SPACE (U+0020), followed by the string "{", i.e., LEFT CURLY BRACKET (U+007B),＼
</li>
			<li>
<p>
%規則 の`子~規則~list$【！cssRules:#dom-cssgroupingrule-cssrules】を成す
~EACH( %子~規則 )
に対し：
</p>
				<ol>
					<li>
%直列化 ~LET `~CSS規則を直列化する$( %子~規則 )
</li>
					<li>
~IF［
%直列化 ~EQ 空~文字列
］
⇒
~CONTINUE
</li>
					<li>
%結果 に次を順に付加する
⇒＃
改行文字,
~SP,
~SP,
%直列化
</li>
				</ol>
◎
followed by a newline.
◎
The result of performing serialize a CSS rule on each rule in the rule’s cssRules list, filtering out empty strings, indenting each item with two spaces, all joined with newline.
</li>
			<li>
%結果 に次を順に付加する
⇒＃
改行文字,
❝}
◎
A newline, followed by the string "}", i.e., RIGHT CURLY BRACKET (U+007D)
</li>
			<li>
~RET %結果
◎
↑</li>
		</ol>
	</dd>

	<dt>`CSSFontFaceRule$I</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET 空~文字列
◎
The result of concatenating the following:
</li>
			<li>
%結果 に次を順に付加する
⇒＃
`@font-face {^l,
~SP,
`font-family:^l,
~SP,
`文字列を直列化する$( %規則 の `font-family$td ),
❝;
◎
The string "@font-face {", followed by a single SPACE (U+0020).
◎
The string "font-family:", followed by a single SPACE (U+0020).
◎
The result of performing serialize a string on the rule’s font family name.
◎
The string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
<p>
~IF［
%規則 内に `src$d 記述子は在る
【！ associated source list is not empty】
］：
</p>
				<ol>
					<li>
%~source~list ~LET 
%規則 の `src$td 内の各~sourceに［
`~CSS~URLに直列化する$ ／ `~LOCALに直列化する$
］のいずれか適切な方を適用して得られる同順の~list
</li>
					<li>
%結果 に次を順に付加する
⇒＃
~SP,
`src:^l,
~SP,
`~commaで分離して直列化する$( %~source~list ),
❝;
</li>
				</ol>
◎
If the rule’s associated source list is not empty, follow these substeps:
◎
A single SPACE (U+0020), followed by the string "src:", followed by a single SPACE (U+0020).
◎
The result of invoking serialize a comma-separated list on performing serialize a URL or serialize a LOCAL for each source on the source list.
◎
The string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
~IF［
%規則 内に `unicode-range$d 記述子は在る
］
⇒
%結果 に次を順に付加する
⇒＃
~SP,
`unicode-range:^l,
~SP,
%規則 の `unicode-range$td を直列化した結果,
❝;
◎
If rule’s associated unicode-range descriptor is present, a single SPACE (U+0020), followed by the string "unicode-range:", followed by a single SPACE (U+0020), followed by the result of performing serialize a &lt;'unicode-range'&gt;, followed by the string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
~IF［
%規則 内に `font-variant$d 記述子は在る
］
⇒
%結果 に次を順に付加する
⇒＃
~SP,
`font-variant:^l,
~SP,
%規則 の `font-variant^td を直列化した結果,
❝;
◎
If rule’s associated font-variant descriptor is present, a single SPACE (U+0020), followed by the string "font-variant:", followed by a single SPACE (U+0020), followed by the result of performing serialize a &lt;'font-variant'&gt;, followed by the string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
~IF［
%規則 内に `font-feature-settings$d 記述子は在る
］
⇒
%結果 に次を順に付加する
⇒＃
~SP,
`font-feature-settings:^l,
~SP,
%規則 の `font-feature-settings$td を直列化した結果,
❝;
◎
If rule’s associated font-feature-settings descriptor is present, a single SPACE (U+0020), followed by the string "font-feature-settings:", followed by a single SPACE (U+0020), followed by the result of performing serialize a &lt;'font-feature-settings'&gt;, followed by the string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
<p>
~IF［
%規則 内に `font-stretch$d 記述子†は在る
］
⇒
%結果 に次を順に付加する
⇒＃
~SP,
`font-stretch:^l,
~SP,
%規則 の `font-stretch$td を直列化した結果,
❝;
</p>

<p class="trans-note">【†
`font-stretch^d は `font-width$d の旧来の別名なので、
`font-width^d に対しても類似に挙動するであろう。
】</p>
◎
If rule’s associated font-stretch descriptor is present, a single SPACE (U+0020), followed by the string "font-stretch:", followed by a single SPACE (U+0020), followed by the result of performing serialize a &lt;'font-stretch'&gt;, followed by the string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
~IF［
%規則 内に `font-weight$d 記述子は在る
］
⇒
%結果 に次を順に付加する
⇒＃
~SP,
`font-weight:^l,
~SP,
%規則 の `font-weight$td を直列化した結果,
❝;
◎
If rule’s associated font-weight descriptor is present, a single SPACE (U+0020), followed by the string "font-weight:", followed by a single SPACE (U+0020), followed by the result of performing serialize a &lt;'font-weight'&gt;, followed by the string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
~IF［
%規則 内に `font-style$d 記述子は在る
］
⇒
%結果 に次を順に付加する
⇒＃
~SP,
`font-style:^l,
~SP,
%規則 の `font-style$td を直列化した結果,
❝;
◎
If rule’s associated font-style descriptor is present, a single SPACE (U+0020), followed by the string "font-style:", followed by a single SPACE (U+0020), followed by the result of performing serialize a &lt;'font-style'&gt;, followed by the string ";", i.e., SEMICOLON (U+003B).
</li>
			<li>
%結果 に次を順に付加する
⇒＃
~SP,
❝}
◎
A single SPACE (U+0020), followed by the string "}", i.e., RIGHT CURLY BRACKET (U+007D).
</li>
			<li>
~RET %結果
◎
↑</li>
		</ol>

<p class="issue">
`CSSFontFaceRule$I の各種 記述子の値を直列化する方法を定義する必要がある。
◎
Need to define how the CSSFontFaceRule descriptors' values are serialized.
</p>
	</dd>

	<dt>`CSSPageRule$I</dt>
	<dd class="issue">
直列化する方法を定義する必要がある。
◎
Need to define how CSSPageRule is serialized.
</dd>

	<dt>`CSSNamespaceRule$I</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET 空~文字列
◎
↓</li>
			<li>
%結果 に次を順に付加する
⇒＃
`@namespace^l,
~SP
◎
The literal string "@namespace", followed by a single SPACE (U+0020),＼
</li>
			<li>
~IF［
%規則 に`~ns接頭辞$は在る【！`prefix$m1 attribute ~NEQ 空~文字列】
］
⇒
%結果 に次を順に付加する
⇒＃
`識別子を直列化する$( %規則 の`~ns接頭辞$ ),
~SP,
`~CSS~URLに直列化する$( %規則 の`~ns名$【！`namespaceURI$m1 attribute】 ),
❝;
◎
followed by the serialization as an identifier of the prefix attribute (if any), followed by a single SPACE (U+0020) if there is a prefix, followed by the serialization as URL of the namespaceURI attribute, followed the character ";" (U+003B).
</li>
			<li>
~RET %結果
◎
↑</li>
		</ol>
	</dd>
	<dt>`CSSKeyframesRule$I</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET 空~文字列
◎
The result of concatenating the following:
</li>
			<li>
%結果 に次を順に付加する
⇒＃
`@keyframes^l,
~SP
◎
The literal string "@keyframes", followed by a single SPACE (U+0020).
</li>
			<li>
<p>
%結果 に次に与える［
`name$mA 属性の直列化
］を付加する
⇒
属性は［
`~CSS全域~keyword$／ `default^v ／ `none^v
］いずれかである†ならば `文字列を直列化する$( 属性の値 ) ／
~ELSE_ `識別子を直列化する$( 属性の値 )
</p>

<p class="trans-note">【†
`name$mA 属性 `CSS-ANIMATIONS-1$r の取得子が
まだ具体的な手続きとして定義されていないので、
この条件も曖昧になっている。
】</p>
◎
The serialization of the name attribute. If the attribute is a CSS wide keyword, or the value default, or the value none, then it is serialized as a string. Otherwise, it is serialized as an identifier.
</li>
			<li>
%結果 に次を順に付加する
⇒＃
~SP,
❝{
~SP
◎
The string " { ", i.e., a single SPACE (U+0020), followed by LEFT CURLY BRACKET (U+007B), followed by a single SPACE (U+0020).
</li>
			<li>
%規則 の`子~規則~list$【！~CSSANIM#dom-csskeyframesrule-name】を成す
~EACH( %子~規則 )
に対し
⇒
%結果 に次を順に付加する
⇒＃
改行文字,
~SP,
~SP,
`~CSS規則を直列化する$( %子~規則 )
◎
The result of performing serialize a CSS rule on each rule in the rule’s cssRules list, separated by a newline and indented by two spaces.
</li>
			<li>
%結果 に次を順に付加する
⇒＃
改行文字,
❝}
◎
A newline, followed by the string "}", i.e., RIGHT CURLY BRACKET (U+007D)
</li>
		</ol>
	</dd>

	<dt>`CSSKeyframeRule$I</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET 空~文字列
◎
The result of concatenating the following:
</li>
			<li>
%結果 に次を順に付加する
⇒＃
`keyText$mA 属性の値,
~SP,
❝{,
~SP
◎
The keyText.
◎
The string " { ", i.e., a single SPACE (U+0020), followed by LEFT CURLY BRACKET (U+007B), followed by a single SPACE (U+0020).
</li>
			<li>
%宣言~群 ~LET %規則 が表現している`~CSS~style規則$の`~CSS宣言~block$の`宣言~群$dB
【 `style$mA 】
◎
↓</li>
			<li>
~IF［
%宣言~群 は空でない
］
⇒
%結果 に次を順に付加する
⇒＃
`宣言~群を直列化する$( %宣言~群 ),
~SP
◎
The result of performing serialize a CSS declaration block on the rule’s associated declarations.
◎
If the rule is associated with one or more declarations, the string " ", i.e., a single SPACE (U+0020).
</li>
			<li>
%結果 に ❝} を付加する
◎
The string "}", RIGHT CURLY BRACKET (U+007D).
</li>
		</ol>
	</dd>
</dl>

<p class="issue">
2 個の ~SP で “字下げする” 所
【改行文字, ~SP, ~SP を付加する所】
は、
~browserに合致するが，作業が必要である。
`5494$issue を見よ。
【入子な`~CSS規則$に対しても，同じ字下げになってしまう。】
◎
The "indented by two spaces" bit matches browsers, but needs work, see #5494
</p>
</div>

<div class="algo">
<p>
`~CSS規則~listに規則を挿入する@
~algoは、
所与の
( `~CSS規則~list$ss %~list, `~CSS規則$ %規則, 整数 %~index, 真偽値 %入子にされたか（省略時は ~F ） )
に対し：
◎
To insert a CSS rule rule in a CSS rule list list at index index, with a flag nested, follow these steps:
</p>
<ol>
	<li>
~IF［
%~index ~GT %~list の~item数
］
⇒
~THROW `IndexSizeError$E
◎
Set length to the number of items in list.
◎
If index is greater than length, then throw an IndexSizeError exception.
</li>
	<li>
%新たな規則 ~SET `~CSS規則として構文解析する$( %規則 )
◎
Set new rule to the results of performing parse a CSS rule on argument rule.
</li>
	<li>
<p>
~IF［
%新たな規則 ~EQ `構文~error^i
］：
</p>
		<ol>
			<li>
~IF［
%入子にされたか ~EQ ~F
］
⇒
~THROW `SyntaxError$E
</li>
			<li>
%宣言~群 ~SET `~CSS宣言~blockとして構文解析する$( %規則 )
</li>
			<li>
~IF［
%宣言~群 は空である
］
⇒
~THROW `SyntaxError$E
</li>
			<li>
%新たな規則 ~SET %宣言~群 を包装する新たな`入子な宣言~列が成す規則$
</li>
		</ol>
◎
If new rule is a syntax error, and nested is set, perform the following substeps:
• Set declarations to the results of performing parse a CSS declaration block, on argument rule.
• If declarations is empty, throw a SyntaxError exception.
• Otherwise, set new rule to a new nested declarations rule with declarations as it contents.
◎
If new rule is a syntax error, throw a SyntaxError exception.
</li>
	<li>
<p>
~IF［
%新たな規則 を %~list 内の %~index 番の~itemになるよう挿入すると，
~CSS `CSS21$r により指定される拘束に反する
］
⇒
~THROW `HierarchyRequestError$E
◎
If new rule cannot be inserted into list at the zero-index position index due to constraints specified by CSS, then throw a HierarchyRequestError exception. [CSS21]
</p>

<p class="note">注記：
例えば，~CSS~ssは、
~style規則の後に `import$at ~at-規則を包含できない。
◎
Note: For example, a CSS style sheet cannot contain an @import at-rule after a style rule.
</p>
	</li>
	<li>
~IF［
%新たな規則 は `namespace$at ~at-規則である
］~AND［
%~list は［
`import$at ~at-規則, `namespace$at ~at-規則
］以外のものを包含している
］
⇒
~THROW `InvalidStateError$E
◎
If new rule is an @namespace at-rule, and list contains anything other than @import at-rules, and @namespace at-rules, throw an InvalidStateError exception.
</li>
	<li>
%新たな規則 を %~list 内の %~index 番の~itemになるよう挿入する
◎
Insert new rule into list at the zero-indexed position index.
</li>
	<li>
~RET %~index
◎
Return index.
</li>
</ol>
</div>

<div class="algo">
<p>
`~CSS規則~listから規則を除去する@
~algoは、
所与の
( `~CSS規則~list$ss %~list, 負でない整数 %~index )
に対し：
◎
To remove a CSS rule from a CSS rule list list at index index, follow these steps:
</p>

<ol>
	<li>
~IF［
%~index ~GTE %~list の長さ
］
⇒
~THROW `IndexSizeError$E
◎
Set length to the number of items in list.
◎
If index is greater than or equal to length, then throw an IndexSizeError exception.
</li>
	<li>
%規則 ~SET %~list[ %~index ]
◎
Set old rule to the indexth item in list.
</li>
	<li>
~IF［
%規則 は `namespace$at ~at-規則である
］~AND［
%~list は［
`import$at ~at-規則, `namespace$at ~at-規則
］以外のものを包含している
］
⇒
~THROW `InvalidStateError$E
◎
If old rule is an @namespace at-rule, and list contains anything other than @import at-rules, and @namespace at-rules, throw an InvalidStateError exception.
</li>
	<li>
%~list から %~index 番の~itemを除去する
◎
Remove rule old rule from list at the zero-indexed position index.
</li>
	<li>
%規則 の
⇒＃
`親~規則$ ~SET ~NULL,
`親~ss$ ~SET ~NULL
◎
Set old rule’s parent CSS rule and parent CSS style sheet to null.
</li>
</ol>
</div>

			<section id="the-cssrulelist-sequence">
<h4 title="The CSSRuleList Interface">6.4.1. `CSSRuleList^I ~interface</h4>

<p>
`CSSRuleList$I ~interfaceは、
`~CSS規則~list$ss
— ~CSS規則たちが成す有順序~collection —
を表現する。
◎
The CSSRuleList interface represents an ordered collection of CSS style rules.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSRuleList@I {
  getter `CSSRule$I? `item$m(`unsigned long$ %index);
  readonly attribute `unsigned long$ `length$m;
};
</pre>

<p>
`CSSRuleList$I ~obj %O が`~supportする~prop~index$は、
0 以上［
%O が表現する~collectionを成す `CSSRule$I ~objの総数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of CSSRule objects represented by the collection. If there are no such CSSRule objects, then there are no supported property indices.
</p>

<div class="algo">
`item(index)@m
~method手続きは
⇒
~RET %index はコレが`~supportする~prop~index$であるならば
コレが表現する~collectionの中で %index 番の `CSSRule$I ~obj ／
~ELSE_ ~NULL
◎
The item(index) method must return the indexth CSSRule object in the collection. If there is no indexth object in the collection, then the method must return null.
</div>

<div class="algo">
`length@m
取得子~手続きは
⇒
~RET コレが表現する~collectionを成す `CSSRule$I ~objの総数
◎
The length attribute must return the number of CSSRule objects represented by the collection.
</div>

			</section>
			<section id="the-cssrule-interface">
<h4 title="The CSSRule Interface">6.4.2. `CSSRule^I ~interface</h4>

<p>
`CSSRule$I ~interfaceは，抽象的な基底`~CSS規則$を表現する。
各種`~CSS規則$は、
その種別に応じて，この~interfaceを継承する別個な~interfaceで表現される。
◎
The CSSRule interface represents an abstract, base CSS rule. Each distinct CSS rule type is represented by a distinct interface that inherits from this interface.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSRule@I {
  attribute `CSSOMString$ `cssText$m;
  readonly attribute `CSSRule$I? `parentRule$m;
  readonly attribute `CSSStyleSheet$I? `parentStyleSheet$m;

  /* <span class="comment">
以下の属性, 定数は歴史的
◎
the following attribute and constants are historical
</span> */
  readonly attribute `unsigned short$ `type$m;
  const `unsigned short$ `STYLE_RULE@m = 1;
  const `unsigned short$ `CHARSET_RULE@m = 2;
  const `unsigned short$ `IMPORT_RULE@m = 3;
  const `unsigned short$ `MEDIA_RULE@m = 4;
  const `unsigned short$ `FONT_FACE_RULE@m = 5;
  const `unsigned short$ `PAGE_RULE@m = 6;
  const `unsigned short$ `MARGIN_RULE@m = 9;
  const `unsigned short$ `NAMESPACE_RULE@m = 10;
};
</pre>

<p>
`cssText@m
の：
◎
↓</p>
<ul>
	<li class="algo">
取得子~手続きは
⇒
~RET `~CSS規則を直列化する$( コレの`~CSS規則$ )
◎
The cssText attribute must return a serialization of the CSS rule.＼
</li>
	<li class="algo">
設定子~手続きは、
何もしない。
◎
On setting the cssText attribute must do nothing.
</li>
</ul>

<div class="algo">
<p>
`parentRule@m
取得子~手続きは
⇒
~RET コレの`親~規則$
◎
The parentRule attribute must return the parent CSS rule.
</p>

<p class="note">注記：
例えば `media$at は、
規則を封入し得る。
その場合、
`parentRule$m は非 ~NULL になる。
封入する規則がないときの `parentRule$m は ~NULL になる。
◎
Note: For example, @media can enclose a rule, in which case parentRule would be non-null; in cases where there is no enclosing rule, parentRule will be null.
</p>
</div>

<div class="algo">
<p>
`parentStyleSheet@m
取得子~手続きは
⇒
~RET コレの`親~ss$
◎
The parentStyleSheet attribute must return the parent CSS style sheet.
</p>

<p class="note">注記：
~NULLが返されるような唯一の~~状況は、
~CSS~ssから`除去されたとき＠#remove-a-css-rule$である。
◎
Note: The only circumstance where null is returned when a rule has been removed.
</p>

<p class="note">注記：
`文書$から［
`LinkStyle$I ~interfaceを実装する `Node^I
］が除去されても，（それだけでは） `CSSRule$I から `CSSStyleSheet$I への参照は到達できなくなるわけではない。
◎
Note: Removing a Node that implements the LinkStyle interface from a Document instance does not (by itself) cause the CSSStyleSheet referenced by a CSSRule to be unreachable.
</p>
</div>

<div class="algo">
<p>
`type@m
属性は非推奨にされた。
その取得子~手続きは
⇒
~RET コレがどの~interfaceの~instanceであるかに応じて，次の表tに与える整数：
◎
The type attribute is deprecated. It must return an integer, as follows:
</p>

	<div>
<table><thead>
<tr><th>~interface
<th>結果
<tbody>

<tr><td>`CSSStyleRule$I
<td>1

<tr><td>`CSSImportRule$I
<td>3

<tr><td>`CSSMediaRule$I
<td>4

<tr><td>`CSSFontFaceRule$I
<td>5

<tr><td>`CSSPageRule$I
<td>6

<tr><td>`CSSKeyframesRule$I
<td>7

<tr><td>`CSSKeyframeRule$I
<td>8

<tr><td>`CSSMarginRule$I
<td>9

<tr><td>`CSSNamespaceRule$I
<td>10

<tr><td>`CSSCounterStyleRule$I
<td>11

<tr><td>`CSSSupportsRule$I
<td>12

<tr><td>`CSSFontFeatureValuesRule$I
<td>14

<tr><td>その他
<td>0
</table>

◎
If the object is a CSSStyleRule
• Return 1.
If the object is a CSSImportRule
• Return 3.
If the object is a CSSMediaRule
• Return 4.
If the object is a CSSFontFaceRule
• Return 5.
If the object is a CSSPageRule
• Return 6.
If the object is a CSSKeyframesRule
• Return 7.
If the object is a CSSKeyframeRule
• Return 8.
If the object is a CSSMarginRule
• Return 9.
If the object is a CSSNamespaceRule
• Return 10.
If the object is a CSSCounterStyleRule
• Return 11.
If the object is a CSSSupportsRule
• Return 12.
If the object is a CSSFontFeatureValuesRule
• Return 14.
Otherwise
• Return 0.
</div>

<p class="note">注記：
［
整数~列挙／
それら整数を`識別する^emための定数【この事例では `STYLE_RULE$m 等】
］を利用する実施は、
旧来の設計であり，もはや~Web~APIには利用されない。
所与の~objが どの型の規則か知るには、
代わりに %rule.`constructor.name^c を検査することが推奨される
— それは、
`CSSStyleRule^l の様な文字列を返す。
したがって、
この列挙は，現在の状態に凍結される
— 追加的な~at-規則を反映する新たな値が追加されることはなく、
上に挙げたもの以外の~at-規則は，どれも 0 を返すことになる。
◎
Note: The practice of using an integer enumeration and several constants to identify the integers is a legacy design practice that is no longer used in Web APIs. Instead, to tell what type of rule a given object is, it is recommended to check rule.constructor.name, which will return a string like "CSSStyleRule". This enumeration is thus frozen in its current state, and no new new values will be added to reflect additional at-rules; all at-rules beyond the ones listed above will return 0.
</p>
</div>

			</section>
			<section id="the-cssstylerule-interface">
<h4 title="The CSSStyleRule Interface">6.4.3. `CSSStyleRule^I ~interface</h4>

<p>
`CSSStyleRule$I ~interfaceは`~CSS~style規則$を表現する。
◎
The CSSStyleRule interface represents a style rule.
</p>

<p class="trans-note">【
`~CSS~style規則@
とは、
`選択子~list$と`~CSS宣言~block$の組である。
略して “~style規則” とも記される。
】</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSStyleRule@I : `CSSGroupingRule$I {
  attribute `CSSOMString$ `selectorText$m;
  [`SameObject$, `PutForwards$=`CSSStyleDeclaration^I1`cssText$m1] readonly attribute `CSSStyleProperties$I `style$m;
};
</pre>

<p>
`selectorText@m
の：
◎
↓</p>
<ul>
	<li class="algo">
取得子~手続きは
⇒
~RET `選択子~listを直列化する$( コレに結付けられた`選択子~list$ )
◎
The selectorText attribute, on getting, must return the result of serializing the rule’s associated selector list.＼
</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
On setting the selectorText attribute these steps must be run:
</p>
		<ol>
			<li>
%~list ~LET `選択子~listとして構文解析する$( 所与の値 )
◎
Run the parse a group of selectors algorithm on the given value.
</li>
			<li>
~IF［
%~list ~NEQ ~NULL
］
⇒
コレに結付けられた`選択子~list$ ~SET %~list
◎
If the algorithm returns a non-null value replace the associated selector list with the returned value.
◎
Otherwise, if the algorithm returns a null value, do nothing.
</li>
		</ol>
	</li>
</ul>

<div class="algo">
`style@m
取得子~手続きは
⇒
~RET ~style規則~用の［
次のようにされた`~CSS宣言~block$
］を表現する `CSSStyleProperties$I ~obj
⇒＃
`算出-済みか$dB ~SET ~F,
`読専か$dB ~SET ~F,
`宣言~群$dB ~SET この規則の中で宣言された宣言たちが成す`指定d順序$による~list,
`親~CSS規則$dB ~SET コレ,
`所有者~node$dB ~SET ~NULL
◎
The style attribute must return a CSSStyleProperties object for the style rule, with the following properties:
◎
computed flag
• Unset.
readonly flag
• Unset.
declarations
• The declared declarations in the rule, in specified order.
parent CSS rule
• this
owner node
• Null. 
</div>

<p>
`指定d順序@
による宣言~群とは、
その順序は指定された順序と同じであるが，`略式~prop$については`正準的~順序$で`下位prop$たちに展開されているものである。
同じ~propが（`略式~prop$の展開-後に）複数~回~現れる場合、
~cascade法において最高位のもののみが，指定された所に位置するものとして表現するモノトスル。
`CSS3CASCADE$r
◎
The specified order for declarations is the same as specified, but with shorthand properties expanded into their longhand properties, in canonical order. If a property is specified more than once (after shorthand expansion), only the one with greatest cascading order must be represented, at the same relative position as it was specified. [CSS3CASCADE]
</p>

			</section>
			<section id="the-cssimportrule-interface">
<h4 title="The CSSImportRule Interface">6.4.4. `CSSImportRule^I ~interface</h4>

<p>
`CSSImportRule$I ~interfaceは `import$at ~at-規則を表現する。
◎
The CSSImportRule interface represents an @import at-rule.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSImportRule@I : `CSSRule$I {
  readonly attribute `USVString$ `href$m;
  [`SameObject$, `PutForwards$=`mediaText$m] readonly attribute `MediaList$I `media$m;
  [`SameObject$] readonly attribute `CSSStyleSheet$I? `styleSheet$m;
  readonly attribute `CSSOMString$? `layerName$m;
  readonly attribute `CSSOMString$? `supportsText$m;
};
</pre>

<div class="algo">
<p>
`href@m
取得子~手続きは
⇒
~RET コレが表現する `import$at ~at-規則に指定された`~URL^ 【！＊】
◎
The href attribute must return the URL specified by the @import at-rule.
</p>

<p class="note">注記：
解決された URL を取得するには，結付けられた`~CSS~ss$の `StyleSheet.href$m 属性を利用する。
◎
Note: To get the resolved URL use the href attribute of the associated CSS style sheet.
</p>
</div>

<div class="algo">
`media@m
取得子~手続きは
⇒
~RET コレに結付けられた`~CSS~ss$†の`媒体$ss
【†無い場合もあり得るが（下の注記），何を返すか指定されていない。】
【！`StyleSheet.media$m 取得子~手続き()】
◎
The media attribute must return the value of the media attribute of the associated CSS style sheet.
</div>

<div class="algo">
<p>
`styleSheet@m
取得子~手続きは
⇒
~RET コレに結付けられた`~CSS~ss$は［
在るならばそれ／
無いならば ~NULL
］
◎
The styleSheet attribute must return the associated CSS style sheet, if any, or null otherwise.
</p>
</div>

<div class="algo">
<p>
`layerName@m
取得子~手続きは：
</p>
<ol>
	<li>
<p>
~IF［
コレが表現する `import$at ~at-規則は`~cascade層$を宣言している
【すなわち， `layer^v ~keywordか `layer()^v 関数を伴う】
］：
</p>
		<ol>
			<li>
~IF［
宣言された層は匿名である
【すなわち， `layer^v ~keywordを伴う場合】
］
⇒
~RET 空~文字列
</li>
			<li>
~RET 宣言された層の`名前$ly
【すなわち， `layer()^v 関数の引数】
</li>
		</ol>
	</li>
	<li>
~RET ~NULL
</li>
</ol>
◎
The layerName attribute must return the layer name declared in the at-rule itself, or an empty string if the layer is anonymous, or null if the at-rule does not declare a layer.
</div>

<div class="algo">
<p>
`supportsText@m
取得子~手続きは：
</p>
<ol>
	<li>
~IF［
コレが表現する `import$at ~at-規則は `supports-condition$t を宣言している
］
⇒
~RET それ
</li>
	<li>
~RET ~NULL
</li>
</ol>
◎
The supportsText attribute must return the &lt;supports-condition&gt; declared in the at-rule itself, or null if the at-rule does not declare a supports condition.
</div>

<p class="note">注記：
`import$at ~at-規則には、
結付けられる`~CSS~ss$が無いこともある
（例： その【 `import-conditions$t を成す】 `supports()^v 条件に合致するものが無い場合）。
◎
Note: An @import at-rule might not have an associated CSS style sheet (e.g., if it has a non-matching supports() condition).
</p>

			</section>
			<section id="the-cssgroupingrule-interface">
<h4 title="The CSSGroupingRule Interface">6.4.5. `CSSGroupingRule^I ~interface</h4>

<p>
`CSSGroupingRule$I
~interfaceは 自身の内部に他の規則を入子にする~at-規則を表現する。
◎
The CSSGroupingRule interface represents an at-rule that contains other rules nested inside itself.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSGroupingRule@I : `CSSRule$I {
  [`SameObject$] readonly attribute `CSSRuleList$I `cssRules$m;
  `unsigned long$ `insertRule$m(`CSSOMString$ %rule, optional `unsigned long$ %index = 0);
  `undefined$ `deleteRule$m(`unsigned long$ %index);
};
</pre>

<div class="algo">
`cssRules@m
取得子~手続きは
⇒
~RET コレの`子~規則~list$を表現する `CSSRuleList$I ~obj
◎
The cssRules attribute must return a CSSRuleList object for the child CSS rules.
</div>

<div class="algo">
`insertRule(rule, index)@m
~method手続きは
⇒
~RET `~CSS規則~listに規則を挿入する$( コレの`子~規則~list$, %rule, %index, ~T )
◎
The insertRule(rule, index) method must return the result of invoking insert a CSS rule rule into the child CSS rules at index, with the nested flag set.
</div>

<div class="algo">
`deleteRule(index)@m
~method手続きは
⇒
~RET `~CSS規則~listから規則を除去する$( コレの`子~規則~list$, %index )
◎
The deleteRule(index) method must remove a CSS rule from the child CSS rules at index.
</div>

			</section>
			<section id="the-cssmediarule-interface">
<h4 title="The CSSMediaRule Interface">6.4.6. `CSSMediaRule^I ~interface</h4>

<p>
`CSSMediaRule$I ~interfaceは、
`CSS3-CONDITIONAL$r にて定義される。
◎
The CSSMediaRule interface is defined in CSS Conditional Rules. [CSS3-CONDITIONAL]
</p>

			</section>
			<section id="the-csspagerule-interface">
<h4 title="The CSSPageRule Interface">6.4.7. `CSSPageRule^I ~interface</h4>
<p>
`CSSPageRule$I ~interfaceは `page$at ~at-規則を表現する。
◎
The CSSPageRule interface represents an @page at-rule.
</p>

<p class="issue">
次を行うための規則を定義する必要がある
⇒＃
`~CSS~page選択子~listとして構文解析する@,
`~CSS~page選択子~listを直列化する@
◎
Need to define the rules for parse a list of CSS page selectors and serialize a list of CSS page selectors.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSPageDescriptors@I : `CSSStyleDeclaration$I {
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `margin@m;
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `marginTop@m;
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `marginRight@m;
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `marginBottom@m;
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `marginLeft@m;
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `margin-top@m;
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `margin-right@m;
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `margin-bottom@m;
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `margin-left@m;
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `size@m;
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `pageOrientation@m;
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `page-orientation@m;
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `marks@m;
  attribute [`LegacyNullToEmptyString$] `CSSOMString$ `bleed@m;
};

[`Exposed$=Window]
interface `CSSPageRule@I : `CSSGroupingRule$I {
  attribute `CSSOMString$ `selectorText$m;
  [`SameObject$, `PutForwards$=`CSSStyleDeclaration^I1`cssText$m1] readonly attribute `CSSPageDescriptors$I `style$m;
};
</pre>

<p>
`selectorText@m
の：
◎
↓</p>
<ul>
	<li class="algo">
取得子~手続きは
⇒
~RET `~CSS~page選択子~listを直列化する$( コレに結付けられた選択子~list† )
◎
The selectorText attribute, on getting, must return the result of serializing the associated selector list.＼
</li>
	<li class="algo">
<p>
設定子~手続きは：
◎
On setting the selectorText attribute these steps must be run:
</p>
		<ol>
			<li>
%値 ~LET `~CSS~page選択子~listとして構文解析する$( 所与の値 )
◎
Run the parse a list of CSS page selectors algorithm on the given value.
</li>
			<li>
~IF［
%値 ~NEQ ~NULL
］
⇒
コレに結付けられた選択子~list† ~SET %値
◎
If the algorithm returns a non-null value replace the associated selector list with the returned value.
◎
Otherwise, if the algorithm returns a null value, do nothing.
</li>
		</ol>
	</li>
</ul>

<p class="trans-note">【†
原文が参照している`選択子~list$ではなく， `page-selector-list$t 。
】</p>

<div class="algo">
`style@m
取得子~手続きは
⇒
~RET `page$at ~at-規則~用の［
次のようにされた`~CSS宣言~block$
］を表現する `CSSPageDescriptors$I ~obj
⇒＃
`算出-済みか$dB ~SET ~F,
`読専か$dB ~SET ~F,
`宣言~群$dB ~SET この規則の中で宣言された記述子たちが成す`指定d順序$による~list,
`親~CSS規則$dB ~SET コレ,
`所有者~node$dB ~SET ~NULL
◎
The style attribute must return a CSSPageDescriptors object for the @page at-rule, with the following properties:
◎
computed flag
• Unset.
readonly flag
• Unset.
declarations
• The declared descriptors in the rule, in specified order.
parent CSS rule
• this.
owner node
• Null.
</div>

			</section>
			<section id="the-cssmarginrule-interface">
<h4 title="The CSSMarginRule Interface">6.4.8. `CSSMarginRule^I ~interface</h4>

<p>
`CSSMarginRule$I ~interfaceは `page$at ~at-規則の中の
`~margin~at-規則$ （例えば `top-left^at ）を表現する。
`CSS3PAGE$r
◎
The CSSMarginRule interface represents a margin at-rule (e.g. @top-left) in an @page at-rule. [CSS3PAGE]
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSMarginRule@I : `CSSRule$I {
  readonly attribute `CSSOMString$ `name$m;
  [`SameObject$, `PutForwards$=`CSSStyleDeclaration^I1`cssText$m1] readonly attribute `CSSMarginDescriptors^I `style$m;
};
</pre>

<p class="trans-note">【
`CSSMarginDescriptors^I は、
まだ定義されていない。
】</p>

<div class="algo">
`name@m
取得子~手続きは
⇒
~RET コレが表現する`~margin~at-規則$の名前
— 文字 "<code>@</code>" は名前に含まれない
`CSS3SYN$r
◎
The name attribute must return the name of the margin at-rule. The @ character is not included in the name. [CSS3SYN]
</div>

<div class="algo">
`style@m
取得子~手続きは
⇒
~RET `~margin~at-規則$用の［
次のようにされた`~CSS宣言~block$
］を表現する `CSSMarginDescriptors^I ~obj
⇒＃
`算出-済みか$dB ~SET ~F,
`読専か$dB ~SET ~F,
`宣言~群$dB ~SET この規則の中で宣言された宣言たちが成す`指定d順序$による~list,
`親~CSS規則$dB ~SET コレ,
`所有者~node$dB ~SET ~NULL
◎
The style attribute must return a CSSMarginDescriptors object for the margin at-rule, with the following properties:
◎
computed flag
• Unset.
readonly flag
• Unset.
declarations
• The declared declarations in the rule, in specified order. 
parent CSS rule
• this.
owner node
• Null.
</div>

			</section>
			<section id="the-cssnamespacerule-interface">
<h4 title="The CSSNamespaceRule Interface">6.4.9. `CSSNamespaceRule^I ~interface</h4>

<p>
`CSSNamespaceRule$I ~interfaceは `namespace$at ~at-規則を表現する。
◎
The CSSNamespaceRule interface represents an @namespace at-rule.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSNamespaceRule@I : `CSSRule$I {
  readonly attribute `CSSOMString$ `namespaceURI$m;
  readonly attribute `CSSOMString$ `prefix$m;
};
</pre>

<div class="algo">
`namespaceURI@m
取得子~手続きは
⇒
~RET コレの`~ns名$
◎
The namespaceURI attribute must return the namespace of the @namespace at-rule.
</div>

<div class="algo">
`prefix@m
取得子~手続きは
⇒
~RET ［
コレの`~ns接頭辞$は在るならば それ ／
無いならば 空~文字列
］
◎
The prefix attribute must return the prefix of the @namespace at-rule or the empty string if there is no prefix.
</div>

			</section>
		</section>
		<section id="css-declarations">
<h3 title="CSS Declarations">6.5. ~CSS宣言</h3>

<p>
`~CSS宣言@
とは、
~DOMにおいては~objとして公開されない抽象的な概念である。
各 `~CSS宣言$には、
次のものが結付けられる：
◎
A CSS declaration is an abstract concept that is not exposed as an object in the DOM. A CSS declaration has the following associated properties:
</p>

<p class="trans-note">【
［
~prop名: 値
］の組に対応する。
】</p>

<dl class="def-list">
	<dt>
`~prop名@
◎
property name
</dt>
	<dd>
宣言の~prop名
◎
The property name of the declaration. 
</dd>

	<dt>`値@
◎
value
</dt>
	<dd>
宣言の値を成す成分~値たちが成す~listとして表現される
◎
The value of the declaration represented as a list of component values. 
</dd>

	<dt>
`~importantか@
◎
important flag
</dt>
	<dd>
変更-可能な真偽値。
◎
Either set or unset. Can be changed.
</dd>
	<dd class="trans-note">【
`!important^css 宣言の有無に対応する
】</dd>

	<dt>
`文字大小区別か@
◎
case-sensitive flag
</dt>
	<dd>
`~prop名$が その仕様に則って文字大小区別とされているとき ~T にされ, 他の場合は ~F にされる。
◎
Set if the property name is defined to be case-sensitive according to its specification, otherwise unset.
</dd>
	<dd class="trans-note">【
ほぼ，`~custom~prop用＠~CSSVAR#defining-variables$のもの
】</dd>
</dl>

		</section>
		<section id="css-declaration-blocks">
<h3 title="CSS Declaration Blocks">6.6. ~CSS宣言~block</h3>

<p>
`~CSS宣言~block@
とは、
値が結付けられた~CSS~prop（ `~CSS宣言$とも呼ばれる）たちが成す，有順序~collectionである。
~DOMにおいては， `CSSStyleDeclaration$I ~objが`~CSS宣言~block$を表現する。
各 `~CSS宣言~block$には，次に挙げるものが結付けられる：
◎
A CSS declaration block is an ordered collection of CSS properties with their associated values, also named CSS declarations. In the DOM a CSS declaration block is a CSSStyleDeclaration object. A CSS declaration block has the following associated properties:
</p>

<p class="trans-note">【
CSS2 の`宣言~block＠~CSS22/syndata.html#rule-sets$に対応する。
現代の~CSSにおいては、
`block-contents$t に対応する。
したがって、
実際には，~prop宣言に限られない。
】</p>

<dl class="def-list">
	<dt>
`算出-済みか@dB
◎
computed flag
</dt>
	<dd>
~objは算出-済みな~style宣言であるならば ~T に設定される。
他が言明されない限り， ~F にされる。
◎
Set if the object is a computed style declaration, rather than a specified style. Unless otherwise stated it is unset.
</dd>

	<dt>
`読専か@dB
◎
readonly flag
</dt>
	<dd>
~objは改変-不能ならば ~T に設定される。
◎
Set if the object is not modifiable.
</dd>

	<dt>
`宣言~群@dB
◎
declarations
</dt>
	<dd>
~objに結付けられた一連の`~CSS宣言$。
◎
The CSS declarations associated with the object.
</dd>
	<dd class="trans-note">【
宣言~群は，内部的には［
`略式~prop$の宣言は、
その`下位prop$たちに展開-済みとして扱われる
］ように見受けられるが
（`指定d順序$など、
一部の箇所では，そのように指定されてもいる）、
宣言~群は略式~propを包含し得ないものと明示的には定義されておらず，
はっきりしない部分もある。
】</dd>

	<dt>
`親~CSS規則@dB
◎
parent CSS rule
</dt>
	<dd>
`~CSS宣言~block$が結付けられた`~CSS規則$は在るならば それ ／
無いならば ~NULL
◎
The CSS rule that the CSS declaration block is associated with, if any, or null otherwise.
</dd>

	<dt>
`所有者~node@dB
◎
owner node
</dt>
	<dd>
`~CSS宣言~block$が結付けられた `Element$I は在るならば それ ／
無いならば ~NULL
◎
The Element that the CSS declaration block is associated with, if any, or null otherwise.
</dd>

	<dt>
`更新-中か@dB
◎
updating flag
</dt>
	<dd>
真偽値をとり、
既定は ~F とする。
`~CSS宣言~block$が`所有者~node$dBの `style^a 属性を更新している間は ~T にされる。
◎
Unset by default. Set when the CSS declaration block is updating the owner node’s style attribute. 
</dd>
</dl>

<div class="algo">
<p>
`~CSS宣言~blockとして構文解析する@
~algoは、
所与の
( 文字列 %文字列 )
に対し：
◎
To parse a CSS declaration block from a string string, follow these steps:
</p>

<ol>
	<li>
%宣言~list ~LET `~blockの内容を構文解析する$( %文字列 )
◎
Let declarations be the returned declarations from invoking parse a block’s contents with string.
</li>
	<li>
%構文解析した宣言~list ~LET 新たな空~list
◎
Let parsed declarations be a new empty list.
</li>
	<li>
<p>
%宣言~list を成す
~EACH( %宣言 )
に対し：
◎
For each item declaration in declarations, follow these substeps:
</p>
		<ol>
			<li>
%構文解析した宣言 ~LET 適切な~CSS仕様に則って
%宣言 を構文解析し，`無視される$ものは落とした結果
◎
Let parsed declaration be the result of parsing declaration according to the appropriate CSS specifications, dropping parts that are said to be ignored. If the whole declaration is dropped, let parsed declaration be null.
</li>
			<li>
~IF［
前~段により宣言~全体は落とされてはいない（ %構文解析した宣言 は空でない）
］
⇒
%構文解析した宣言~list に %構文解析した宣言 を付加する
◎
If parsed declaration is not null, append it to parsed declarations. 
</li>
		</ol>
	</li>
	<li>
~RET %構文解析した宣言~list
◎
Return parsed declarations.
</li>
</ol>
</div>

<div class="algo">
<p>
`~CSS宣言を直列化する@
~algoは、
所与の
( %~prop名, %値, %~importantか )
に対し：
</p>
<ol>
	<li>
~IF［
%値 は`空白$以外の文字を包含しない
］
⇒
%値 ~SET 空~文字列
</li>
	<li>
%~important ~LET 空~文字列
</li>
	<li>
~IF［
%~importantか ~EQ ~T
］
⇒
%~important ~SET 次を順に`連結する$
⇒＃
~SP,
`!important^l <span class="code-point">(U+0021 U+0069 U+006D U+0070 U+006F U+0072 U+0074 U+0061 U+006E U+0074)</span>
</li>
	<li>
~RET 次を順に`連結する$
⇒＃
%~prop名,
❝:,
~SP,
%値,
%~important,
❝;
</li>
</ol>
◎
To serialize a CSS declaration with property name property, value value and optionally an important flag set, follow these steps:
• Let s be the empty string.
• Append property to s.
• Append ": " (U+003A U+0020) to s.
• If value contains any non-whitespace characters, append value to s.
• If the important flag is set, append " !important" (U+0020 U+0021 U+0069 U+006D U+0070 U+006F U+0072 U+0074 U+0061 U+006E U+0074) to s.
• Append ";" (U+003B) to s.
• Return s.
</div>

<div class="algo">
<p>
`宣言~群を直列化する@
~algoは、
所与の
( `宣言~群$dB %宣言~群 )
に対し：
◎
To serialize a CSS declaration block declaration block means to run the steps below:
</p>

<p class="trans-note">【
原文の~algoは，`~CSS宣言~block$を入力にとるが、
この~algoを利用する他所を簡潔にするため，その`宣言~群$dBを入力にとるよう改めることにする。
】</p>

<ol>
	<li>
%宣言~list ~LET %宣言~群 を`~cloneする$
【以下を簡略化するため、この訳では~cloneする。】
◎
↓</li>
	<li>
%~list ~LET 空~list
◎
Let list be an empty array.
◎
Let already serialized be an empty array.
</li>
	<li>
<p>
%宣言~list を成す
~EACH( `~CSS宣言$ %宣言 )
に対し：
◎
Declaration loop: For each CSS declaration declaration in declaration block’s declarations, follow these substeps:
</p>
		<ol>
			<li>
%~importantか ~LET %宣言 の`~importantか$
◎
↓</li>
			<li>
<p>
%宣言 の`~prop名$ に対応する`略式~prop$たち（無いならば，この段は飛ばす）を成す
~EACH( %略式~prop )
に対し，`選好d順序$で：
◎
Let property be declaration’s property name.
◎
If property is in already serialized, continue with the steps labeled declaration loop.
◎
If property maps to one or more shorthand properties, let shorthands be an array of those shorthand properties, in preferred order.
◎
Shorthand loop: For each shorthand in shorthands, follow these substeps:
</p>
				<ol>
					<li>
%下位prop宣言~list ~LET %宣言~list 内の`~CSS宣言$のうち［
その`~prop名$は、
%略式~prop の ある`下位prop$の名前であるもの
］すべてからなる同順の~list
◎
↓</li>
					<li>
<p>
~IF［
~OR↓
］…
</p>
						<ul>
							<li>
%下位prop宣言~list を成す`~CSS宣言$たちの`~prop名$は、
%略式~prop のすべての`下位prop$の名前を網羅していない
◎
Let longhands be an array consisting of all CSS declarations in declaration block’s declarations that that are not in already serialized and have a property name that maps to one of the shorthand properties in shorthands.
◎
If all properties that map to shorthand are not present in longhands, continue with the steps labeled shorthand loop.
◎
Let current longhands be an empty array.
◎
Append all CSS declarations in longhands that have a property name that maps to shorthand to current longhands.
</li>
							<li>
%下位prop宣言~list 内に次を満たす`~CSS宣言$が在る
⇒
`~importantか$ ~NEQ %~importantか
◎
If there is one or more CSS declarations in current longhands have their important flag set and one or more with it unset, continue with the steps labeled shorthand loop.
</li>
							<li>
<p>
%宣言~list 内に ~AND↓ を満たす`~CSS宣言$が在る：
</p>
								<ul>
									<li>
%下位prop宣言~list には含まれない
</li>
									<li>
%宣言~list 内で［
%下位prop宣言~list を成す最初の宣言【すなわち %宣言 】から最後の宣言
］の合間にある
</li>
									<li>
%下位prop宣言~list 内の ある下位prop【どれでもよい】と同じ`論理-~prop~group$に属するが，`対応付け~logic$は異なる
</li>
								</ul>
◎
If there’s any declaration in declaration block in between the first and the last longhand in current longhands which belongs to the same logical property group, but has a different mapping logic as any of the longhands in current longhands, and is not in current longhands, continue with the steps labeled shorthand loop.
</li>
						</ul>
<p>
…ならば
⇒
~CONTINUE
◎
↑</p>
					</li>
					<li>
%値 ~LET `下位prop~listを直列化する$( %下位prop宣言~list )
◎
Let value be the result of invoking serialize a CSS value of current longhands.
</li>
					<li>
~IF［
%値 ~EQ 空~文字列
］
⇒
~CONTINUE
◎
If value is the empty string, continue with the steps labeled shorthand loop.
</li>
					<li>
%~list に次の結果を`付加する$
⇒
`~CSS宣言を直列化する$( %略式~prop, %値, %~importantか )
◎
Let serialized declaration be the result of invoking serialize a CSS declaration with property name shorthand, value value, and the important flag set if the CSS declarations in current longhands have their important flag set.
◎
Append serialized declaration to list.
</li>
					<li>
%宣言~list から %下位prop宣言~list を成すすべての宣言を`除去する$
◎
Append the property names of all items of current longhands to already serialized.
</li>
					<li>
~GOTO `最後^i
◎
Continue with the steps labeled declaration loop.
</li>
				</ol>
			</li>
			<li>
%値 ~LET `~CSS値を直列化する$( %宣言 )
◎
Let value be the result of invoking serialize a CSS value of declaration.
</li>
			<li>
%~list に次の結果を`付加する$
⇒
`~CSS宣言を直列化する$( %宣言 の`~prop名$, %値, %~importantか )
◎
Let serialized declaration be the result of invoking serialize a CSS declaration with property name property, value value, and the important flag set if declaration has its important flag set.
◎
Append serialized declaration to list.
</li>
			<li>
%宣言~list から %宣言 を`除去する$
◎
Append property to already serialized.
</li>
			<li>
`最後^i：
（何もしない）
◎
↑</li>
		</ol>
	</li>
	<li>
~RET %~list を~SPで`連結する$
◎
Return list joined with " " (U+0020).
</li>
</ol>

<p class="note">注記：
空な`~CSS宣言~block$を直列化した結果は、
空~文字列になる。
◎
Note: The serialization of an empty CSS declaration block is the empty string.
</p>

<p class="note">注記：
空でない`~CSS宣言~block$を直列化した結果の［
先頭／末尾
］には，空白は含まれない。
すなわち、［
最初の~prop名の前, および最後の~prop値の最後の~semicolon区切子の後
］には，空白は現れない。
◎
Note: The serialization of a non-empty CSS declaration block does not include any surrounding whitespace, i.e., no whitespace appears before the first property name and no whitespace appears after the final semicolon delimiter that follows the last property value.
</p>
</div>

<div class="algo">
<p>
`~CSS宣言~block$~obj %O の`所有者~node$dB用の`属性~変更-時の手続き$は、
所与の
( %局所~名, %旧-値, %値, %~ns )
に対し：
◎
A CSS declaration block has these attribute change steps for its owner node with localName, value, and namespace:
</p>

<ol>
	<li>
~IF［
%O の`算出-済みか$dB ~EQ ~T
］
⇒
~RET
◎
If the computed flag is set, then return.
</li>
	<li>
~IF［
%O の`更新-中か$dB ~EQ ~T
］
⇒
~RET
◎
If the updating flag is set, then return.
</li>
	<li>
~IF［
%局所~名 ~NEQ `style^l
］~OR［
%~ns ~NEQ ~NULL
］
⇒
~RET
◎
If localName is not "style", or namespace is not null, then return.
</li>
	<li>
~IF［
%値 ~EQ ~NULL
］
⇒
%O の`宣言~群$dBを空にする
◎
If value is null, empty the declarations.
</li>
	<li>
~ELSE
⇒
%O の`宣言~群$dB ~SET `~CSS宣言~blockとして構文解析する$( %値 )
◎
Otherwise, let the declarations be the result of parse a CSS declaration block from a string value.
</li>
</ol>
</div>

<div class="algo">
<p>
`~CSS宣言~block$~obj %O の作成-時には、
次を走らす：
◎
When a CSS declaration block object is created, then:
</p>

<ol>
	<li>
%所有者~node ~LET %O の`所有者~node$dB
◎
Let owner node be the owner node.
</li>
	<li>
~IF［
%所有者~node ~EQ ~NULL
］~OR［
%O の`算出-済みか$dB ~EQ ~T
］
⇒
~RET
◎
If owner node is null, or the computed flag is set, then return.
</li>
	<li>
%値 ~LET %所有者~node の`属性を~nsと局所~名により取得する$( ~NULL, `style^l )
◎
Let value be the result of getting an attribute given null, "style", and owner node.
</li>
	<li>
~IF［
%値 ~NEQ ~NULL
］
⇒
%O の`宣言~群$dB ~SET `~CSS宣言~blockとして構文解析する$( %値 )
◎
If value is not null, let the declarations be the result of parse a CSS declaration block from a string value.
</li>
</ol>
</div>

<div class="algo">
<p>
`~CSS宣言~block$~obj %O 用の
`~style属性を更新する@
~algoは：
◎
To update style attribute for declaration block means to run the steps below:
</p>
<ol>
	<li>
~Assert：
%O の`算出-済みか$dB ~EQ ~F
◎
Assert: declaration block’s computed flag is unset.
</li>
	<li>
%所有者~node ~LET %O の`所有者~node$dB
◎
Let owner node be declaration block’s owner node.
</li>
	<li>
~IF［
%所有者~node ~EQ ~NULL
］
⇒
~RET
◎
If owner node is null, then return.
</li>
	<li>
%O の`更新-中か$dB ~SET ~T
◎
Set declaration block’s updating flag.
</li>
	<li>
%所有者~node の`属性~値を設定する$( `style^l, `宣言~群を直列化する$( %O の`宣言~群$dB ) )
◎
Set an attribute value for owner node using "style" and the result of serializing declaration block.
</li>
	<li>
%O の`更新-中か$dB ~SET ~F
◎
Unset declaration block’s updating flag.
</li>
</ol>
</div>

<div class="algo">
<p>
`略式~prop$たちが成す~list %略式~prop~list の
`選好d順序@
は、
次に従う：
◎
The preferred order of a list of shorthand properties shorthands is as follows:
</p>
<ol>
	<li>
%略式~prop~list を辞書式~順序に~~整列する
◎
Order shorthands lexicographically.
</li>
	<li>
%略式~prop~list を成す~itemのうち次を満たすものを
— それらの相対的~順序を保ったまま —
~listの末尾へ回す
⇒
❝- から始まる
◎
Move all items in shorthands that begin with "-" (U+002D) last in the list, retaining their relative order.
</li>
	<li>
%略式~prop~list を成す~itemのうち次を満たすものを
— それらの相対的~順序を保ったまま —
~listの末尾へ回す
⇒
［
❝- から始まる
］~AND［
`-webkit-^l からは始まらない
］
◎
Move all items in shorthands that begin with "-" (U+002D) but do not begin with "-webkit-" last in the list, retaining their relative order.
</li>
	<li>
<p>
%略式~prop~list を
【先行の段で末尾に回されたものは，その順位を保ちつつ？】
対応する`下位prop$の個数が多い順に並べる
◎
Order shorthands by the number of longhand properties that map to it, with the greatest number first.
</p>

<p class="trans-note">【
例えば
`border-style$p よりも `border$p の方が `末端の^em `下位prop$の個数が多くなるので，先に来るものと考えられる。
】</p>

	</li>
</ol>
</div>

			<section id="the-cssstyledeclaration-interface">
<h4 title="The CSSStyleDeclaration Interface">6.6.1. `CSSStyleDeclaration^I ~interface</h4>

<p>
`CSSStyleDeclaration$I
~interfaceは，下層の状態も含めた`~CSS宣言~block$を表現する。
この下層の状態は `CSSStyleDeclaration$I ~instanceの~sourceに依存する。
◎
The CSSStyleDeclaration interface represents a CSS declaration block, including its underlying state, where this underlying state depends upon the source of the CSSStyleDeclaration instance.
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSStyleDeclaration@I {
  [`CEReactions$] attribute `CSSOMString$ `cssText$m;
  readonly attribute `unsigned long$ `length$m;
  getter `CSSOMString$ `item$m(`unsigned long$ %index);
  `CSSOMString$ `getPropertyValue$m(`CSSOMString$ %property);
  `CSSOMString$ `getPropertyPriority$m(`CSSOMString$ %property);
  [`CEReactions$] `undefined$ `setProperty$m(
      `CSSOMString$ %property,
      [`LegacyNullToEmptyString$] `CSSOMString$ %value,
      optional [`LegacyNullToEmptyString$] `CSSOMString$ %priority = ""
  );
  [`CEReactions$] `CSSOMString$ `removeProperty$m(`CSSOMString$ %property);
  readonly attribute `CSSRule$I? `parentRule$m;
};

[`Exposed$=Window]
interface `CSSStyleProperties@I : `CSSStyleDeclaration$I {
  [`CEReactions$] attribute [`LegacyNullToEmptyString$] `CSSOMString$ `cssFloat$m;
};
</pre>

<!--＊ `CSSStyleDeclaration@I -->
<p>
~objが`~supportする~prop~index$は、
0 以上［
コレの`宣言~群$dBに含まれている`~CSS宣言$の総数
］未満とする。
◎
The object’s supported property indices are the numbers in the range zero to one less than the number of CSS declarations in the declarations. If there are no such CSS declarations, then there are no supported property indices.
</p>

<p>
`cssText@m
の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
◎
Getting the cssText attribute must run these steps:
</p>
		<ol>
			<li>
~IF［
コレの`算出-済みか$dB ~EQ ~T
］
⇒
~RET 空~文字列
◎
If the computed flag is set, then return the empty string.
</li>
			<li>
~RET `宣言~群を直列化する$( コレの`宣言~群$dB )
◎
Return the result of serializing the declarations.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
`cssText$m 設定子~手続きは：
◎
Setting the cssText attribute must run these steps:
</p>
		<ol>
			<li>
~IF［
コレの`読専か$dB ~EQ ~T
］
⇒
~THROW `NoModificationAllowedError$E
◎
If the readonly flag is set, then throw a NoModificationAllowedError exception.
</li>
			<li>
コレの`宣言~群$dBを空にする
◎
Empty the declarations.
</li>
			<li>
%~item群 ~LET `~CSS宣言~blockとして構文解析する$( 所与の値 )
◎
Parse the given value and,＼
</li>
			<li>
%~item群 を`指定d順序$による~listに変換した結果を成す
~EACH( %宣言 )
に対し
⇒
コレの`宣言~群$dBに %宣言 を`付加する$
◎
if the return value is not the empty list, insert the items in the list into the declarations, in specified order.
</li>
			<li>
コレ用の`~style属性を更新する$
◎
Update style attribute for the CSS declaration block.
</li>
		</ol>
	</li>
</ul>

<div class="algo">
`length@m
取得子~手続きは
⇒
~RET コレの`宣言~群$dBに含まれている`~CSS宣言$の個数
◎
The length attribute must return the number of CSS declarations in the declarations.
</div>

<div class="algo">
`item(index)@m
~method手続きは
⇒
~RET コレの`宣言~群$dB内の %index 番の`~CSS宣言$の`~prop名$
◎
The item(index) method must return the property name of the CSS declaration at position index.
</div>

<div class="algo">
<p>
`getPropertyValue(property)@m
~method手続きは：
◎
The getPropertyValue(property) method must run these steps:
</p>
<ol>
	<li>
<p>
~IF［
%property は`~custom~prop名$でない
］：
◎
If property is not a custom property, follow these substeps:
</p>
		<ol>
			<li>
%property ~LET `~ASCII小文字~化する$( %property )
◎
Let property be property converted to ASCII lowercase.
</li>
			<li>
<p>
~IF［
%property は ある`略式~prop$の名前である
］：
</p>
				<ol>
					<li>
コレの`宣言~群$dBを成す
~EACH( `~CSS宣言$ %宣言 )
に対し
⇒
~IF［
%宣言 の`~prop名$ ~NIN %property の`下位prop$の名前たちが成す集合
］~OR［
%宣言 の`~importantか$ ~NEQ コレの`宣言~群$dBを成す最初の宣言の`~importantか$
］
⇒
~RET 空~文字列
</li>
					<li>
~RET `下位prop~listを直列化する$( コレの`宣言~群$dBを`正準的~順序$に~sortした結果の~list )
</li>
				</ol>
◎
If property is a shorthand property, then follow these substeps:
• Let list be a new empty array.
• For each longhand property longhand that property maps to, in canonical order, follow these substeps:
•• If longhand is a case-sensitive match for a property name of a CSS declaration in the declarations, let declaration be that CSS declaration, or null otherwise.
•• If declaration is null, then return the empty string.
•• Append the declaration to list.
• If important flags of all declarations in list are same, then return the serialization of list.
• Return the empty string. 
</li>
		</ol>
	</li>
	<li>
コレの`宣言~群$dBを成す
~EACH( `~CSS宣言$ %宣言 )
に対し
⇒
~IF［
%宣言 の`~prop名$ ~EQ %property
］
⇒
~RET `~CSS値を直列化する$( %宣言 )
◎
If property is a case-sensitive match for a property name of a CSS declaration in the declarations, then return the result of invoking serialize a CSS value of that declaration.
</li>
	<li>
~RET 空~文字列
◎
Return the empty string.
</li>
</ol>
</div>

<div class="algo">
<p>
`getPropertyPriority(property)@m
~method手続きは：
◎
The getPropertyPriority(property) method must run these steps:
</p>
<ol>
	<li>
<p>
~IF［
%property は`~custom~prop名$でない
］：
◎
If property is not a custom property, follow these substeps:
</p>
		<ol>
			<li>
%property ~LET `~ASCII小文字~化する$( %property )
◎
Let property be property converted to ASCII lowercase.
</li>
			<li>
<p>
~IF［
%property は`略式~prop$の名前である
］：
◎
If property is a shorthand property, follow these substeps:
</p>
				<ol>
					<li>
%property に対応する
~EACH( `下位prop$ %下位prop )
に対し
⇒
~IF［
コレ上の `getPropertyPriority$m ~method手続き( %下位prop ) の結果
~NEQ `important^l
］
⇒
~RET 空~文字列
◎
Let list be a new array.
◎
For each longhand property longhand that property maps to, append the result of invoking getPropertyPriority() with longhand as argument to list.
</li>
					<li>
~RET `important^l
◎
If all items in list are the string "important", then return the string "important".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
コレの`宣言~群$dBを成す
~EACH( `~CSS宣言$ %宣言 )
に対し
⇒
~IF［
%宣言 の`~prop名$ ~EQ %property
］~AND［
%宣言 の`~importantか$ ~EQ ~T
］
⇒
~RET `important^l
◎
If property is a case-sensitive match for a property name of a CSS declaration in the declarations that has the important flag set, return the string "important".
</li>
	<li>
~RET 空~文字列
◎
Return the empty string.
</li>
</ol>

<p class="example">
例えば
<code class="css">background-color:`lime^v !IMPORTANT;</code>
に対し 返される値は `important^l になるであろう。
◎
E.g. for background-color:lime !IMPORTANT the return value would be "important".
</p>
</div>

<div class="algo">
<p>
`setProperty(property, value, priority)@m
~method手続きは：
◎
The setProperty(property, value, priority) method must run these steps:
</p>
<ol>
	<li>
~IF［
コレの`読専か$dB ~EQ ~T
］
⇒
~THROW `NoModificationAllowedError$E
◎
If the readonly flag is set, then throw a NoModificationAllowedError exception.
</li>
	<li>
<p>
~IF［
%property は`~custom~prop名$でない
］：
◎
If property is not a custom property, follow these substeps:
</p>
		<ol>
			<li>
%property ~LET `~ASCII小文字~化する$( %property )
◎
Let property be property converted to ASCII lowercase.
</li>
			<li>
~IF［
%property は `~supportされる~CSS~prop$でない
］
⇒
~RET
◎
If property is not a case-sensitive match for a supported CSS property, then return. 
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%value ~EQ 空~文字列
］：
</p>
		<ol>
			<li>
コレ上の `removeProperty$m ~method手続き( %property )
</li>
			<li>
~RET
</li>
		</ol>
◎
If value is the empty string, invoke removeProperty() with property as argument and return.
</li>
	<li>
~IF［
%priority ~NIN `大小無視$sub {  空~文字列, `important^l }
］
⇒
~RET
◎
If priority is not the empty string and is not an ASCII case-insensitive match for the string "important", then return. 
</li>
	<li>
<p>
%成分~値~list ~LET
`~CSS値として構文解析する$( %value, %property )
◎
Let component value list be the result of parsing value for property property.
</p>

<p class="note">注記：
%value は `!important^l を含み得ない。
◎
Note: value can not include "!important".
</p>
	</li>
	<li>
~IF［
%成分~値~list ~EQ ~NULL
］
⇒
~RET
◎
If component value list is null, then return.
</li>
	<li>
%~importantか ~LET ~IS［
%priority ~NEQ 空~文字列
］
◎
↓</li>
	<li>
%更新されたか ~LET ~F
◎
Let updated be false. 
</li>
	<li>
<p>
~IF［
%property はある`略式~prop$の名前である
］：
◎
If property is a shorthand property, then＼
</p>
		<ol>
			<li>
<p>
%property に対応する
~EACH( `下位prop$ %下位prop )
に対し，`正準的~順序$で：
◎
for each longhand property longhand that property maps to, in canonical order, follow these substeps:
</p>
				<ol>
					<li>
%変化したか ~LET `~CSS宣言を設定する$( ↓ )
⇒＃
コレの`宣言~群$dB,
%下位prop,
%成分~値~list 内の %下位prop の値を成す部分,
%~importantか
◎
Let longhand result be the result of set the CSS declaration longhand with the appropriate value(s) from component value list, with the important flag set if priority is not the empty string, and unset otherwise, and with the list of declarations being the declarations.
</li>
					<li>
~IF［
%変化したか ~EQ ~T
］
⇒
%更新されたか ~SET ~T
◎
If longhand result is true, let updated be true.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%更新されたか ~LET `~CSS宣言を設定する$( ↓ )
⇒＃
コレの`宣言~群$dB,
%property,
%成分~値~list,
%~importantか
◎
Otherwise, let updated be the result of set the CSS declaration property with value component value list, with the important flag set if priority is not the empty string, and unset otherwise, and with the list of declarations being the declarations.
</li>
	<li>
~IF［
%更新されたか ~EQ ~T
］
⇒
コレ用の`~style属性を更新する$
◎
If updated is true, update style attribute for the CSS declaration block.
</li>
</ol>
</div>

<div class="algo">
<p>
`~CSS宣言を設定する@
~algoは、
所与の
( %宣言~list, %~prop名, %成分~値~list, %~importantか )
に対し，［
遂行した後に，次に挙げるすべての拘束を保持する
］ような手続きを走らす：
◎
To set a CSS declaration property with a value component value list and optionally with an important flag set, in a list of declarations declarations, the user agent must ensure the following constraints hold after its steps:
</p>
<ul>
	<li>
%宣言~list 内に次を満たす`~CSS宣言$
— 以下， %~target宣言 と記される —
が正確に 1 個だけ存在する
⇒
`~prop名$ ~EQ %~prop名
◎
Exactly one CSS declaration whose property name is a case-sensitive match of property must exist in declarations. Such declaration is referenced as the target declaration below.
</li>
	<li>
%~target宣言 の値 ~EQ %成分~値~list
◎
The target declaration must have value being component value list, and＼
</li>
	<li>
%~target宣言 の`~importantか$ ~EQ %~importantか
◎
target declaration’s important flag must be set if important flag is set, and unset otherwise.
</li>
	<li>
%宣言~list 内に在った， %~target宣言 以外の どの`~CSS宣言$も［
変更-／挿入-／除去-
］されていない。
◎
Any CSS declaration which is not the target declaration must not be changed, inserted, or removed from declarations.
</li>
	<li>
%宣言~list 内には、
%~target宣言 より後には，次を満たす`~CSS宣言$ %宣言 は無い
⇒
［
%宣言 の`~prop名$, %~prop名
］は、
同じ`論理-~prop~group$に属するが，`対応付け~logic$は異なる
◎
If there are CSS declarations in declarations whose property name is in the same logical property group as property, but has a different mapping logic, target declaration must be at an index after all of those CSS declarations.
</li>
	<li>
手続きは、
その結果として［
%宣言~list の直列化は変化したならば ~T ／
~ELSE_ ~F
］を返す。
◎
The steps must return true if the serialization of declarations was changed as result of the steps. It may return false otherwise.
</li>
</ul>
</div>

<p class="issue">
“%宣言~list の外側では，観測-可能な いかなる副作用も生じないモノトスル”
の様な何かを追加するべきか？
現在の拘束は、
定義されない挙動について，穴がありそうだ。
◎
Should we add something like "Any observable side effect must not be made outside declarations"? The current constraints sound like a hole for undefined behavior.
</p>

<p class="note">注記：
`~CSS宣言を設定する$ための【具体的な】手続きは、
この~levelの~CSSOMにおいては定義されない。
~UAは、
上の拘束が保持される限り，異なる~algoを利用してもヨイ。
◎
Note: The steps of set a CSS declaration are not defined in this level of CSSOM. User agents may use different algorithms as long as the constraints above hold.
</p>

<div class="example">

<p>
拘束に適合する最も単純な仕方は、
常に，［
%~prop名 に合致している既存の宣言があれば，それらは除去して、
新たな宣言を末尾に付加する
］ものになるであろう。
が、
実装~feedbackから，この~approachは処理能を~~犠牲にする見込みが高い。
◎
The simplest way to conform with the constraints would be to always remove any existing declaration matching property, and append the new declaration to the end. But based on implementation feedback, this approach would likely regress performance.
</p>

<p>
可能な別の~algoは：
◎
Another possible algorithm is:
</p>
<ol>
	<li>
<p>
~IF［
%宣言~list 内に［
`~prop名$ ~EQ %~prop名
］を満たす`~CSS宣言$ %~target宣言 が在る
］：
◎
If property is a case-sensitive match for a property name of a CSS declaration in declarations, follow these substeps:
• Let target declaration be such CSS declaration.
</p>
		<ol>
			<li>
%付加する必要があるか ~LET ~F
◎
Let needs append be false.
</li>
			<li>
<p>
%宣言~list 内の %~target宣言 より後にある
~EACH( %宣言 )
に対し：
◎
For each declaration in declarations after target declaration:
</p>
				<ol>
					<li>
~IF［［
%宣言 の`~prop名$, %~prop名
］は、
同じ`論理-~prop~group$に属する
］
⇒
~CONTINUE
◎
If declaration’s property name is not in the same logical property group as property, then continue.
</li>
					<li>
~IF［［
%宣言 の`~prop名$, %~prop名
］の`対応付け~logic$は同じである
］
⇒
~CONTINUE
◎
If declaration’ property name has the same mapping logic as property, then continue.
</li>
					<li>
%付加する必要があるか ~LET ~T
◎
Let needs append be true.
</li>
					<li>
~BREAK
◎
Break.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%付加する必要があるか ~EQ ~F
］
⇒
:
◎
If needs append is false, then:
</p>
				<ol>
					<li>
%更新する必要があるか ~LET ~F
◎
Let needs update be false.
</li>
					<li>
~IF［
%~target宣言 の`値$ ~NEQ %成分~値~list
］
⇒
%更新する必要があるか ~LET ~T
◎
If target declaration’s value is not equal to component value list, then let needs update be true.
</li>
					<li>
~IF［
%~target宣言 の`~importantか$ ~NEQ %~importantか
］
⇒
%更新する必要があるか ~LET ~T
◎
If target declaration’s important flag is not equal to whether important flag is set, then let needs update be true.
</li>
					<li>
~IF［
%更新する必要があるか ~EQ ~F
］
⇒
~RET ~F
◎
If needs update is false, then return false.
</li>
					<li>
%~target宣言 の`値$ ~SET %成分~値~list
◎
Set target declaration’s value to component value list.
</li>
					<li>
%~target宣言 の`~importantか$ ~SET %~importantか ~EQ ~T
◎
If important flag is set, then set target declaration’s important flag, otherwise unset it.
</li>
					<li>
~RET ~T
◎
Return true.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%宣言~list から %~target宣言 を除去する
◎
Otherwise, remove target declaration from declarations.
</li>
		</ol>
	</li>
	<li>
%宣言 ~LET 新たな`~CSS宣言$
— その
⇒＃
`~prop名$ ~SET %~prop名,
`値$ ~SET %成分~値~list,
`~importantか$ ~SET %~importantか
◎
↓</li>
	<li>
%宣言~list %宣言 を`付加する$
◎
Append a new CSS declaration with property name property, value component value list, and important flag set if important flag is set to declarations.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`removeProperty(property)@m
~method手続きは：
◎
The removeProperty(property) method must run these steps:
</p>
<ol>
	<li>
~IF［
コレの`読専か$dB ~EQ ~T
］
⇒
~THROW `NoModificationAllowedError$E
◎
If the readonly flag is set, then throw a NoModificationAllowedError exception.
</li>
	<li>
~IF［
%property は`~custom~prop名$でない
］
⇒
%property ~SET `~ASCII小文字~化する$( %property )
◎
If property is not a custom property, let property be property converted to ASCII lowercase. 
</li>
	<li>
%値 ~LET
コレ上の `getPropertyValue$m ~method手続き( %property )
◎
Let value be the return value of invoking getPropertyValue() with property as argument.
</li>
	<li>
%名前~群 ~LET %property に応じて
⇒＃
ある`略式~prop$の名前であるならば その`下位prop$の名前たちが成す集合 ／
~ELSE_ %property のみからなる集合
◎
↓</li>
	<li>
%除去されたか ~LET ~F
◎
Let removed be false.
</li>
	<li>
コレの`宣言~群$dBを成す
~EACH( `~CSS宣言$ %宣言 )
に対し
⇒
~IF［
%宣言 の`~prop名$ ~IN %名前~群
］
⇒＃
コレの`宣言~群$dBから %宣言 を除去する；
%除去されたか ~SET ~T
◎
If property is a shorthand property, for each longhand property longhand that property maps to:
• If longhand is not a property name of a CSS declaration in the declarations, continue.
• Remove that CSS declaration and let removed be true.
◎
Otherwise, if property is a case-sensitive match for a property name of a CSS declaration in the declarations, remove that CSS declaration and let removed be true.
</li>
	<li>
~IF［
%除去されたか ~EQ ~T
］
⇒
コレ用の`~style属性を更新する$
◎
If removed is true, Update style attribute for the CSS declaration block.
</li>
	<li>
~RET %値
◎
Return value.
</li>
</ol>
</div>

<div class="algo">
`parentRule@m
取得子~手続きは
⇒
~RET コレの`親~CSS規則$dB
◎
The parentRule attribute must return the parent CSS rule.
</div>

<p>
`CSSStyleProperties^I1
`cssFloat@m1
の：
◎
↓</p>
<ul>
	<li class="algo">
取得子~手続きは
⇒
~RET コレ上の `getPropertyValue$m ~method手続き( `float^l )
◎
The cssFloat attribute, on getting, must return the result of invoking getPropertyValue() with float as argument.＼
</li>
	<li class="algo">
設定子~手続きは
⇒
コレ上の `setProperty$m ~method手続き( `float^l, 所与の値 )
（ 3 個目の引数は省略する, 例外は投出し直す）
◎
On setting, the attribute must invoke setProperty() with float as first argument, as second argument the given value, and no third argument. Any exceptions thrown must be re-thrown.
</li>
</ul>

<p>
`~supportされる~CSS~prop$を成す各~prop名 %~prop名 に対しては、
次の部分的~interfaceが適用される
— そこでの `~camel_cased_attr$m は、
次を走らせて得される識別子になるとする
⇒
`~IDL属性~名に変換する$( %~prop名 )
◎
For each CSS property property that is a supported CSS property, the following partial interface applies where camel-cased attribute is obtained by running the CSS property to IDL attribute algorithm for property.
</p>

<pre class="idl">
partial interface `CSSStyleProperties$I {
  [`CEReactions$] attribute [`LegacyNullToEmptyString$] `CSSOMString$ _`~camel_cased_attr$m;
};
</pre>

<p class="trans-note">【
~IDLにおいて名前の先頭に現れる ❝_ は、
属性の識別子の一部を成さないことに注意
— それは、
~escapeを指示する，~IDL構文の一部である
（下に定義される部分的~interfaceも同様）。
】</p>

<p>
`~camel_cased_attr@m
の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
</p>
		<ol>
			<li>
%~prop名 ~LET `~CSS~prop名に変換する$( この属性の名前 )
</li>
			<li>
~RET コレ上の `getPropertyValue$m ~method手続き( %~prop名 )
</li>
		</ol>
◎
The camel-cased attribute attribute, on getting, must return the result of invoking getPropertyValue() with the argument being the result of running the IDL attribute to CSS property algorithm for camel-cased attribute.
</li>
	<li class="algo">
<p>
設定子~手続きは：
</p>
		<ol>
			<li>
%~prop名 ~LET `~CSS~prop名に変換する$( この属性の名前 )
</li>
			<li>
コレ上の `setProperty$m ~method手続き( %~prop名, 所与の値 )
（ 3 個目の引数は省略する, 例外は投出し直す）
</li>
		</ol>
◎
Setting the camel-cased attribute attribute must invoke setProperty() with the first argument being the result of running the IDL attribute to CSS property algorithm for camel-cased attribute, as second argument the given value, and no third argument. Any exceptions thrown must be re-thrown.
</li>
</ul>

<p class="example">
例えば `font-size$p ~propに対しては， `fontSize^m ~IDL属性が在ることになる。
◎
For example, for the font-size property there would be a fontSize IDL attribute.
</p>

<p>
`~supportされる~CSS~prop$を成す各~prop名 %~prop名 のうち，その頭部は文字列 `-webkit-^l に一致するものに対しては、
次の部分的~interfaceが適用される
— そこでの `~webkit_cased_attr$m は、
次を走らせて得される識別子になるとする
⇒
`~IDL属性~名に変換する$( %~prop名, ~T )
◎
For each CSS property property that is a supported CSS property and that begins with the string -webkit-, the following partial interface applies where webkit-cased attribute is obtained by running the CSS property to IDL attribute algorithm for property, with the lowercase first flag set.
</p>

<pre class="idl">
partial interface `CSSStyleProperties$I {
  [`CEReactions$] attribute [`LegacyNullToEmptyString$] `CSSOMString$ _`~webkit_cased_attr$m;
};
</pre>

<p>
`~webkit_cased_attr@m
の：
◎
↓</p>
<ul>
	<li class="algo">
<p>
取得子~手続きは：
</p>
		<ol>
			<li>
%~prop名 ~LET `~CSS~prop名に変換する$( この属性の名前, ~T )
</li>
			<li>
~RET コレ上の `getPropertyValue$m ~method手続き( %~prop名 )
</li>
		</ol>
◎
The webkit-cased attribute attribute, on getting, must return the result of invoking getPropertyValue() with the argument being the result of running the IDL attribute to CSS property algorithm for webkit-cased attribute, with the dash prefix flag set.
</li>
	<li class="algo">
<p>
設定子~手続きは：
</p>
		<ol>
			<li>
%~prop名 ~LET `~CSS~prop名に変換する$( この属性の名前, ~T )
</li>
			<li>
コレ上の `setProperty$m ~method手続き( %~prop名, 所与の値 )
（ 3 個目の引数は省略する, 例外は投出し直す）
</li>
		</ol>
◎
Setting the webkit-cased attribute attribute must invoke setProperty() with the first argument being the result of running the IDL attribute to CSS property algorithm for webkit-cased attribute, with the dash prefix flag set, as second argument the given value, and no third argument. Any exceptions thrown must be re-thrown.
</li>
</ul>

<p class="example">
例えば，~UAが `-webkit-transform$p ~propを~supportするならば、
`webkitTransform^m ~IDL属性が在ることになる。
`~camel_cased_attr$m 属性~用の規則により，
`WebkitTransform^m ~IDL属性も在ることになる。
◎
For example, if the user agent supports the -webkit-transform property, there would be a webkitTransform IDL attribute. There would also be a WebkitTransform IDL attribute because of the rules for camel-cased attributes.
</p>

<p>
`~supportされる~CSS~prop$を成す各~prop名 %~prop名 のうち，
❝- を含むものに対しては、
次の部分的~interfaceが適用される
— そこでの `~dashed_attr$m は %~prop名 になるとする：
◎
For each CSS property property that is a supported CSS property, except for properties that have no "-" (U+002D) in the property name, the following partial interface applies where dashed attribute is property.
</p>

<pre class="idl">
partial interface `CSSStyleProperties$I {
  [`CEReactions$] attribute [`LegacyNullToEmptyString$] `CSSOMString$ _`~dashed_attr$m;
};
</pre>

<p>
`~dashed_attr@m
の：
◎
↓</p>
<ul>
	<li class="algo">
取得子~手続きは
⇒
~RET コレ上の `getPropertyValue$m ~method手続き( この属性の名前 )
◎
The dashed attribute attribute, on getting, must return the result of invoking getPropertyValue() with the argument being dashed attribute.
</li>
	<li class="algo">
<p>
設定子~手続きは
⇒
コレ上の `setProperty$m ~method手続き( この属性の名前, 所与の値 )
（ 3 個目の引数は省略する, 例外は投出し直す）
◎
Setting the dashed attribute attribute must invoke setProperty() with the first argument being dashed attribute, as second argument the given value, and no third argument. Any exceptions thrown must be re-thrown.
</li>
</ul>

<div class="example">
<p>
例えば `font-size$p ~propに対しては、
~IDL属性 `font-size^m が在ることになる。
~JSにおいては、
%要素 が`~HTML要素$であるとするとき，この~propは 次の様に~accessできる：
◎
For example, for the font-size property there would be a font-size IDL attribute. In JavaScript, the property can be accessed as follows, assuming element is an HTML element:
</p>

<pre class="lang-js">
%要素.style['font-size'];
</pre>
</div>

<div class="algo">
<p>
`~IDL属性~名に変換する@
~algoは、
所与の
( %~prop名, 真偽値 %先頭を小文字~化するか（省略時は ~F ） )
に対し：
◎
The CSS property to IDL attribute algorithm for property, optionally with a lowercase first flag set, is as follows:
</p>
<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
	<li>
%次回は大文字~化するか ~LET ~F
◎
Let uppercase next be unset.
</li>
	<li>
~IF［
%先頭を小文字~化するか ~EQ ~T
］
⇒
%~prop名 から最初の文字を除去する
◎
If the lowercase first flag is set, remove the first character from property. </li>
	<li>
<p>
%~prop名 を成す
~EACH( 文字 %c )
に対し，先頭から順に：
◎
For each character c in property:
</p>
		<ol>
			<li>
~IF［
%c ~EQ ❝-
］
⇒＃
%次回は大文字~化するか ~SET ~T；
~CONTINUE
◎
If c is "-" (U+002D), let uppercase next be set.
</li>
			<li>
~IF［
%次回は大文字~化するか ~EQ ~T
］
⇒＃
%次回は大文字~化するか ~SET ~F；
%c ~SET `~ASCII大文字~化する$( %c )
◎
Otherwise, if uppercase next is set, let uppercase next be unset and append c converted to ASCII uppercase to output.
</li>
			<li>
%出力 に %c を付加する
◎
Otherwise, append c to output.
</li>
		</ol>

	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

<div class="algo">
<p>
`~CSS~prop名に変換する@
~algoは、
所与の
( %~IDL属性~名, 真偽値 %~dashを接頭するか（省略時は ~F ） )
に対し：
◎
The IDL attribute to CSS property algorithm for attribute, optionally with a dash prefix flag set, is as follows:
</p>

<ol>
	<li>
%出力 ~LET 空~文字列
◎
Let output be the empty string.
</li>
				<li>
~IF［
%~dashを接頭するか ~EQ ~T
］
⇒
%出力 に ❝- を付加する
◎
If the dash prefix flag is set, append "-" (U+002D) to output.
</li>
	<li>
<p>
%~IDL属性~名 を成す
~EACH( 文字 %c )
に対し，先頭から順に：
◎
For each character c in attribute:
</p>
		<ol>
			<li>
~IF［
%c ~IN { ❝A 〜 ❝Z }
］
⇒
%出力 に次を順に付加する
⇒＃
❝-,
`~ASCII小文字~化する$( %c )
◎
If c is in the range U+0041 to U+005A (ASCII uppercase), append "-" (U+002D) followed by c converted to ASCII lowercase to output.
</li>
			<li>
~ELSE
⇒
%出力 に %c を付加する
◎
Otherwise, append c to output.
</li>
		</ol>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="css-values">
<h3 title="CSS Values">6.7. ~CSS値</h3>

			<section id="parsing-css-values">
<h4 title="Parsing CSS Values">6.7.1. ~CSS値の構文解析-法</h4>

<div class="algo">
<p>
`~CSS値として構文解析する@
~algoは、
所与の
( %値, %~prop名 )
に対し：
◎
To parse a CSS value value for a given property means to follow these steps:
</p>

<ol>
	<li>
%~list ~LET `成分~値~listを構文解析する$( %値 )
◎
Let list be the value returned by invoking parse a list of component values from value.
</li>
	<li>
~IF［
%~list は~CSS仕様の［
名前 %~prop名 の~prop
］の文法に合致する
］
⇒
~RET %~list
◎
Match list against the grammar for the property property in the CSS specification.
</li>
	<li>
~RET ~NULL
◎
If the above step failed, return null.
◎
Return list.
</li>
</ol>

<p class="note">注記：
`!important^l 宣言は、
~propの値~空間の一部を成さないので，
`~CSS値として構文解析する$
の結果は~NULLになる。
◎
Note: "!important" declarations are not part of the property value space and will therefore cause parse a CSS value to return null.
</p>
</div>

			</section>
			<section id="serializing-css-values">
<h4 title="Serializing CSS Values">6.7.2. ~CSS値の直列化-法</h4>

<div class="algo">
<p>
【！ `略式~prop$ %略式~prop に対応する ＊】
`下位prop~listを直列化する@
~algoは、
所与の
( `下位prop$の`~CSS宣言$たちが成す~list %~list )
に対し：
◎
To serialize a CSS value of a CSS declaration declaration or a list of longhand CSS declarations list, follow these rules:
• If this algorithm is invoked with a list list:
</p>
<ol>
	<li>
<p>
~IF［
%~list の中のすべての`下位prop$に正確に対応する`略式~prop$はある
］~AND［
該当する略式~propのうち`選好d順序$で最初のもの %P は、
それらの下位propの値が成す組を正確に表現できる値 %値 をとれる
］
⇒
~RET `~CSS値を直列化する$( 次のようにされた`~CSS宣言$ )
⇒＃
`~prop名$ ~SET %P,
`値$ ~SET %値
</p>

◎
Let shorthand be the first shorthand property, in preferred order, that exactly maps to all of the longhand properties in list.
◎
If there is no such shorthand or shorthand cannot exactly represent the values of all the properties in list, return the empty string.
◎
Otherwise, serialize a CSS value from a hypothetical declaration of the property shorthand with its value representing the combined values of the declarations in list.
</li>
	<li>
~RET 空~文字列
◎
↑</li>
</ol>
</div>

<p class="trans-note">【
上の~algoは，原文では次の~algoと一緒にされて定義されているが、
表記上の都合により，この訳では 2 つに分割している。
】【
上の~algoも次の~algoも、［
`~importantか$,
`文字大小区別か$
］については，何も言及していない
（これらは、関係しないので直列化されることもない？）。
】</p>

<div class="algo">
<p>
`~CSS値を直列化する@
~algoは、
所与の
( `~CSS宣言$ %宣言 )
に対し：
◎
↑</p>

<ol>
	<li>
%P ~LET %宣言 の`~prop名$
◎
↓</li>
	<li>
<p>
%成分~list ~LET ~AND↓ を満たす~CSS成分~値たちが成す`~list$：
◎
Represent the value of the declaration as a list of CSS component values components that,＼
</p>
		<ul>
			<li>
何らかの文字列を %P の`文法に則って構文解析-$した結果に一致する
◎
when parsed according to the property’s grammar, would represent that value.＼
</li>
			<li>
成分~値たちは %宣言 の`値$と同じ意味を表現する
◎
↓</li>
			<li>
<p>
他が指定されない限り， ~AND↓ が満たされる：
</p>
				<ul>
					<li>
成分~値たちは、
可能な限り後方-互換である。
</li>
					<li>
成分~値たちの順序は、
前項までの条件を満たす下で，可能な限り
%P の~prop定義~表tに与えられる正準的~順序に従う。
</li>
					<li>
成分~値たちの個数は、
前項までの条件を満たす下で，最~小である。
</li>
					<li>
各 成分~値は、
前項までの条件を満たす下で，最短な表現である。
</li>
				</ul>
◎
Additionally, unless otherwise specified:
• If certain component values can appear in any order without changing the meaning of the value (a pattern typically represented by a double bar || in the value syntax), reorder the component values to use the canonical order of component values as given in the property definition table.
• If component values can be omitted or replaced with a shorter representation without changing the meaning of the value, omit/replace them.
• If either of the above syntactic translations would be less backwards-compatible, do not perform them.
</li>
		</ul>

<p class="note">注記：
ここに述べた規則は、
直列化の`一般~原則^emを要旨する。
旧来の理由から，一部の~propは異なる方式で直列化するが、
【人的？】資源の欠如に因り，ここには意図的に定義されない。
詳細は、［
当の~propの仕様／ `your local reverse-engineer^en
］に諮られたし。
◎
Note: The rules described here outline the general principles of serialization. For legacy reasons, some properties serialize in a different manner, which is intentionally undefined here due to lack of resources. Please consult that property’s specification and/or your local reverse-engineer for details.
</p>
	</li>
	<li>
%結果 ~LET 空~文字列
◎
↓</li>
	<li>
<p>
%成分~list を成す
~EACH( %成分~値 )
に対し：
</p>
		<ol>
			<li>
~IF［
%成分~値 は `whitespace-token$t である
］
⇒
~CONTINUE
</li>
			<li>
~IF［
%成分~値 ~EQ ❝,
］
⇒＃
%結果 に ❝, を付加する；
~CONTINUE
</li>
			<li>
~IF［
%結果 ~NEQ 空~文字列
］
⇒
%結果 に ~SP を付加する
</li>
			<li>
%結果 に次を付加する
⇒
`~CSS成分~値を直列化する$( %成分~値 )
</li>
		</ol>
◎
Remove any &lt;whitespace-token&gt;s from components.
◎
Replace each component value in components with the result of invoking serialize a CSS component value.
◎
Join the items of components into a single string, inserting " " (U+0020 SPACE) between each pair of items unless the second item is a "," (U+002C COMMA) Return the result.
</li>
	<li>
~RET %結果
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
`~CSS成分~値を直列化する@
~algoは、
所与の
( %値 )
に対し，
その型に応じて：
◎
To serialize a CSS component value depends on the component, as follows:
</p>

<dl class="switch">
	<dt>`~keyword$</dt>
	<dd>
~RET `~ASCII小文字~化する$( %値 )
◎
The keyword converted to ASCII lowercase.
</dd>

	<dt>`angle$t</dt>
	<dd>
~RET 次を順に`連結する$
⇒＃
%値 の `number^t 成分を `number^t として直列化した結果,
%値 の単位を表す 当該の仕様にて定義される正準-形の文字列
◎
The &lt;number&gt; component serialized as per &lt;number&gt; followed by the unit in canonical form as defined in its respective specification.
</dd>
	<dd class="issue">
おそらく、［
宣言d値, 算出d値, 解決d値
］を判別するべきである。
◎
Probably should distinguish between declared and computed / resolved values.
</dd>

	<dt>`color$t</dt>
	<dd>
%値 は`解決d値$の成分である場合
⇒
`CSS-COLOR-4$r `§ ~color_t 値の解決-法＠~CSSCOLOR#resolving-color-values$
を見よ。
◎
If &lt;color&gt; is a component of a resolved value, see CSS Color 4 § 14. Resolving &lt;color&gt; Values.
</dd>
	<dd>
%値 は`算出d値$の成分である場合
⇒
`CSS-COLOR-4$r `§ ~color_t 値の直列化-法＠~CSSCOLOR#serializing-color-values$
を見よ。
◎
If &lt;color&gt; is a component of a computed value, see CSS Color 4 § 15. Serializing &lt;color&gt; Values.
</dd>
	<dd>
<p>
%値 は`宣言d値$の成分である場合：
◎
If &lt;color&gt; is a component of a declared value, then＼
</p>
		<ul>
			<li>
~sRGB値~用には、
`CSS-COLOR-4$r `§ ~sRGB値の解決-法＠~CSSCOLOR#resolving-sRGB-values$
を見よ。
◎
for sRGB values, see CSS Color 4 § 14.1 Resolving sRGB values.＼
</li>
			<li>
他の色~関数~用には、
`CSS-COLOR-4$r `§ ~color_t 値の解決-法＠~CSSCOLOR#resolving-color-values$
を見よ。
◎
For other color functions, see CSS Color 4 § 14. Resolving &lt;color&gt; Values.
</li>
		</ul>
	</dd>

	<dt>`alpha-value$t</dt>
	<dd>
`CSS-COLOR-4$r `§ ~alpha値の直列化-法＠~CSSCOLOR#serializing-alpha-values$
を見よ。
◎
See CSS Color 4 § 15.1 Serializing alpha values.
</dd>

	<dt>`counter$t</dt>
	<dd>
		<ol>
			<li>
%~list ~LET %値 を成す~CSS成分~値たちが成す~list
◎
↓</li>
			<li>
%結果 ~LET %~list 内の~item数に応じて
⇒＃
3 個ならば `counters(^l ／
2 個ならば `counter(^l
◎
The return value of the following algorithm:
◎
Let s be the empty string.
◎
If &lt;counter&gt; has three CSS component values append the string "counters(" to s.
◎
If &lt;counter&gt; has two CSS component values append the string "counter(" to s.
◎
Let list be a list of CSS component values belonging to &lt;counter&gt;,＼
</li>
			<li>
~IF［
%~list 内の最後の~item ~EQ `decimal^l
］
⇒
%~list から最後の~itemを除去する
◎
omitting the last CSS component value if it is "decimal".
</li>
			<li>
%~list ~SET %~list 内の各~itemに
`~CSS成分~値を直列化する$を適用して得られる同順の~list
◎
↓</li>
			<li>
%結果 に次を順に付加する
⇒＃
`~commaで分離して直列化する$( %~list ),
❝)
◎
Let each item in list be the result of invoking serialize a CSS component value on that item.
◎
Append the result of invoking serialize a comma-separated list on list to s.
◎
Append ")" (U+0029) to s.
</li>
			<li>
~RET %結果
◎
Return s.
</li>
		</ol>
	</dd>

	<dt>`frequency$t</dt>
	<dd>
~RET 次を順に`連結する$
⇒＃
%値 の `number^t 成分を `number^t として直列化した結果,
%値 の単位を表す 当該の仕様にて定義される正準-形の文字列
◎
The &lt;number&gt; component serialized as per &lt;number&gt; followed by the unit in its canonical form as defined in its respective specification.
</dd>
	<dd class="issue">
おそらく、［
宣言d値, 算出d値, 解決d値
］を判別するべきである。
◎
Probably should distinguish between declared and computed / resolved values.
</dd>

	<dt>`identifier$t</dt>
	<dd>
~RET 次の結果
⇒
`識別子を直列化する$( %値 )
◎
The identifier serialized as an identifier.
</dd>

	<dt>`integer$t</dt>
	<dd>
		<ol>
			<li>
%結果 ~LET ［
%値 は負であるならば ❝- ／
~ELSE_ 空~文字列
］
</li>
			<li>
%結果 に次を付加する
⇒
%値 を表す ❝0 〜 ❝9 からなる最短-形の基数10整数
</li>
			<li>
~RET %結果
</li>
		</ol>

◎
A base-ten integer using digits 0-9 (U+0030 to U+0039) in the shortest form possible, preceded by "-" (U+002D) if it is negative.
</dd>

	<dt>`length$t</dt>
	<dd>
	<dd>
~RET 次を順に`連結する$
⇒＃
%値 の `number^t 成分を `number^t として直列化した結果,
%値 の単位を表す 当該の仕様にて定義される正準-形の文字列
◎
The &lt;number&gt; component serialized as per &lt;number&gt; followed by the unit in its canonical form as defined in its respective specification.
</dd>
	<dd class="issue">
おそらく、［
宣言d値, 算出d値, 解決d値
］を判別するべきである。
◎
Probably should distinguish between declared and computed / resolved values.
</dd>

	<dt>`number$t</dt>
	<dd>
<p>
~RET %値 を表す ❝0 〜 ❝9 からなる最短-形の基数10数
— 小数部がある場合は ❝. で分離した上で、
【小数部が？】
6 桁を超えるときは値を丸め，負な場合は ❝- を前置する
◎
A base-ten number using digits 0-9 (U+0030 to U+0039) in the shortest form possible, using "." to separate decimals (if any), rounding the value if necessary to not produce more than 6 decimals, preceded by "-" (U+002D) if it is negative.
</p>

<p class="note">注記：
科学的記数法は利用されない。
◎
Note: scientific notation is not used.
</p>
	</dd>

	<dt>`percentage$t</dt>
	<dd>
~RET 次を順に`連結する$
⇒＃
%値 の `number^t 成分を `number^t として直列化した結果,
❝%
◎
The &lt;number&gt; component serialized as per &lt;number&gt; followed by the literal string "%" (U+0025).
</dd>

	<dt>`resolution$t</dt>
	<dd>
~RET 次を順に`連結する$
⇒＃
%値 が表現する， 1 `~CSS~pixel$あたりの~dot数による解像度を `number^t として直列化した結果,
`dppx^l
◎
The resolution in dots per CSS pixel serialized as per &lt;number&gt; followed by the literal string "dppx".
</dd>

	<dt>`ratio$t</dt>
	<dd>
~RET 次を順に`連結する$
⇒＃
分子成分を `number^t として直列化した結果,
` / ^l,
分母成分を `number^t として直列化した結果
◎
The numerator serialized as per &lt;number&gt; followed by the literal string " / ", followed by the denominator serialized as per &lt;number&gt;.
<dd>

	<dt>`rect()$t【！`shape$t】</dt>
	<dd>
~RET 次を順に`連結する$
⇒＃
`rect(^l,
`~commaで分離して直列化する$( %値 を成す各 ~CSS成分~値に`~CSS成分~値を直列化する$を適用して得られる同順の~list ),
❝)
◎
The return value of the following algorithm:
• Let s be the string "rect(".
• Let list be a list of the CSS component values belonging to &lt;shape&gt;.
• Let each item in list be the result of invoking serialize a CSS component value of that item.
• Append the result of invoking serialize a comma-separated list on list to s.
• Append ")" (U+0029) to s.
• Return s.
</dd>

	<dt>`string$t</dt>
	<dt>`family-name$t</dt>
	<dd>
~RET `文字列を直列化する$( %値 )
◎
The string serialized as a string. 
</dd>

	<dt>`time$t</dt>
	<dd>
~RET 次を順に`連結する$
⇒＃
［%値 が表現する秒~単位による数］を `number^t として直列化した結果,
❝s
◎
The time in seconds serialized as per &lt;number&gt; followed by the literal string "s".
</dd>

	<dt>`url$t</dt>
	<dd>
~RET `~CSS~URLに直列化する$( %値 が与える`絶対~URL文字列$ )
◎
The absolute-URL string serialized as URL.
</dd>
	<dd class="issue">
これは、
宣言d値, 算出d値とで違えるベキである。
`3195$issue を見よ
◎
This should differentiate declared and computed &lt;url&gt; values, see #3195.
</dd>
</dl>
</div>

<p>
次に挙げるものは、
この仕様では~macroと見なされる。
これらはすべて，上に示された成分の~instanceを表現する
⇒＃
`absolute-size^t,
`border-width^t,
`border-style^t,
`bottom^t,
`generic-family^t,
`generic-voice^t,
`left^t,
`margin-width^t,
`padding-width^t,
`relative-size^t,
`right^t,
`top^t
◎
&lt;absolute-size&gt;, &lt;border-width&gt;, &lt;border-style&gt;, &lt;bottom&gt;, &lt;generic-family&gt;, &lt;generic-voice&gt;, &lt;left&gt;, &lt;margin-width&gt;, &lt;padding-width&gt;, &lt;relative-size&gt;, &lt;right&gt;, and &lt;top&gt;, are considered macros by this specification. They all represent instances of components outlined above.
</p>

<p class="issue">
この節を除去する案もある
— 上の定義を当の~CSS成分を定義する他の~CSS草案に移動することにより。
◎
One idea is that we can remove this section somewhere in the CSS3/CSS4 timeline by moving the above definitions to the drafts that define the CSS components.
</p>

				<section id="examples-0">
<h5 title="Examples">6.7.2.1. 用例集</h5>

<p>
`宣言d値$に対する処理前後の結果を示す，いくつかの例を以下に挙げる。
“処理前” の列は、作者が~ssに記したものを表す／
“処理後” の列は、~DOMが返すことになる値を表す。
◎
Here are some examples of before and after results on declared values. The before column could be what the author wrote in a style sheet, while the after column shows what querying the DOM would return.
</p>

<div class="example">
<table><thead>
<tr><th>
処理前
◎
Before
<th>
処理後
◎
After

<tbody><tr><td>`background: none^css
<td>`background: rgba(0, 0, 0, 0)^css

<tr><td>`outline: none^css
<td>`outline: invert^css

<tr><td>`border: none^css
<td>`border: medium^css

<tr><td>`list-style: none^css
<td>`list-style: disc^css

<tr><td>`margin: 0 1px 1px 1px^css
<td>`margin: 0px 1px 1px^css

<tr><td>`azimuth: behind left^css
<td>`azimuth: 220deg^css

<tr><td>`font-family: a, 'b"', serif^css
<td>`font-family: "a", "b\"", serif^css

<tr><td>`content: url('h)i') '\[\]'^css
<td>`content: url("h)i") "[]"^css

<tr><td>`azimuth: leftwards^css
<td>`azimuth: leftwards^css

<tr><td>`color: rgb(18, 52, 86)^css
<td>`color: #123456^css

<tr><td>`color: rgba(000001, 0, 0, 1)^css
<td>`color: #000000^css
</table>

<p class="issue">
これらのうち一部は、
新たな規則で更新される必要がある。
◎
Some of these need to be updated per the new rules.
</p>
</div>

				</section>
			</section>
		</section>
	</section>
	<section id="dom-access-to-css-declaration-blocks">
<h2 title="DOM Access to CSS Declaration Blocks">7. ~CSS宣言~blockへの~DOM~access</h2>

		<section id="the-elementcssinlinestyle-mixin">
<h3 title="The ElementCSSInlineStyle Mixin">7.1. `ElementCSSInlineStyle^I ~mixin</h3>

<p>
`ElementCSSInlineStyle$I
~mixinは、
要素の~inline~style~propへの~accessを供する。
◎
The ElementCSSInlineStyle mixin provides access to inline style properties of an element.
</p>

<pre class="idl">
interface mixin `ElementCSSInlineStyle@I {
  [`SameObject$, `PutForwards$=cssText] readonly attribute `CSSStyleDeclaration$I `style$m;
};
</pre>

<div class="algo">
`style@m
取得子~手続きは
⇒
~RET 次のようにされた`~CSS宣言~block$を表現する `CSSStyleDeclaration$I ~obj
⇒＃
`読専か$dB ~SET ~F,
`親~CSS規則$dB ~SET ~NULL,
`所有者~node$dB ~SET コレ
◎
The style attribute must return a CSS declaration block object whose readonly flag is unset, whose parent CSS rule is null, and whose owner node is this.
</div>

<p>
~UAが~HTML `HTML$r を~supportする場合、
次の~IDLが適用される：
◎
If the user agent supports HTML, the following IDL applies: [HTML]
</p>

<pre class="idl">
`HTMLElement$I includes `ElementCSSInlineStyle$I;
</pre>

<p>
~UAが~SVG `SVG11$r を~supportする場合、
次の~IDLが適用される：
◎
If the user agent supports SVG, the following IDL applies: [SVG11]
</p>

<pre class="idl">
`SVGElement$I includes `ElementCSSInlineStyle$I;
</pre>

<p>
~UAが~MathML `MathML-Core$r を~supportする場合、
次の~IDLが適用される：
◎
If the user agent supports MathML, the following IDL applies: [MathML-Core]
</p>

<pre class="idl">
`MathMLElement$I includes `ElementCSSInlineStyle$I;
</pre>

		</section>
		<section id="extensions-to-the-window-interface">
<h3 title="Extensions to the Window Interface">7.2. `Window^I ~interfaceに対する拡張</h3>

<pre class="idl">
partial interface `Window$I {
  [`NewObject$] `CSSStyleDeclaration$I `getComputedStyle$m(`Element$I %elt, optional `CSSOMString$? %pseudoElt);
};
</pre>

<div class="algo">
<p>
`getComputedStyle(elt, pseudoElt)@m
~method手続きは：
◎
The getComputedStyle(elt, pseudoElt) method must run these steps:
</p>
<ol>
	<li>
%文書 ~LET コレの`~node文書$
◎
Let doc be elt’s node document.
</li>
	<li>
%~obj ~LET %elt
◎
Let obj be elt.
</li>
	<li>
<p>
~IF［
%pseudoElt ~NIN { ε, ~NULL, 空~文字列 }
］~AND［
%pseudoElt の最初の文字 ~EQ ❝:
］：
◎
If pseudoElt is provided, is not the empty string, and starts with a colon, then:
</p>
		<ol>
			<li>
%型 ~LET %pseudoElt を `pseudo-element-selector$t の`文法に則って構文解析-$した結果
◎
Parse pseudoElt as a &lt;pseudo-element-selector&gt;, and let type be the result.
</li>
			<li>
~IF［
%型 ~EQ `失敗^i
］~OR［
%型 は［
`slotted()$pe ／ `part()$pe
］疑似要素である
］
⇒
%~obj ~SET ~NULL
◎
If type is failure, or is a ::slotted() or ::part() pseudo-element, let obj be null.
</li>
			<li>
~ELSE
⇒
%~obj ~SET %型 に対応する， %elt 上の疑似要素
◎
Otherwise let obj be the given pseudo-element of elt.
</li>
		</ol>

<p class="note">注記：
CSS2 の疑似要素は、
~colon 1 個だけのものにも合致するべきである。
例えば `::before^l のみならず `:before^l にも。
◎
Note: CSS2 pseudo-elements should match both the double and single-colon versions. That is, both :before and ::before should match above.
</p>
	</li>
	<li>
%宣言~群 ~LET 空~list
◎
Let decls be an empty list of CSS declarations.
</li>
	<li>
<div class="p">

<p>
~IF［
~AND↓
］…
</p>
		<ul>
			<li>
%~obj ~NEQ ~NULL
</li>
			<li>
%elt は`接続されて$いる
</li>
			<li>
%elt は`平坦~tree$の一部を成す
</li>
			<li>
<p>
%elt の`~shadowも含めた根$の`~node文書$が`属する閲覧~文脈$を %B に関して，［
%B ~NEQ ~NULL
］~AND［
~OR↓
］が満たされる：
</p>
				<ul>
					<li>
<p>
%B は閲覧~文脈~容器を持たない
</p>

<p class="trans-note">【
おそらく、
%B は`~top-level閲覧~文脈$であることを意味するであろう
— 単に %B の`容器$bc ~EQ ~NULL のみならず。
】</p>
					</li>
					<li>
［
%B の`容器$bc ~NEQ ~NULL
］~AND［
%B の`容器$bcは`具現化されて$いる
］
</li>
				</ul>
			</li>
		</ul>
<p>
…ならば：
</p>
◎
If obj is not null, and elt is connected, part of the flat tree, and its shadow-including root has a browsing context which either doesn’t have a browsing context container, or whose browsing context container is being rendered,＼
</div>
		<ol>
			<li>
すべての［
`~supportされる~CSS~prop$である`下位prop$
］を成す
~EACH( %~prop名 )
に対し，辞書式~順序で
⇒
%宣言~群 に次のようにされた`~CSS宣言$を付加する
⇒＃
`~prop名$ ~SET %~prop名,
`値$ ~SET %文書 に結付けられた~style規則を利用して %~obj 上の %~prop名 ~propに対し算出される`解決d値$
◎
set decls to a list of all longhand properties that are supported CSS properties, in lexicographical order, with the value being the resolved value computed for obj using the style rules associated with doc.＼
</li>
			<li>
~EACH( `~custom~prop$ %~custom~prop )
に対し【下の課題を見よ】
⇒
~IF［
%~obj 上での %~custom~prop の`算出d値$は、
`無効が保証される値$でない
］
⇒
%~custom~prop を成す宣言を %宣言~群 に付加する
◎
Additionally, append to decls all the custom properties whose computed value for obj is not the guaranteed-invalid value.
</li>
		</ol>

<p class="issue">
略式~propを取扱う~UAもあり、
すべての~UAは，
`overflow$p の様な以前は下位propであった略式を取扱う。
`2529$issue を見よ。
◎
There are UAs that handle shorthands, and all UAs handle shorthands that used to be longhands like overflow, see #2529.
</p>

<p class="issue">
~custom~propの順序は、
まだ定義されていない。
`4947$issue を見よ。
◎
Order of custom properties is currently undefined, see #4947.
</p>
	</li>
	<li>
~RET ［
次のようにされた`~CSS宣言~block$
］を表現する，~liveな `CSSStyleProperties$I ~obj
⇒＃
`算出-済みか$dB ~SET ~T,
`読専か$dB ~SET ~T,
`宣言~群$dB ~SET %宣言~群,
`親~CSS規則$dB ~SET ~NULL,
`所有者~node$dB ~SET %~obj 【これは、疑似要素にもなり得ることになる。】
◎
Return a live CSSStyleProperties object with the following properties:
• computed flag
•• Set.
• readonly flag
•• Set. 
• declarations
•• decls.
• parent CSS rule
•• Null.
• owner node
•• obj.
</li>
</ol>

<p class="warning">
`getComputedStyle()$m
~methodは、
`生成元cleanか$ss ~EQ ~F の下でも，`~CSS~ss$からの情報を公開する。
◎
The getComputedStyle() method exposes information from CSS style sheets with the origin-clean flag unset.
</p>

<p class="issue">
`getComputedStyle()^m は、
有用な直列化を供するべきか？
`1033$issue を見よ。
◎
Should getComputedStyle() provide a useful serialization? See #1033
</p>
</div>

		</section>
	</section>
	<section id="utility-apis">
<h2 title="Utility APIs">8. ~utility~API</h2>

		<section id="the-css.escape()-method">
<h3 title="The CSS.escape() Method">8.1. `CSS.escape()^m ~method</h3>

<p>
`CSS$I ~nsは、
他に属さない有用な~CSSに関係する機能を保持する。
◎
The CSS namespace holds useful CSS-related functions that do not belong elsewhere.
</p>

<pre class="idl">
[`Exposed$=Window]
namespace `CSS@I {
  `CSSOMString$ `escape$m(`CSSOMString$ %ident);
};
</pre>

<p class="issue">
これは、
以前は，静的~methodのみを保持する~IDL~interfaceとして指定されていた。
~IDL~nsに切り替えても，ほとんど同じになるので、
互換性の懸念はないものと期待されている。
何か発見されたときは、
この変更の復帰を考慮できるよう報告されたし。
◎
This was previously specified as an IDL interface that only held static methods. Switching to an IDL namespace is *nearly* identical, so it’s expected that there won’t be any compat concerns. If any are discovered, please report so we can consider reverting this change.
</p>

<div class="algo">
<p>
`escape(ident)@m
~method手続きは
⇒
~RET `識別子を直列化する$( %ident )
◎
The escape(ident) operation must return the result of invoking serialize an identifier of ident.
</p>

<div class="example">
<p>
`escape()$m ~methodを利用して直列化すれば、
~~未知な文字列でも，選択子の一部として利用できるようになる：
◎
For example, to serialize a string for use as part of a selector, the escape() method can be used:
</p>

<pre class="lang-js">
var %element = document.querySelector(
  '#' + CSS.escape(%id) + ' &gt; img'
);
</pre>

<p>
厳密には、
~escape不要な文字まで~escapeするが：
◎
The escape() method can also be used for escaping strings, although it escapes characters that don’t strictly need to be escaped:
</p>

<pre class="lang-js">
var %element = document.querySelector(
  'a[href="#' + CSS.escape(%fragment) + '"]'
);
</pre>
</div>
</div>

<p>
`CSS$I ~ns上に演算を定義する仕様は、
格納したい状態があるならば，`現在の大域~obj$に`結付けられた文書$に格納するべきである。
◎
Specifications that define operations on the CSS namespace and want to store some state should store the state on the current global object’s associated Document.
</p>

		</section>
	</section>
	<section id="resolved-values">
<h2 title="Resolved Values">9. 解決d値</h2>

<p>
`Window$I の `getComputedStyle()$m は、
歴史的に，要素や`疑似要素$の “`算出d値$” を返すように定義されていた。
しかしながら、
配備-済みな~scriptとの互換性を得るため， `getComputedStyle()$m の実装は変えるわけにいかない一方で、
“`算出d値$” の概念は，~CSSの改訂に伴って変化してきている。
この課題に取組むため、
この仕様は，`解決d値$の概念を導入する。
◎
getComputedStyle() was historically defined to return the "computed value" of an element or pseudo-element. However, the concept of "computed value" changed between revisions of CSS while the implementation of getComputedStyle() had to remain the same for compatibility with deployed scripts. To address this issue this specification introduces the concept of a resolved value.
</p>

<p>
所与の下位prop用の
`解決d値@
は，~propに応じて次で与えられる：
◎
The resolved value for a given longhand property can be determined as follows:
</p>

<dl class="switch">
	<dt>`background-color$p
	<dt>`border-block-end-color$p
	<dt>`border-block-start-color$p
	<dt>`border-bottom-color$p
	<dt>`border-inline-end-color$p
	<dt>`border-inline-start-color$p
	<dt>`border-left-color$p
	<dt>`border-right-color$p
	<dt>`border-top-color$p
	<dt>`box-shadow$p
	<dt>`caret-color$p
	<dt>`color$p
	<dt>`outline-color$p
	<dt id="resolved-value-special-case-property-like-color">
他の仕様にて［
解決d値は `color^p の様に特別
］と定義される~prop
◎
A resolved value special case property like color defined in another specification 
</dt>
	<dd>
`使用~値$
◎
The resolved value is the used value.
</dd>

	<dt>`line-height$p
	<dd>
`算出d値$は `normal^v ならば `normal^v ／
~ELSE_ `使用~値$
◎
The resolved value is normal if the computed value is normal, or the used value otherwise.
</dd>

	<dt>`block-size$p</dt>
	<dt>`height$p</dt>
	<dt>`inline-size$p</dt>
	<dt>`margin-block-end$p</dt>
	<dt>`margin-block-start$p</dt>
	<dt>`margin-bottom$p</dt>
	<dt>`margin-inline-end$p</dt>
	<dt>`margin-inline-start$p</dt>
	<dt>`margin-left$p</dt>
	<dt>`margin-right$p</dt>
	<dt>`margin-top$p</dt>
	<dt>`padding-block-end$p</dt>
	<dt>`padding-block-start$p</dt>
	<dt>`padding-bottom$p</dt>
	<dt>`padding-inline-end$p</dt>
	<dt>`padding-inline-start$p</dt>
	<dt>`padding-left$p</dt>
	<dt>`padding-right$p</dt>
	<dt>`padding-top$p</dt>
	<dt>`width$p</dt>
	<dt id="resolved-value-special-case-property-like-height">
他の仕様にて［
解決d値は `height^p の様に特別
］と定義される~prop
◎
A resolved value special case property like height defined in another specification
</dt>
	<dd>
<p>
~AND↓ が満たされるならば `使用~値$ ／
~ELSE_ `算出d値$：
</p>
		<ul>
			<li>
~propは 要素または`疑似要素$に適用されている
</li>
			<li>
当の要素~上の `display$p ~propの`解決d値$ ~NIN { `none^v, `contents^v }
</li>
		</ul>
◎
If the property applies to the element or pseudo-element and the resolved value of the display property is not none or contents, then the resolved value is the used value. Otherwise the resolved value is the computed value.
</dd>

	<dt>`bottom$p</dt>
	<dt>`left$p</dt>
	<dt>`inset-block-end$p</dt>
	<dt>`inset-block-start$p</dt>
	<dt>`inset-inline-end$p</dt>
	<dt>`inset-inline-start$p</dt>
	<dt>`right$p</dt>
	<dt>`top$p</dt>
	<dt id="resolved-value-special-case-property-like-top">
他の仕様にて［
解決d値は `top^p の様に特別
］と定義される~prop
◎
A resolved value special case property like top defined in another specification 
</dt>
	<dd>
<p>
~AND↓ が満たされるならば `使用~値$ ／
~ELSE_ `算出d値$：
</p>
		<ul>
			<li>
~propは `有位置$な要素に適用されている
</li>
			<li>
当の要素~上の `display$p ~propの`解決d値$ ~NIN { `none^v, `contents^v }
</li>
			<li>
~propにより拘束され過ぎにならない
</li>
		</ul>
◎
If the property applies to a positioned element and the resolved value of the display property is not none or contents, and the property is not over-constrained, then the resolved value is the used value. Otherwise the resolved value is the computed value.
</dd>

	<dt>
他の仕様にて
`解決d値は特別@
と定義される~prop
◎
A resolved value special case property defined in another specification
</dt>
	<dd>
関連な仕様により定義される。
◎
As defined in the relevant specification.
</dd>
	<dt>その他の~prop</dt>
	<dd>
`算出d値$
◎
The resolved value is the computed value.
</dd>
</dl>

	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">10. IANA 考慮点</h2>

		<section id="default-style">
<h3 title="Default-Style">10.1. `Default-Style^h ~header~field</h3>

<div>
<p>
この節では、
`Permanent Message Header Field Registry^cite
に登録するための~header~fieldについて述べる。
</p>

<table><tbody>
<tr><th>~header~field名
<td>`Default-Style@h
<tr><th>適用-可能な~protocol
<td>http
<tr><th>位置付け
<td>標準
<tr><th>著作者
<td>~W3C
<tr><th>変更~制御者
<td>~W3C
<tr><th>仕様~文書
<td>この文書
<tr><th>関係する情報
<td>なし
</table>

◎
This section describes a header field for registration in the Permanent Message Header Field Registry.
◎
• Header field name
•• Default-Style
• Applicable protocol
•• http
• Status
•• standard
• Author/Change controller
•• W3C
• Specification document(s)
•• This document is the relevant specification.
• Related information
•• None.
</div>

		</section>
	</section>
	<section id="change-history">
<h2 title="Change History">変更~履歴</h2>

<p>
この節では、
この仕様の各~公表版の間の変更点の一部を文書化する。
この節は、
網羅的ではない。
~bug修正点および編集上の変更点は、
一般に，挙げられない。
◎
This section documents some of the changes between publications of this specification. This section is not exhaustive. Bug fixes and editorial changes are generally not listed.
</p>

<dl>
	<dt id="changes-from-17-march-2016">
2016年 3月 17日からの変更点
◎
11.1. Changes From 17 March 2016
</dt>
	<dd>
`resolution$t の直列化を変更した。
◎
Serialization of &lt;resolution&gt; is changed.
</dd>
	<dd>
<code class="xattr">[`CEReactions$]</code> ~IDL拡張d属性を追加した。
◎
[CEReactions] IDL extended attributes are added.
</dd>
	<dd>
論理-~prop用の`解決d値$を追加した。
◎
Resolved value for logical properties are added.
</dd>
	<dd>
<code class="css">`display$p: `contents^v</code>
【が指定された要素】用の`解決d値$【！getComputedStyle】を変更した。
◎
getComputedStyle for display: contents is changed.
</dd>
	<dd>
`MediaList$I の `item$m1 は、
直列化を返すようにした。
◎
MediaList.item now returns serialization.
</dd>
	<dd>
`MediaList$I の `item$m1 は、
重要度【`~importantか$】が相違する場合には，
略式~propを直列化しないようにした。
【？】
◎
MediaList.item does not serialize shorthand if importance differs.
</dd>
	<dd>
他の仕様が`解決d値$を指定することも許容した。
◎
Other specifications are allowed to specify resolved value.
</dd>
	<dd>
`insertRule()^m の %index 引数 を省略可能にした。
◎
index argument in insertRule is now optional.
</dd>
	<dd>
［
`StyleSheet$I の `href$m1 属性／
`CSSImportRule$I の `href$m1 属性
］には、
`USVString$I を利用するようにした。
◎
href attribute of Stylesheet and CSSImportRule now uses USVString.
</dd>
	<dd>
`CSSOMString$I を導入した。
◎
CSSOMString is introduced.
</dd>
	<dd>
［
`CSSMediaRule$I ／ `CSSFontFaceRule$I
］の直列化を追加した。
◎
Serialization of CSSMediaRule and CSSFontFaceRule is added.
</dd>
	<dd>
`style^a 属性に対し値を直列化して構文解析し直すのを避けるため、
`~CSS宣言~block$に`更新-中か$dBを追加した。
◎
Updating flag is added to CSS declaration block to avoid serialize-and-reparse on style attribute.
</dd>
	<dd>
宣言~値の直列化を適正に定義した。
◎
Serialization of a declaration value is now properly defined.
</dd>
	<dd>
`getComputedStyle()$m は、
~nodeが属する文書の~style規則を返すようにした。
◎
getComputedStyle now returns the style rules of the node’s document.
</dd>
	<dd>
`getComputedStyle()$m に渡された疑似要素が［
未知 ／ `slotted()$pe
］の場合には、
`TypeError$E を投出するようにした。
◎
A TypeError is thrown when the pseudo-element passed to getComputedStyle is unknown or ::slotted().
</dd>
	<dd>
`CSS$I を~interfaceから名前空間に切替えた。
◎
CSS is switched from interface to namespace.
</dd>
	<dd>
実装からの関心の欠如に因り、
`CSSStyleDeclaration$I から［
`setPropertyValue()^m, `setPropertyPriority()^m
］を除去した。
◎
setPropertyValue and setPropertyPriority are removed from CSSStyleDeclaration due to lack of interest from implementations.
</dd>
	<dd>
`styleSheets$m ~IDL属性を `Document$I から `DocumentOrShadowRoot$I へ移動した。
◎
The styleSheets IDL attribute is moved from Document to DocumentOrShadowRoot.
</dd>
	<dd>
`LinkStyle$I の `sheet$m1 属性は、
`StyleSheet$I に代えて， `CSSStyleSheet$I を返すようにした。
◎
LinkStyle.sheet now returns CSSStyleSheet instead of StyleSheet
</dd>
	<dd>
`CSSStyleSheet$I の非推奨にされた~memberを定義した。
◎
Deprecated CSSStyleSheet members are defined.
</dd>
	<dd>
`CSSRule$I の `type$m1 属性を非推奨にした。
◎
The CSSRule.type attribute is deprecated.
</dd>
	<dd>
`ratio$t の直列化を追加した。
◎
Serialization of &lt;ratio&gt; is added.
</dd>
	<dd>
`CSSStyleDeclaration$I `cssText$m1 は、
算出-済みな~style用には空~文字列を返すようにした。
◎
CSSStyleDeclaration.cssText now returns the empty string for computed style.
</dd>
	<dd>
`getComputedStyle()$m に`~custom~prop$を含めた。
◎
Custom properties are included in getComputedStyle.
</dd>
	<dd>
~MathML~IDLを導入した。
◎
MathML IDL is introduced.
</dd>
	<dd>
［
`CSSKeyframesRule$I, `CSSKeyframeRule$I
］の直列化を追加した。
◎
Serialization of CSSKeyframesRule and CSSKeyframeRule is added.
</dd>
	<dd>
`媒体~query$の直列化を変更した。
◎
Serialization of media query is changed.
</dd>
	<dd>
同じ`論理-~prop~group$に属するが，`対応付け~logic$は異なる下位propが混ざっている場合には、
略式~propに直列化しないようにした。
◎
A shorthand is not serialized if there are longhands with other property group / mapping logic in between the longhands of that shorthand.
</dd>
	<dd>
`CSSStyleRule$I の直列化は、
入子ngを自覚-【して字下げ】する。
◎
CSSStyleRule serialization is aware of nesting now.
</dd>
	<dd>
構築-可能な~stylesheetを導入した。
◎
Constructable stylesheets is introduced.
</dd>

	<dt id="changes-from-5-december-2013">
2013年 12月 5日 以降の変更点
◎
11.2. Changes From 5 December 2013
</dt>
	<dd>
代替~ss用の~API
— 次に挙げる `Document$I の~member —
を除去した
⇒＃
`selectedStyleSheetSet^m,
`lastStyleSheetSet^m,
`preferredStyleSheetSet^m,
`styleSheetSets^m,
`enableStyleSheetsForSet()^m
◎
API for alternative stylesheets is removed: selectedStyleSheetSet, lastStyleSheetSet, preferredStyleSheetSet, styleSheetSets, enableStyleSheetsForSet() on Document.
</dd>
	<dd>
［
`Element$I ／ `PseudoElement^I
］~interfaceの `pseudo()^m ~methodは除去した。
【現在は `CSS Pseudo-Elements Module^cite に移動され、 `PseudoElement^I も `CSSPseudoElement$I に改称されている。】
◎
The pseudo() method on Element and the PseudoElement interface is removed.
</dd>
	<dd>
`Element$I の次の属性は除去した
⇒＃
`cascadedStyle^m,
`defaultStyle^m,
`rawComputedStyle^m,
`usedStyle^m
◎
The cascadedStyle, defaultStyle, rawComputedStyle and usedStyle IDL attributes on Element are removed.
</dd>
	<dd>
`CSSRule$I の `cssText$m1 設定子~手続きは、
何もしないように変更した。
◎
The cssText IDL attribute’s setter on CSSRule is changed to do nothing.
</dd>
	<dd>
`CSSStyleDeclaration$I 上に `~webkit_cased_attr$m
— `webkitFoo^m の形の属性（小文字の `w^c ） —
を追加した。
◎
IDL attributes of the form webkitFoo (with lowercase w) on CSSStyleDeclaration are added.
</dd>
	<dd>
`CSSNamespaceRule$I は、
読専に変更した。
◎
CSSNamespaceRule is changed back to readonly.
</dd>
	<dd>
`CSSStyleSheet$I の `insertRule()$m1 における
`charset^at の取扱いは、
除去した。
◎
Handling of @charset in insertRule() is removed.
</dd>
	<dd>
`CSSCharsetRule^I を再び除去した。
◎
CSSCharsetRule is removed again.
</dd>
	<dd>
識別子／文字列の直列化を変更した。
◎
Serialization of identifiers and strings is changed.
</dd>
	<dd>
選択子の直列化は、
今や［
結合子 `&gt;&gt;^l, `||^l
］, および［
属性~選択子における `i^l ~flag
］も~supportする。
◎
Serialization of selectors now supports combinators "&gt;&gt;" and "||" and the "i" flag in attribute selectors.
</dd>
	<dd>
`lang()$ps の直列化を変更した。
◎
Serialization of :lang() is changed.
</dd>
	<dd>
`color$t, `number$t
の直列化を変更した。
◎
Serialization of &lt;color&gt; and &lt;number&gt; is changed.
</dd>
	<dd>
`CSSStyleDeclaration$I の `setProperty()$m1 を変更した。
◎
setProperty() on CSSStyleDeclaration is changed.
</dd>

	<dt id="changes-from-12-july-2011-to-5-december-2013">
2011年 7月 12日 から 2013年 12月 5日 までの変更点
◎
11.3. Changes From 12 July 2011 To 5 December 2013
</dt>
	<dd>
非同一-生成元~ssの読み取りや変更は許容されない。
◎
Cross-origin stylesheets are not allowed to be read or changed.
</dd>
	<dd>
`CSSCharsetRule^I ~interfaceを再び導入した。
◎
CSSCharsetRule is re-introduced.
</dd>
	<dd>
`CSSGroupingRule$I, `CSSMarginRule$I
を導入した。
◎
CSSGroupingRule and CSSMarginRule are introduced.
</dd>
	<dd>
`CSSNamespaceRule$I は今や変異-可能である。
◎
CSSNamespaceRule is now mutable.
</dd>
	<dd>
~CSS宣言~block用に［
`~CSS宣言~blockとして構文解析する$,
`宣言~群を直列化する$
］を定義した。
◎
Parse and serialize a CSS declaration block is now defined.
</dd>
	<dd>
`CSSStyleDeclaration$I の［
`setProperty()$m1,
`getPropertyValue()$m1,
等々
］は、
略式~propを~supportするようにした。
◎
Shorthands are now supported in setProperty(), getPropertyValue(), et al.
</dd>
	<dd>
`CSSStyleDeclaration^I に［
`setPropertyValue()^m,
`setPropertyPriority()^m
］を追加した。
◎
setPropertyValue and setPropertyPriority are added to CSSStyleDeclaration.
</dd>
	<dd>
各種~interfaceにおける［
`style^m, `media^m
］属性を，
~Web~IDL拡張d属性 [`PutForwards$] 注釈付きにした。
◎
The style and media attributes of various interfaces are annotated with the [PutForwards] WebIDL extended attribute.
</dd>
	<dd>
`Element^I 上に `pseudo()^m ~methodを導入した†。
◎
The pseudo() method on Element is introduced.
</dd>
	<dd>
`PseudoElement^I ~interfaceを導入した†。
◎
The PseudoElement interface is introduced.
</dd>
	<dd>
［
`Element$I, `PseudoElement^I
］に［
`cascadedStyle^m,
`rawComputedStyle^m,
`usedStyle^m
］属性を導入した†。
【†が、再び除去された（上の 2013年 12月 5日 以降の変更点を見よ）。】
◎
The cascadedStyle, rawComputedStyle and usedStyle attributes on Element and PseudoElement are introduced.
</dd>
	<dd>
静的~method `CSS.escape()$m を導入した。
◎
The CSS.escape() static method is introduced. 
</dd>
</dl>

	</section>
	<section id="sec">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
この仕様に対し報告された新たな~securityの考慮点は、
無い。
◎
No new security considerations have been reported on this specification.
</p>

	</section>
	<section id="priv">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
この仕様に対し報告された新たな~privacyの考慮点は、
無い。
◎
No new privacy considerations have been reported on this specification.
</p>

	</section>
	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様に貢献された次に挙げる方々に感謝する：
</p>

<p lang="en">
The editors would like to thank

Alexey Feldgendler,
Benjamin Poulain,
Björn Höhrmann,
Boris Zbasky,
Brian Kardell,
Chris Dumez,
Christian Krebs,
Daniel Glazman,
David Baron,
Domenic Denicola,
Dominique Hazael-Massieux,
<i>fantasai</i>,
Hallvord R. M. Steen,
Ian Hickson,
John Daggett,
Lachlan Hunt,
Mike Sherov,
Myles C. Maxfield,
Morten Stenshorne,
Ms2ger,
Nazım Can Altınova,
Øyvind Stenhaug,
Peter Sloetjes,
Philip Jägenstedt,
Philip Taylor,
Richard Gibson,
Robert O’Callahan,
Simon Sapin,
Sjoerd Visscher,
Sylvain Galineau,
Tarquin Wilton-Jones,
Xidorn Quan, and
Zack Weinberg

for contributing to this specification.
</p>

<p>
加えて、［
代替~ss~API, ~CSS値の正準-化（現在は “直列化”）規則
］の初期~versionを書かれた `Ian Hickson^en 氏にも。
◎
Additional thanks to Ian Hickson for writing the initial version of the alternative style sheets API and canonicalization (now serialization) rules for CSS values.
</p>

	</section>
</main></div>
