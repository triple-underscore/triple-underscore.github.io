<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Scoping Module Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'ps':
	text = `:${key}`;
	break;
case 'pe':
	text = `::${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'f':
	text = `${key}()`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Scoping Module Level 1
spec_date:2021-05-13
trans_update:2021-05-16
source_checked:201111
page_state_key:CSS
original_url:https://drafts.csswg.org/css-scoping-1/
	abbr_url:CSSSCOPING
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:selector,css
conformance:css
copyright:2021,permissive
trans_1st_pub:2017-09-01


●●class_map
p:property
d:descriptor
ps:pseudo
pe:pseudo
css:css
e:element
a:attr
v:value
at:at-rule
f:func
t:type
sl:js-slot

●●tag_map
I:code
m:code
p:code
d:code
ps:code
pe:code
at:code
t:var
css:code
e:code
a:code
v:code
f:code
c:code
sl:span

●●original_id_map

●●mdn_urls
selectordef-slotted:CSS/::slotted
selectordef-host:CSS/:host
selectordef-host-function:CSS/:host()
selectordef-host-context:CSS/:host-context()

●●words_table1

●●words_table


	●内容／構造／slot／scope／node tree／shadow
	Scope
	Shadow
light:
shadow:
	~shadowを貫く:shadow-piercing
	~light~tree:light-tree
slot:
	slottable
	slot-assigned
	slot-assignment
	at all slot-assignment levels
貫く:pierceする::~
	~treeに留まる:tree-abiding
入子:nest::入れ子
encapsulation::::カプセル化
埋める:fillする:~
	包装している〜要素:wrapper elements
平坦:flat::~
	平坦~化:flatten
	平坦~化-法:flattening
深い:deepな:~
参照r:refer:参照
捕捉-:capture::~
住まう:liveする:~
参照解決-:dereference::~

	到達-不能:unreachable
	containing
	より深い:deeper
	-:pre-order
	どうしの順序:relative ordering
	最も外縁:outermost
	内部~slot:private slot
	遮断-:disrupt
	引き込む:pulled into
	居る:live

	●選択子／視野
詳細度:specificity::~
選択-:select::~
	選択できない:unselectable
複体:complex::~
合体:compound::~
無特能:featureless::~
	無特能:so weird
出自:origin::~
出自の:originating::~
対象に:target:~
勝つ:winする:優先される
視野な:scopedな::~
	~tree視野な:tree-scoped
	視野~付け:scoping
	視野~付き:scoped

	●CSS
	cascade法:cascading
flexbox:
	styling
	stylesheet:sheet
	［疑似要素／疑似類］:pseudo

	●演算／処理
優先-:prioritize:~
処理待ち:pending:~
渡され:passされ:~


	●仕様
明白:obvious:~
適理な:reasonableな:理に適う
アタる:consultする:あたる
複雑化-:complicate:~
驚かす:surpriseさせる:~
惑わす:confuseさせる:~
尊重-:respect:~
続行-:proceed:~
不用意:accidental:~
介入-:intervene:~
緩めら:loosenさ:~
書直す:rewriteする:書き直す
素朴:naive:~
汚す:polluteする:~
仮想の:imaginaryな:~
見出そ:findしよ:~

	できるよう:possible
	-不可能:impossible for 〜
	Standard
	we
	先ず挙げられる:primary
	別の言い方をすれば:alternately
	良くないことが起こる:very good
	~~素の:vanilla
	難しい:hard
	不都合:complaint
	capable
	complex
	idea
	informative
	概ね:loosely
	幸いなことに:luckily
	note
	他の点では:otherwise
	独力で:affirmatively 〜 all by itself
	なら〜必要がある:we can’t say〜

	予測-不能:unpredictable
	-:provide
	単一化:single unified
	聞く:hear
	基づく:rebase
	必要がある:want
	~~先送り:punt
	~~編成し直す:reorg
	~~問題にはならない:matter
	任意選択で選ぶ:opt into
	力点を置いて:focusing
	-:remember
	〜ないように:prevent
	しようと:-try
	戸惑う／confusing
	にも関わらず:despite
	伝える:tell
	最中にある:under active
	必要がある:TODO
	見合うよう:against
	利用されても妥当に:be validly used
	その一方:meanwhile
	いきなり:suddenly
	~~説明-:illustrate
	と同じく:just as in
	該当する:relevant

	●未分類
提示-:present:~
後続-:follow:~
足した:plusした:~
部品:component:~
	`my-component^e:component
関数形の:functional:~
	-:functional form
変種:variant:~
種類:kind:~
theme::::テーマ
色:color:~
切替わる:switchする:切り替わる
具象化-:reify::~
	具象化:reification
運ぶ:carryする:~

	伴い続ける:stay
	観測され得:observable
	現れる:appear
	-:attach
	called
	coming
	-:gain
	-:get
	名前:keyed with
	originating
	-:pop
	-:put
	made
	できない:capable
	低い:low
	~~特性:qualities
	Selector
	対象にできない:untargettable
	失われ:lost
	何もしない:no-op
	得る:taking
	新規:fresh
	を利用する:in 〜

	●指示語
普通は:ordinaryには:~
普通の:ordinaryな:~

	他の部分:the rest
	部分:part
	うち一部:some of
	どこか:somewhere
	一部:part of
	先に来る:earlier
	後に来る:coming later
	~slotに:downwards
	-:sort of
	ちょうど同じく:just as
	同類:akin
	種々の:various
	逆:opposite
	遡る:on the way up
	遡る:starts walking up
	さらに遡って:further up
	across
	against
	top
	一握りhandful
	higher
	later
	sole
	somewhat
	somewhere
	whichever
	より上位にある:lies〜 above
	より上位:higher up
	もっぱら:sole
	他:nobody else
	どうやっても:any way
	とともに:along with
	より新たな:newer
	一連の:set-of
	複数回:multiple times
	2 つの〜間:across


●●link_map


I.Window:~WINDOW#window
m.querySelector():~DOM4#dom-parentnode-queryselector
sl.defaultElementStylesMap:#dom-window-defaultelementstylesmap-slot

at.font-face:~CSSFONT4#at-font-face-rule
at.keyframes:~CSSANIM#at-ruledef-keyframes
at.font-feature-values:~CSSFONT4#at-ruledef-font-feature-values
at.counter-style:~CSSCOUNTER#at-ruledef-counter-style
at.color-profile:~CSSCOLOR5#at-ruledef-profile
at.font-palette-values:~CSSFONT4#at-ruledef-font-palette-values

d.font-family:~CSSFONT4#descdef-font-face-font-family

ps.host:#selectordef-host
ps.host():#selectordef-host-function
ps.host-context():#selectordef-host-context

pe.slotted():#selectordef-slotted
pe.first-line:~CSSPSEUDO#selectordef-first-line
ps.is():~SELECTORS4#matches-pseudo
ps.not():~SELECTORS4#negation-pseudo

p.display:~CSSDISP#propdef-display
p.font-family:~CSSFONT#propdef-font-family
p.animation-name:~CSSANIM#propdef-animation-name
p.list-style-type:~CSSLIST#propdef-list-style-type
p.font-palette:~CSSFONT4#propdef-font-palette

t.compound-selector:~SELECTORS4#typedef-compound-selector
t.stylesheet:~CSSSYN#typedef-stylesheet

f.color:~CSSCOLOR#funcdef-color

v.contents:~CSSDISP#valdef-display-contents

e.slot:~HEscripting#the-slot-element
e.style:~HEmetadata#the-style-element

	●用語
平坦~化された要素~tree:#flat-tree
平坦~tree:#flat-tree
断片~疑似要素:#fragment-pseudo-element
~shadow~treeの文脈~下:#in-the-context-of-a-shadow-tree
~tree文脈:#tree-context
~tree視野な名前:#css-tree-scoped-name
~tree視野な参照:#css-tree-scoped-reference

	●用語（外部
~at-rule:~CSSSYN#at-rule

~cascade:~CASCADE#cascade
~UA出自:~CASCADE#cascade-origin-ua
~cascade文脈:~CASCADE#cascade-context

~CSS~style属性:~CSSSTYLEATTR#style-attribute0

複体~選択子:~SELECTORS4#complex
合体~選択子:~SELECTORS4#compound
の~list:~SELECTORS4#list-of-simple-selectors
子孫:~DOM4#concept-tree-descendant
子孫~結合子:~SELECTORS4#descendant-combinator
無特能:~SELECTORS4#featureless
要素に対し選択子を照合-:~SELECTORS4#match-a-selector-against-an-element
~treeに対し選択子を照合-:~SELECTORS4#match-a-selector-against-a-tree
型~選択子:~SELECTORS4#type-selector
詳細度:~SELECTORS4#specificity
出自の要素:~SELECTORS4#originating-element
	選択対象:~SELECTORS4#selector-subject

~node~tree:~DOM4#concept-node-tree
子:~DOM4#concept-tree-child
	子たち:~DOM4#concept-tree-child
~custom要素:~DOM4#concept-element-custom
	アテガわれ
平坦~化され:~DOM4#find-flattened-slotables
~slot用に平坦~化された~slot可能なものを見出す:~DOM4#find-flattened-slotables
~slot用に~slot可能なものを見出す:~DOM4#find-slotables
~host:~DOM4#concept-documentfragment-host
~light~tree:~DOM4#concept-light-tree
局所~名:~DOM4#concept-element-local-name
根:~DOM4#concept-tree-root
文書片:~DOM4#interface-documentfragment
要素:~DOM4#concept-element

~shadowも含む先祖:~DOM4#concept-shadow-including-ancestor
~shadow~host:~DOM4#element-shadow-host
~shadow根:~DOM4#concept-shadow-root
~shadow~tree:~DOM4#concept-shadow-tree
~slot:~DOM4#concept-slot
~slot可能:~DOM4#concept-slotable

具象化-:~CSSTOM1#css-reify

●●ref_normative

[CSS-ANIMATIONS-1]
    Dean Jackson; et al. CSS Animations Level 1. 11 October 2018. WD. URL: https://www.w3.org/TR/css-animations-1/ 
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. CSS Cascading and Inheritance Level 5. 19 March 2021. WD. URL: https://www.w3.org/TR/css-cascade-5/ 
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4. 12 November 2020. WD. URL: https://www.w3.org/TR/css-color-4/ 
[CSS-COUNTER-STYLES-3]
    Tab Atkins Jr.. CSS Counter Styles Level 3. 14 December 2017. CR. URL: https://www.w3.org/TR/css-counter-styles-3/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 18 December 2020. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-FONTS-3]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 3. 20 September 2018. REC. URL: https://www.w3.org/TR/css-fonts-3/ 
[CSS-FONTS-4]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 4. 17 November 2020. WD. URL: https://www.w3.org/TR/css-fonts-4/ 
[CSS-FONTS-5]
    CSS Fonts Module Level 5 URL: https://www.w3.org/TR/css-fonts-5/ 
[CSS-LISTS-3]
    Elika Etemad; Tab Atkins Jr.. CSS Lists and Counters Module Level 3. 17 November 2020. WD. URL: https://www.w3.org/TR/css-lists-3/ 
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. CSS Pseudo-Elements Module Level 4. 31 December 2020. WD. URL: https://www.w3.org/TR/css-pseudo-4/ 
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 16 July 2019. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 21 November 2018. WD. URL: https://www.w3.org/TR/selectors-4/ 

●●ref_informative

[CSS-TYPED-OM-1]
    Shane Stephens; Tab Atkins Jr.; Naina Raisinghani. CSS Typed OM Level 1. 10 April 2018. WD. URL: https://www.w3.org/TR/css-typed-om-1/ 
[SELECTORS-3]
    Tantek Çelik; et al. Selectors Level 3. 6 November 2018. REC. URL: https://www.w3.org/TR/selectors-3/ 

●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Scoping Module Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-scoping-1/
公表履歴
	https://www.w3.org/standards/history/css-scoping-1
編集者草案
	https://drafts.csswg.org/css-scoping-1/

テスト一式
	http://test.csswg.org/suites/css-scoping-1_dev/nightly-unstable/
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-scoping-1">CSSWG Issues Repository</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-scoping-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-scoping-1

</script>

</head>

<body>

<header>
	<hgroup>
<h1 id="title">CSS Scoping Module Level 1</h1>
	</hgroup>

</header>


<div id="MAIN" hidden>
	<section id="abstract">
~ABSTRACT

<p>
この仕様は、~CSSによる［
視野~付け／~encapsulation
］の仕組みを，特に ~shadow~DOMの視野~付け（ `scoping^en ）に力点を置いて定義する。
◎
This specification defines scoping/encapsulation mechanisms for CSS, focusing on the Shadow DOM scoping mechanism.
</p>

~CSSisaLANG


	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

【未策定】

	</section>
	<section id="default-element-styles">
<h2 title="Default Styles for Custom Elements">2. ~custom要素に対する既定の~style</h2>

<p class="advisement"><strong>
この節は、<strong>試験的</strong>であり，論の最中にある。
実装する前に，~CSS~WGにアタること。
</strong>
◎
This section is experimental, and is under active discussion. Do not implement without consulting the CSSWG.
</p>

<p>
`~custom要素$の定義-時には、それに対する
— 組込みの要素に適用される~UA~styleと同類の —
“既定の” ~styleを設定しておくよう求まれることが多い。
あいにく，これを~~素の~CSSで行うのは、次の 2 点から難しい：
◎
When defining custom elements, one often wants to set up "default" styles for them, akin to the user-agent styles that apply to built-in elements. This is, unfortunately, hard to do in vanilla CSS, due to issues of scoping and specificity—＼
</p>

<ul>
	<li>
視野~付けの課題：
当の要素は，`~shadow~tree$内で利用されるかもしれない
— その場合、最も外縁の文書~内にある，要素を対象にしている選択子からは到達-不能になる。
◎
the element in question might be used in shadow trees, and thus is unreachable by any selector targeting it in the outermost document;＼
</li>
	<li>
詳細度の課題：
`型~選択子$の様な詳細度が低い選択子でも、当の要素を対象にするよう意味された作者~levelの~styleを，不用意に上書きし得る。
◎
and selectors, even low-specificity ones like simple type selectors, can accidentally override author-level styles meant to target the element.
</li>
</ul>

<p>
これを援助するため、この節では，所与の要素に対し
“既定の要素~style”
を与える~stylesheetの作成-法を定義する。
この種の~stylesheetは、［
文書~全体, および すべての`~shadow~tree$内
］にわたって適用され、その中の各~規則は，作者~levelの規則が自動的に勝つように，`~UA出自$の下で適用される。
◎
To aid in this, this section defines a way to create a stylesheet of "default element styles" for a given element. This stylesheet applies across the entire document, in all shadow trees, and the rules in it apply at the user agent origin, so author-level rules automatically win.
</p>

<p>
各 `Window$I は、
`defaultElementStylesMap@sl
内部~slotを持つ
— それは、要素の`局所~名$を~stylesheetに対応付ける。
それらの~stylesheetは：
◎
Windows gain a private slot [[defaultElementStylesMap]] which is a map of local names to stylesheets.
</p>

<ul>
	<li>
<p>
~window内のどの文書にも適用されるモノトスル。
加えて，~UA~stylesheetとして解釈されるモノトスル。
◎
These stylesheets must apply to every document in the window. They must be interpreted as user agent stylesheets.
</p>

<p class="note">注記：
これは特に、各~文書ごとに，その中のすべての`~shadow~tree$に適用され、それらの中の宣言は`~UA出自$になることを含意する。
◎
Note: This implies, in particular, that they apply to all shadow trees in every document, and that the declarations in them are from the user agent origin.
</p>
	</li>
	<li>
`~cascade$の目的においては、~UAの自前の~stylesheetより後の順になる。
この種の~stylesheetどうしの順序は、観測され得ないので，~~問題にはならない。
◎
For the purpose of the cascade, these stylesheets are ordered after the user agent’s own stylesheets; their relative ordering doesn’t matter as it is not observable.
</li>
	<li>
その中の`複体~選択子$は、無効になるモノトスル。
◎
Within these stylesheets, complex selectors must be treated as invalid.＼
</li>
	<li>
その中の`合体~選択子$は、［［
要素のうち，その`局所~名$は `defaultElementStylesMap$sl 内で当の~stylesheetに対応付けられるもの
］を選択する，`型~選択子$
］が追加されているものと扱うモノトスル。
◎
Every compound selector must be treated as containing an additional type selector that selects elements with the local name that the stylesheet is keyed with.
</li>
</ul>

<p class="issue">
この種の~stylesheetに利用-可能な`~at-rule$を制約する必要はあるか？
例えば、 `font-face$at は許容されるか？
編集者は、とりあえず，何か不都合を
聞くまで／聞かない限り
は、許容したままにしておくことにする。
◎
Do we need to restrict the at-rules that can be used in these sheets? For example, do we allow an @font-face? I’m going to leave it as allowed unless/until I hear complaints.
</p>

<p>
この仕様は、
`defaultElementStylesMap$sl を［
追加する, 除去する, その他、一般に操作する
］方法は，定義しない。
そうするための仕方は、 `DOM$r などの他の仕様が定義するものと期待される。
◎
This specification does not define how to add to, remove from, or generally manipulate the [[defaultElementStylesMap]]. It is expected that other specifications, such as [DOM], will define ways to do so.
</p>

	</section>
	<section id="shadow-dom">
<h2 title="Shadow Encapsulation">3. ~shadowの~encapsulation</h2>

		<section id="shadow-gloss">
<h3 title="Informative Explanation of Shadow DOM">3.1. ~shadow~DOMの説明</h3>

~INFORMATIVE

<p>
この節では、この仕様が何を定義しているかを，~DOM標準 `DOM$r を全部的に把握せずに理解するのを援助するため、~DOMが規範的に定義しているいくつかの概念を説明する。
◎
The following is a non-normative explanation of several concepts normatively defined in the DOM Standard [DOM], to aid in understanding what this spec defines without having to fully grok the DOM Standard.
</p>

<p>
`SELECTORS4$r の
<a href="~SELECTORS4#data-model">§ ~data~model</a>
に定義される要素~treeの各種~~特性に加え、~DOM標準は，`~shadow~tree$に関係するいくつかの新たな概念を追加している。
うちいくつかは~CSSにも関連する。
◎
In addition to the qualities of an element tree defined in Selectors Level 4 §data-model, the DOM Standard adds several new concepts related to shadow trees, several of which are relevant to CSS.
</p>

<p>
要素 %~host は、ある`~shadow~tree$ %~shadow~tree を~hostすることもある
— その根である`~shadow根$ %~shadow根 は、特別な種類の`文書片$である（要素~nodeではない）。
%~shadow根 の子孫は、普通の要素その他の~nodeからなる。
%~host は、 %~shadow根 の`~host$であり，
【 %~shadow~tree を~hostする】`~shadow~host$になる。
◎
An element can host a shadow tree, which is a special kind of document fragment with a shadow root (a non-element node) at its root. Children of the shadow root are ordinary elements and other nodes. The element hosting the shadow tree is its host, or shadow host.
</p>

<p>
%~shadow~tree 内の要素は、一般に %~host の`子孫$とはされない（`子孫~結合子$の様な選択子の目的も含め）。
しかしながら， %~shadow~tree は、 %~host が属する~tree
—  `~light~tree$ %~light~tree —
における`平坦~tree$の構築に利用される。
~CSSにおいては、この平坦~treeが，選択子<em>より後の</em> すべて目的に（継承や~boxの構築なども含め）利用される。
◎
The elements in a shadow tree are not descendants of the shadow host in general (including for the purposes of Selectors like the descendant combinator). However, the shadow tree, when it exists, is used in the construction of the flattened element tree, which CSS uses for all purposes after Selectors (including inheritance and box construction).
</p>

<p>
%~shadow~tree は、概ね，［
%~light~tree における， %~host の通常の内容
］に代わって %~host の内容として扱われる。
しかしながら，［
%~light~tree における %~host の子
］も、ある`~slot$ %~slot にアテガわれることにより， %~shadow~tree の “中に引き込まれる” ことはある
— そのような子は、~CSSの目的においては %~slot の子として扱われる。
さらには、 %~slot も，より深い`~shadow~tree$内の`~slot$にアテガわれることもある。
幸いなことに どの`~slot$も，それ自身は
<a href="#slots-in-shadow-tree">既定では~boxを生成しない</a>
ので、
%~shadow~tree を包装して~CSSを遮断している `slot$e 要素†の~cascadeを，作者が予測-不能になることはない。
【†~slotを作成できるのは、この型の要素に限られる。】
◎
Loosely, the shadow tree is treated as the shadow host’s contents instead of its normal light tree contents. However, some of its light tree children can be "pulled into" the shadow tree by assigning them to slots. This causes them to be treated as children of the slot for CSS purposes. The slots can then be assigned to slots in deeper shadow trees; luckily, slots themselves don’t generate boxes by default, so you don’t get an unpredictable cascade of slot wrapper elements disrupting your CSS.
</p>

<p>
`~slot$に何も明示的にアテガわれていない場合、代わりに `~slot$の自前の子たちが， “既定の” 内容としてアテガわれる。
◎
If nothing is explicitly assigned to a slot, the slot’s own children are instead assigned to it, as a sort of "default" contents.
</p>


		</section>
		<section id="selectors">
<h3 title="Shadow DOM and Selectors">3.2. ~shadow~DOMと選択子</h3>

			<section id="selectors-data-model">
<h4 title="Matching Selectors Against Shadow Trees">3.2.1. ~shadow~treeに対する選択子の照合-法</h4>

<p>
選択子が`~shadow~tree$に対し照合されるときの `selector match list^en† は、初期~時には，［
先頭の`~shadow~host$, および［
`~shadow~tree$の`~shadow根$
］の子孫すべて
］からなり、~tree順序になるとする。
<!-- ordered by a pre-order traversal -->
◎
When a selector is matched against a shadow tree, the selector match list is initially the shadow host, followed by all children of the shadow tree’s shadow root and their descendants, ordered by a pre-order traversal.
</p>

<p class="issue">†
これを【更新された `SELECTORS4$r 仕様の】より新たな形の照合~algoへの~callに見合うよう書直す。
◎
Rewrite this against the newer call forms of the matching algorithms.
</p>

<p class="note">注記：
`~shadow~tree$は、要素の子孫には含まれない
— 要素の子孫は、`~light~tree$内の，要素の`子$に基づく。
◎
Note: Remember that the descendants of an element are based on the light tree children of the element, which does not include the shadow trees of the element.
</p>

<p>
`~treeに対し選択子を照合-$するときの
`~tree文脈@
は、［
その~algoに渡される %根~要素
］の`根$で与えられる。
`~tree文脈$が`~shadow根$であるとき、選択子は
`~shadow~treeの文脈~下@
で照合されてるという。
◎
When a selector is matched against a tree, its tree context is the root of the root elements passed to the algorithm. If the tree context is a shadow root, that selector is being matched in the context of a shadow tree.
</p>

<div class="example">
<p>
例えば、ある~stylesheetが，`~shadow~tree$内の［
要素~内に埋込まれて／
要素から~linkされて
］いるとき，その~stylesheet内のどの選択子も，`~shadow~treeの文脈~下$にある。
`~shadow根$上で~callされる `querySelector()$m に渡す選択子~引数も同様になる。
◎
For example, any selector in a stylesheet embedded in or linked from an element in a shadow tree is in the context of a shadow tree. So is the argument to querySelector() when called from a shadow root.
</p>
</div>

<p>
宣言~block内の各~宣言は、それを適用するために照合した選択子の`~tree文脈$を継承する。
◎
Declarations inherit the tree context of the selector that was matched to apply them.
</p>



			</section>
			<section id="host-element-in-tree">
<h4 title="Selecting Shadow Hosts from within a Shadow Tree">3.2.2. ~shadow~treeの中から~shadow~hostを選択するとき</h4>

<p>
`~shadow~host$ %~host は、それが~hostする`~shadow~tree$ %~shadow~tree の外側にあるので、普通は，`~shadow~treeの文脈~下$で評価される選択子からは対象にできないが（選択子を照合する対象は，単独の~treeに制限される）、 %~shadow~tree の文脈の内側からも， %~host を~styleできれば有用になることもときどきある。
◎
A shadow host is outside of the shadow tree it hosts, and so would ordinarily be untargettable by any selectors evaluated in the context of the shadow tree (as selectors are limited to a single tree), but it is sometimes useful to be able to style it from inside the shadow tree context.
</p>

<ul>
	<li>
選択子の目的においては、 %~host も
— その子たちが %~shadow~tree の内容であるものと扱うように —
%~shadow~tree に現れる（言い換えれば、 %~host は，`~shadow根$
—  %~shadow~tree の根 — 
を置換するものとして扱われる）
◎
For the purpose of Selectors, a shadow host also appears in its shadow tree, with the contents of the shadow tree treated as its children. (In other words, the shadow host is treated as replacing the shadow root node.)
</li>
	<li>
%~host は、 %~shadow~tree の中では，`無特能$であると見なされ、合致し得る選択子は［
`host$ps ／ `host()$ps ／ `host-context()$ps
］疑似類に限られる。
◎
When considered within its own shadow trees, the shadow host is featureless. Only the :host, :host(), and :host-context() pseudo-classes are allowed to match it.
</li>
</ul>

<details class="note">
<summary>注記：
なぜ~shadow~hostは`無特能$にされているのか ？
◎
Why is the shadow host so weird?
</summary>

<p>
%~shadow~tree の外側に居る %~host の~markupは、
【~shadow~treeを内容とする】部品の作者ではなく，~page作者の制御~下にある。
◎
The shadow host lives outside the shadow tree, and its markup is in control of the page author, not the component author.
</p>

<p>
この部品が、 %~shadow~tree 内の~stylesheet内で，特定0の~class名を内部的に利用しているとする。
そのような部品を利用している~page作者が，同じ~class名を偶発的に %~host に利用した場合、良くないことが起こる。
そのような状況の結果，
【その~class名を選択する選択子を通して，~hostに】
偶発的にあてられる~styleは、部品~作者には予測-不可能であり，~page作者も~debugに戸惑うことになる。
◎
It would not be very good if a component used a particular class name internally in a shadow tree stylesheet, and the page author using the component accidentally also used the same class name and put it on the shadow host. Such a situation would result in accidental styling that is impossible for the component author to predict, and confusing for the page author to debug.
</p>

<p>
しかしながら、 %~shadow~tree 内の~stylesheetが， %~host を~styleすることが適理な利用事例も依然としてある（例えば，その部品は~flexboxとして~lay-outするよう求まれている場合、 %~host の `display$p を設定することが要求される）。
なので、この状況を許容しつつ，偶発的に~styleされないようにするため、 %~host は %~shadow~tree には現れるが、完全に`無特能$で，選択するためには部品~作者が明示的に［
`host$ps, あるいは `host()^ps, `host-context()^ps
］を通して~markupに合致させる他ないようにされている。
◎
However, there are still some reasonable use-cases for letting a stylesheet in a shadow tree style its shadow host. (For example, the component might want to be laid out as a flexbox, requiring the shadow host to be set to display: flex.) So, to allow this situation but prevent accidental styling, the shadow host appears but is completely featureless and unselectable except through :host and its related functional forms, which make it very explicit when you’re trying to match against markup provided by the page author.
</p>

</details>

			</section>
			<section id="host-selector">
<h4 title="Selecting Into the Light: the :host, :host(), and :host-context() pseudo-classes">3.2.3.  ~light~treeの中への選択-法： `host^ps, `host()^ps, `host-context()^ps 疑似類</h4>

<p>
`host@ps
疑似類は、`~shadow~treeの文脈~下$では，当の`~shadow~tree$を~hostしている`~shadow~host$に合致するように評価され、他の文脈~下では，何にも合致しない。
◎
The :host pseudo-class, when evaluated in the context of a shadow tree, matches the shadow tree’s shadow host. In any other context, it matches nothing.
</p>

<p>
関数形の疑似類
`host()@ps
の構文は、次で与えられる：
◎
The :host() function pseudo-class has the syntax:
</p>

<pre class="prod">
:host( `compound-selector$t )
</pre>

<p>
それは、`~shadow~treeの文脈~下$では，当の`~shadow~tree$を~hostしている`~shadow~host$であって, かつ［
通常の文脈~下で引数の選択子（`合体~選択子$）にも合致する
］ものに合致するように評価される。
他の文脈~下では，何にも合致しない。
◎
When evaluated in the context of a shadow tree, it matches the shadow tree’s shadow host if the shadow host, in its normal context, matches the selector argument. In any other context, it matches nothing.
</p>

<p>
`host$ps の`詳細度$は、疑似類のそれとする。
`host()$ps の`詳細度^は、疑似類のそれに引数の`詳細度^を足したものになる。
◎
The specificity of :host is that of a pseudo-class. The specificity of :host() is that of a pseudo-class, plus the specificity of its argument.
</p>

<p class="note">注記：
これは、 `is()$ps や `not()$ps の様な，類似するが引数の詳細度しかとらない疑似類の詳細度とは異なる。
そのわけは、 `host$ps が， “通常の” 疑似類の様に~~独力で【すなわち，引数なしでも】要素を選択するからである
— それは構文上の理由から引数に選択子をとるが（ `:host.foo^css に合致するなら `.foo^css にも合致させる必要がある）、他の点では，単に ある選択子が後続している `host^ps を利用することに一致する。
【 `:host.foo^css は `:host^css と `.foo^css の論理積を表すが、 `.foo^css 単体では~shadow~treeの外にあるものに合致できない。】
◎
Note: This is different from the specificity of similar pseudo-classes, like :is() or :not(), which only take the specificity of their argument. This is because :host is affirmatively selecting an element all by itself, like a "normal" pseudo-class; it takes a selector argument for syntactic reasons (we can’t say that :host.foo matches but .foo doesn’t), but is otherwise identical to just using :host followed by a selector.
</p>

<div class="example">
<p>
例えば、次の様な`~shadow~tree$を伴う部品があるとするとき：
◎
For example, say you had a component with a shadow tree like the following:
</p>

<pre class="lang-html">
&lt;x-foo class="foo"&gt;
  &lt;“~shadow~tree”&gt;
    &lt;div class="foo"&gt;...&lt;/div&gt;
  &lt;/“~shadow~tree”&gt;
&lt;/x-foo&gt;
</pre>

<p>
`~shadow~tree$の中の~stylesheetにおいては：
◎
For a stylesheet within the shadow tree:
</p>

<ul>
	<li>
`host$ps は、 `x-foo^e 要素に合致する。
◎
:host matches the &lt;x-foo&gt; element.
</li>
	<li>
`x-foo^css は、何にも合致しない。
◎
x-foo matches nothing.
</li>
	<li>
`.foo^css は `div^e 要素のみに合致する。
◎
.foo matches only the &lt;div&gt; element.
</li>
	<li>
`.foo:host^css は、何にも合致しない
— `.foo^css は `x-foo^e 要素に合致しないので。
◎
.foo:host matches nothing
</li>
	<li>
`:host(.foo)^css は、 `x-foo^e 要素に合致する
— 引数の `.foo^css も合致するので。
◎
:host(.foo) matches the &lt;x-foo&gt; element.
</li>
</ul>
</div>

<p>
`~shadow~tree$の中の選択子からは、普通は，`~shadow~tree$の外側にある要素は全く見えない。
しかしながら、~shadow~treeの外側のどこか, 同じ文書~内の, より上位にある先祖を選択できると有用になることもときどきある。
◎
Ordinary, selectors within a shadow tree can’t see elements outside the shadow tree at all. Sometimes, however, it’s useful to select an ancestor that lies somewhere outside the shadow tree, above it in the document.
</p>

<div class="example">
<p>
例えば、一群の部品からなる~groupは、それぞれがどう応答するか知る，一握りの色~themeを定義することもある
— ~page作者が、［
それらの部品または, 文書~内のより上位
］に特定の~classを追加して，特定0の~themeを任意選択で選べるような。
◎
For example, a group of components can define a handful of color themes they know how to respond to. Page authors could opt into a particular theme by adding a specific class to the components, or higher up in the document.
</p>

<p class="trans-note">【
すなわち、部品を内容に含ませている先祖にあてがわれた~classに応じて、利用する色~theme（部品どうしや, その内部の構成子たちの色合いが調和するように設計された，色の集合）を切り替える。
】</p>
</div>

<p>
関数形の疑似類
`host-context()@ps
は、`~shadow~tree$の外側に［
特定0の選択子に合致するような先祖
］があるかどうか~testする。
その構文は、次で与えられる：
◎
The :host-context() functional pseudo-class tests whether there is an ancestor, outside the shadow tree, which matches a particular selector. Its syntax is:
</p>

<pre class="prod">
:host-context( `compound-selector$t )
</pre>

<p>
`host-context()$ps
疑似類は、`~shadow~treeの文脈~下$では，［
当の~shadow~treeを~hostしている`~shadow~host$, または その`~shadowも含む先祖$
］のうち［
通常の文脈~下で引数の選択子（`合体~選択子$）に合致する
］ものに合致するように評価される。
他の文脈~下では，何にも合致しない。
◎
When evaluated in the context of a shadow tree, the :host-context() pseudo-class matches the shadow host, if the shadow host or one of its shadow-including ancestors matches the provided &lt;compound-selector&gt;. In any other context, it matches nothing.
</p>

<p>
`host-context()$ps の`詳細度$は、疑似類のそれに引数の`詳細度^を足したものになる。
◎
The specificity of :host-context() is that of a pseudo-class, plus the specificity of its argument.
</p>

<p class="note">注記：
これは、当の選択子は、［
文書の根に到達するか, 引数に合致する要素が見つかる
］まで，~shadow境界を貫くように遡ることを意味する。
◎
Note: This means that the selector pierces through shadow boundaries on the way up, looking for elements that match its argument, until it reaches the document root.
</p>

			</section>
			<section id="slotted-pseudo">
<h4 title="Selecting Slot-Assigned Content: the ::slotted() pseudo-element">3.2.4. ~slotにアテガわれた内容の選択-法： `slotted()^pe 疑似要素</h4>

<p>
`slotted()@pe
疑似要素は、`平坦~化され$た上で`~slot$にアテガわれた要素たちを表現する。
この疑似要素は：
◎
The ::slotted() pseudo-element represents the elements assigned, after flattening, to a slot.＼
</p>

<ul>
	<li>
`~slot$上にのみ存在する。
【すなわち、当の~slotが，この疑似要素の`出自の要素$になる。】
◎
This pseudo-element only exists on slots.
</li>
	<li>
当の~tree内の他の要素を指す<em>別名</em>であり、それ自体は~boxを生成しない。
◎
The ::slotted() pseudo-element is an alias for other elements in the tree, and does not generate any boxes itself.
</li>
	<li>
<p>
その文法は、次で与えられる：
◎
The grammar of the ::slotted() pseudo-element is:
</p>

<pre class="prod">
::slotted( `compound-selector$t )
</pre>

	</li>
	<li>
<p>
次をいずれも満たす要素を表現する：
◎
The ::slotted() pseudo-element represents the elements that are:
</p>

		<ul>
			<li>
`平坦~化され$て［
`slotted^pe の`出自の要素$である`~slot$
］にアテガわれている。
◎
assigned, after flattening, to the slot that is ::slotted’s originating element
</li>
			<li>
`要素に対し選択子を照合-$した結果、引数の `compound-selector$t （`合体~選択子$）に合致する。
◎
matched by its &lt;compound-selector&gt; argument
</li>
		</ul>
	</li>
	<li>
<span class="css">`slotted()^pe`before^pe</span>
の様に，
<a href="~CSSPSEUDO#tree-abiding">~treeに留まる疑似要素</a>
を後続させれる
— それは、 `slotted()$pe 疑似要素により表現される要素を`出自の要素$とする適切な疑似要素を表現する。
◎
The ::slotted() pseudo-element can be followed by a tree-abiding pseudo-element, like ::slotted()::before, representing the appropriate pseudo-element of the elements represented by the ::slotted() pseudo-element.
</li>
</ul>

<p>
`slotted()$pe の`詳細度$は、疑似要素のそれに引数の`詳細度^を足したものになる。
◎
The specificity of ::slotted() is that of a pseudo-element, plus the specificity of its argument.
</p>

<div class="example">
<p>
例えば、次の様な［
子たち, および~shadow~tree
］を伴う部品があるとする：
◎
For example, say you had a component with both children and a shadow tree, like the following:
</p>

<pre class="lang-html">
&lt;x-foo&gt;
  &lt;div id="one" slot="foo" class="foo"&gt;...&lt;/div&gt;
  &lt;div id="two" slot="foo"&gt;...&lt;/div&gt;
  &lt;div id="three" class="foo"&gt;
    &lt;div id="four" slot="foo"&gt;...&lt;/div&gt;
  &lt;/div&gt;
  &lt;“~shadow~tree”&gt;
    &lt;div id="five"&gt;...&lt;/div&gt;
    &lt;div id="six"&gt;...&lt;/div&gt;
    &lt;slot name="foo"&gt;&lt;/slot&gt;
  &lt;/“~shadow~tree”&gt;
&lt;/x-foo&gt;
</pre>

<p>
`~shadow~tree$の中の~stylesheetにおいては、選択子 `::slotted(*)^css は，［
`#one^css, `#two^css
］のみを選択する
— それらはもっぱら `slot$e 要素に
<a href="~DOM4#find-flattened-slotables">アテガわれる要素</a>なので。
それは、 `slot^a 属性を有さない `#three^css は選択しない。
また、 `#four^css も選択しない（ `~slot$にアテガわれる~nodeは、`~shadow~host$の（直な）`子$に限られるので）。
◎
For a stylesheet within the shadow tree, a selector like ::slotted(*) selects #one and #two only, as they’re the elements assigned to the sole slot element. It will not select #three (no slot attribute) nor #four (only direct children of a shadow host can be assigned to a slot).
</p>

<p>
一方で， `::slotted(.foo)^css の様な選択子は、［
`#one^css, `#two^css
］のうち `.foo^css に合致する前者のみを選択する。
◎
A selector like ::slotted(.foo), on the other hand, will only select #one, as it matches .foo, but #two doesn’t.
</p>

<p class="note">注記：
`::slotted(*)^css
の様な選択子は、
`*::slotted(*)^css と等価になる
— 先頭の `*^css は、 `slot$e 要素の他にも多数の要素を選択するが、`~slot$になるのは `slot$e 要素に限られるので，合致するのは `slotted()$pe 疑似要素に合致する要素に限られる。
◎
Note: Note that a selector like ::slotted(*) is equivalent to *::slotted(*), where the * selects many more elements than just the slot element. However, since only the slot elements are slots, they’re the only elements with a ::slotted() pseudo-element as well.
</p>
</div>

<p class="note">注記：
`~slot$には~text~nodeもアテガえるが、それらは `slotted()$pe では表現されないので，選択できない。
そのような~text~nodeを~styleする仕方は、`~slot$を~styleした上で，継承に依拠する他にない。
◎
Note: ::slotted() can only represent the elements assigned to the slot. Slots can also be assigned text nodes, which can’t be selected by ::slotted(). The only way to style assigned text nodes is by styling the slot and relying on inheritance.
</p>

			</section>
		</section>
		<section id="shadow-cascading">
<h3 title="Shadow Trees and the Cascade">3.3. ~shadow~treeと~cascade</h3>

<p>
`~cascade文脈$【！§ ~CASCADE#cascade-sort】 `CSS-CASCADE-4$r を見よ。
◎
See CSS Cascading 4 §6.1 Cascade Sorting Order.
</p>

		</section>
		<section id="flattening">
<h3 title="Flattening the DOM into an Element Tree" data-algorithm="Flattening the DOM into an Element Tree">3.4. ~DOMから要素~treeへの平坦~化-法</h3>

<p>
選択子は，~host言語が提示する~DOM~treeに対し演算するが、~CSSの他の部分が［
標準な 親／`子$ 関係性を介することでは到達-不能な，別々の~tree
］に働くためには、単一化された~tree構造が必要になる。
これは、
`平坦~化された要素~tree@
（略して，`平坦~tree$）と呼ばれ，次に従って構築される
【この “平坦~化” は、要素の入子ではなく，~treeの入子を平坦~化することを表す。】
：
◎
While Selectors operates on the DOM tree as the host language presents it, with separate trees that are unreachable via the standard parent/child relationship, the rest of CSS needs a single unified tree structure to work with. This is called the flattened element tree (or flat tree), and is constructed as follows:
</p>

<ol>
	<li>
%根 ~LET 文書の`根$要素
◎
↓</li>
	<li>
%処理待ち~node~list ~LET 空~list
— この~listは、 ( `~node^i, `親^i ) の組として与えられる~itemたちで拡充されることになる
◎
Let pending nodes be a list of DOM nodes with associated parents,＼
</li>
	<li>
%処理待ち~node~list に ( %根, ε ) を付加する
◎
initially containing just the document’s root element with no associated parent.
</li>
	<li>
%平坦~tree ~LET ε
◎
↓</li>
	<li>
<p>
~WHILE %処理待ち~node~list は空でない：
◎
Repeatedly execute the following substeps until pending nodes is empty:
</p>

		<ol>
			<li>
%~item ~LET %処理待ち~node~list の最初の~item
◎
↓</li>
			<li>
%処理待ち~node~list から %~item を除去する
◎
Pop the first element from pending nodes, and assign it to pending node.
</li>
			<li>
%~node ~LET %~item の `~node^i
◎
↓</li>
			<li>
~IF［
%平坦~tree ~NEQ ε
］
⇒
%~node を，%~item の `親^i の`子$として %平坦~tree の中に挿入する
◎
Insert pending node into the flat tree as a child of its associated parent.＼
</li>
			<li>
~ELSE
⇒
%平坦~tree ~SET %根 を根とする， %根 のみからなる新たな`平坦~tree$
◎
(If it has no associated parent, it’s the document root—just insert it into the flat tree as its root.)
</li>
			<li>
<p>
~IF［
%~node は`~shadow~host$である
］：
◎
Perform one of the following, whichever is the first that matches:
◎
pending node is a shadow host
</p>
				<ol>
					<li>
%~node が~hostしている`~shadow~tree$の`~shadow根$の
~EACH ( %子~node ) に対し
⇒
%処理待ち~node~list に
( %子~node, %~node )
を付加する
◎
Append the child nodes of the shadow root of the shadow tree it hosts to pending nodes, with pending node as their associated parent.
</li>
					<li>
~CONTINUE
</li>
				</ol>
			</li>
			<li>

<p>
~IF［
%~node は`~slot$である
］：
</p>
				<ol>
					<li>
%~slot可能~list ~LET `~slot用に~slot可能なものを見出す$( %~node )
</li>
					<li>
<p>
~IF［
%~slot可能~list は空でない
］：
</p>

<ol><li>%~slot可能~list 内の ~EACH( %~slot可能 ) に対し
⇒
%処理待ち~node~list に
( %~slot可能, %~node )
を付加する
</li><li>~CONTINUE
</li></ol>
					</li>
				</ol>
◎
pending node is a slot
◎
Find slottables for pending node, and append them to pending nodes, with pending node as their associated parent.
◎
↓If no slottables were found for pending node, instead append its children to pending nodes, with pending node as their associated parent.
</li>
			<li>
%~node の~EACH( （`~light~tree$における）`子$ %子 ) に対し
⇒
%処理待ち~node~list に
( `子$, %~node )
を付加する
◎
Otherwise,
◎
Append the child nodes of pending node’s light tree to pending nodes, with pending node as their associated parent.
</li>
		</ol>
	</li>
</ol>

<div class="note">
<p>注記：
言い換えれば、`平坦~tree$は~top-level~DOM~treeであるが：
</p>
<ul>
	<li>
各`~shadow~host$は、その`~light~tree$内の子たちに代わって，`~shadow~tree$内の子たちで埋められる（更に，その`~shadow~tree$も`~shadow~host$を包含するならば，これを再帰的に続行する）
</li>
	<li>
各`~slot$は、それにアテガわれた~nodeたちで埋められる（更に，`~slot$自身が より深い`~shadow~tree$内の`~slot$がアテガわれたなら，これを再帰的に続行する）。
</li>
</ul>
◎
Note: In other words, the flat tree is the top-level DOM tree, but shadow hosts are filled with their shadow tree children instead of their light tree children (and this proceeds recursively if the shadow tree contains any shadow hosts), and slots get filled with the nodes that are assigned to them (and this proceeds recursively if the slots are themselves assigned to a slot in a deeper shadow tree).
</div>

<p class="issue">
これによる明白でない結果は、~slotにアテガわれた要素は、その~slotから【~styleを】継承することである
— 要素の~light~treeにおける親や, その~slotがアテガわれている より深い~slotでなく。
このことは、【~slotにアテガわれた】~text~nodeは、その親の~shadow~treeにより~styleされ，他からはどうやっても介入できないことを意味する。
そのような~text~nodeを対象にする追加的な疑似要素は，求まれるか？
— それらにも，要素のときと同様に at all slot-assignment levels【？】で~styleできるように。
このことは、~light~tree内の~text~nodeに対しても，~slotに<!-- downwards -->アテガわれる前に，そのような疑似要素が働く必要があることを含意する。
なので、これは，ただの `slotted()$pe の変種にはなり得ない。
Luckily, this is a long-standing request!【何が Luckily？】
◎
A non-obvious result of this is that elements assigned to a slot inherit from that slot, not their light-tree parent or any deeper slots their slot gets assigned to. This means that text nodes are styled by the shadow tree of their parent, with nobody else capable of intervening in any way. Do we want an additional pseudo-element for targeting those text nodes so they can be styled at all slot-assignment levels, like normal elements can be? This implies it needs to work for text nodes in the light tree before they’re assigned downwards, so this can’t just be a ::slotted() variant. Luckily, this is a long-standing request!
</p>



			<section id="slots-in-shadow-tree">
<h4 title="Slots and Slotted Elements in a Shadow Tree">3.4.1. ~shadow~tree内の~slotとそれにアテガわれる要素</h4>

<p>
`~slot$は、［
`~UA出自$内の規則を介して，その `display$p に `contents$v がアテガわれている
］かのように動作するモノトスル。
これは、 `display$p を介して上書きできるモノトスル
— 欲されるときには、`~slot$が<em>~boxを生成できる</em>よう。
◎
Slots must act as if they were assigned display: contents via a rule in the UA origin. This must be possible to override via display, so they do generate boxes if desired.
</p>

<p class="trans-note">【
`HTML$r においては、これは，~UA~stylesheetの
`slot{ display: contents }^css
規則として
<a href="~HTMLrendering#flow-content-3">実装されている</a>。
】</p>


<p class="note">注記：
`~slot$に要素をアテガうことによる明白でない結果は、要素は，その`~slot$から【~styleを】継承することである。
［
`~light~tree$における要素の元の親
］／［
その`~slot$もまた 他の`~slot$にアテガわれたとするときの，他の`~slot$
］は、継承には影響しない。
◎
Note: A non-obvious result of assigning elements to slots is that they inherit from the slot they’re assigned to. Their original light tree parent, and any deeper slots that their slot gets assigned to, don’t affect inheritance.
</p>



			</section>
		</section>
		<section id="shadow-names">
<h3 title="Name-Defining Constructs and Inheritance">3.5. 名前を定義する構成子と継承</h3>

<p>
`~shadow~tree$は、~encapsulationの境界になること
— 独立な作者たちが、互いの名前空間を不用意に汚すことなく~codeを共有するのを許容すること —
が意味される。
例えば要素~IDは、一般に，文書の中で一意になることが意味されるが、異なる`~shadow~tree$内であれば，複数回~利用されても妥当になる。
◎
Shadow trees are meant to be an encapsulation boundary, allowing independent authors to share code without accidentally polluting each other’s namespaces. For example, element IDs, which are generally meant to be unique within a document, can be validly used multiple times as long as each use is in a different shadow tree.
</p>

<p>
同様に，~CSSにおける`~at-rule$のうちいくつか
— `keyframes$at や `font-face$at など —
は、~propや他の~at-ruleが，後で それを参照rできる名前を定義する。
これらの名前は、［
~IDの様に，大域的に公開され, 同じ文書の中で一意になる
］が、この制約もまた，今や［
~IDの様に，所与の`~shadow~tree$の中で一意になる
］よう緩められる。
◎
Similarly, several at-rules in CSS, such as @keyframes or @font-face, define a name that later at-rules or properties can refer to them by. Like IDs, these names are globally exposed and unique within a document; also like IDs, this restriction is now loosened to being unique within a given shadow tree.
</p>

<p>
しかしながら，~prop継承は、ある~treeから別の~treeへ値を運ぶこともあるため，所与の名前から正しい定義への参照-法は複雑化する。
これは，素朴に行われた場合、作者を［
驚かす／惑わす
］結果を生産し得る。
この節では、
“大域的” な名前を
— ~encapsulationを尊重して, 驚かす結果を与えない仕方で —
［
定義する／参照する
］ときに利用される概念を いくつか定義する。
◎
However, property inheritance can carry values from one tree to another, which complicates referencing the correct definition of a given name. Done naively, this can produce surprising and confusing results for authors. This section defines a set of concepts to use in defining and referencing "global" names in a way that respects encapsulation and doesn’t give surprising results.
</p>

<p>
ある［
~at-rule／~prop
］が，他の~CSS構成子から参照rできる名前（例：
`font-face$at の `font-family$d に与えた名前や，
`keyframes$at に与えた名前
）を定義する場合、それは，
`~tree視野な名前@
（ `tree-scoped name^en ）
— その視野は ある~treeに絞られる名前 —
として定義されなければナラナイ。
`~tree視野な名前$は、他が指定されない限り，特定0の`~node~tree$の中で “大域的” になり、当の［
~at-rule／~prop
］を定義した~stylesheetを~hostしている`要素$の`根$が結付けられる。
◎
If an at-rule or property defines a name that other CSS constructs can refer to it by, such as a @font-face font-family name or an @keyframes name, it must be defined as a tree-scoped name. Tree-scoped names are "global" within a particular node tree; unless otherwise specified, they’re associated with the root of the element hosting the stylesheet that the at-rule or property is defined in.
</p>

<p>
“大域的” な名前を参照する［
~prop／記述子
］
— `font-family$p や `animation-name$p ~propなど —
は、その値を
`~tree視野な参照@
（ `tree-scoped reference^en ）
— その視野は ある~treeに絞られる参照 —
として定義しなければナラナイ。
`~tree視野な参照$は、それに指定された値とともに，暗黙的に`~node~tree$の`根$を捕捉する
— それは、他が指定されない限り，当の［
~prop／記述子
］が定義されている~stylesheetを~hostしている`要素$の`根$になる。
この［
`根$への参照
］は、継承されても`~tree視野な参照$に伴い続ける。
◎
Properties or descriptors that reference a "global" name, such as the font-family or animation-name properties, must define their value as a tree-scoped reference. Tree-scoped references implicitly capture a node tree root along with their specified value: unless otherwise specified, the root of the element hosting the stylesheet that the property or descriptor is defined in. This root reference stays with the tree-scoped reference as it is inherited.
</p>

<p>
`~tree視野な参照$ %参照 を［
それが参照している~CSS構成子を見出すために参照解決する所
］では、まず，`~tree視野な名前$のうち［
それに結付けられている`根$が %参照 に結付けられている`根$と同じになるもの
］に限り探索するモノトスル
— 該当する`~tree視野な名前$は見出されなかった場合、
%参照 に結付けられている`根$は`~shadow根$であるならば，`根$の`~host$が属する`~node~tree$内でこの探索を繰返すとする（
言い換えれば，`~tree視野な名前$は、子孫~shadow~treeの中へ
— 子孫~tree自身が同じ名前を定義していない限り —
“継承される”
）
◎
Whenever a tree-scoped reference is dereferenced to find the CSS construct it is referencing, first search only the tree-scoped names associated with the same root as the tree-scoped reference must be searched. If no relevant tree-scoped name is found, and the root is a shadow root, then repeat this search in the root's host's node tree. (In other words, tree-scoped names "inherit" into descendant shadow trees, so long as they don’t define the same name themselves.)
</p>

<div class="issue">
<p>
［
大域的な名前を定義する すべての~at-rule／
それらを参照する すべての~prop
］は、これらの概念を利用するよう修正する必要がある：
◎
TODO: Fix all the at-rules that define global names, and the properties that reference them, to use these concepts.
</p>
<ul>
	<li>
`font-family$p から参照される `font-face$at
◎
@font-face, referenced by font-family
</li>
	<li>
`font-family$p から参照される `font-feature-values$at
◎
@font-feature-values, referenced by font-family
</li>
	<li>
`animation-name$p から参照される `keyframes$at
◎
@keyframes, referenced by animation-name
</li>
	<li>
`list-style-type$p から参照される `counter-style$at
◎
@counter-style, referenced by list-style-type
</li>
	<li>
`color$f 関数 から参照される `color-profile$at
◎
@color-profile, referenced by the color() function
</li>
	<li>
`font-palette$p から参照される `font-palette-values$at
◎
@font-palette-values, referenced by font-palette
</li>
	<li>
その他には？
◎
others?
</li>
</ul>
</div>

<div class="example">
<p>
例えば，次の文書において（仮想の~markup `::shadow^e は、要素の`~shadow~tree$を指示する）：
◎
For example, given the following document (using the imaginary &lt;::shadow&gt; markup to indicate an element’s shadow tree):
</p>

<pre class="lang-html">
&lt;p class=outer&gt;
<span class="comment">
ここでは、外縁~文書の "`foo^v" ~fontが利用される。
◎
Here’s some text in the outer document’s "foo" font.
</span>
&lt;/p&gt;
&lt;style&gt;
  @font-face {
    font-family: foo;
    src: url(https://example.com/outer.woff);
  }
  body { font-family: foo; }
  my-component::part(text) { font-family: foo; }
&lt;/style&gt;

&lt;my-component&gt;
  &lt;::shadow&gt;
    &lt;p class=inner-default&gt;
<span class="comment">
これは、外縁~文書の `font-family^p を継承している。
◎
I’m inheriting the outer document’s font-family.
</span>
    &lt;/p&gt;
    &lt;p class=inner-styled&gt;
<span class="comment">
ここでは、 `my-component^e 内の "`foo^v" ~fontを利用するよう，明示的に~styleされる。
◎
And I’m explicitly styled to be in the component’s "foo" font.
</span>
    &lt;/p&gt;
    &lt;p class=part-styled part=text&gt;
<span class="comment">
これは、外縁~文書により明示的に~styleされ，外縁~文書から "`foo^v" ~fontを取得する。
◎
I’m explicitly styled by the outer document, and get the outer document’s "foo" font.
</span>
    &lt;/p&gt;
    &lt;style&gt;
      @font-face {
        font-family: foo;
        src: url(https://example.com/inner.woff);
      }
      .inner-styled { font-family: foo; }
    &lt;/style&gt;
  &lt;/::shadow&gt;
&lt;/my-component&gt;
</pre>

<p>
`.outer^css 要素は、外縁 `font-face$at を参照する結果、
"`outer.woff^v" ~fileを利用する。
◎
The .outer element references the outer @font-face, using the "outer.woff" file.
</p>

<p>
`.inner-default^css 要素は、
`.outer^css と同じ`~tree視野な参照$を利用しているので，
`font-family$p の値を外縁~文書から継承する。
したがって，それも "`outer.woff^v" ~font~fileを利用する。
◎
The .inner-default element inherits the font-family: foo value from the outer document, using the same tree-scoped reference as .outer, and thus also uses the "outer.woff" font file.
</p>

<p>
他方， `.inner-style^css 要素は、
~shadowの内側にある~stylesheetから `font-family$p を受取る
— その`~tree視野な参照$は~shadowの `font-family^at を参照rする結果，
"`inner.woff^v" ~fileを利用する。
◎
The .inner-style element, on the other hand, receives a font-family: foo from the stylesheet inside the shadow, and thus its tree-scoped reference refers to the shadow’s @font-family, and it uses the "inner.woff" file.
</p>

<p>
`.part-styled^css 要素も，自身の~styleを外縁~文書から受取るが、継承によらずに，直に設定されている。
したがって，その`~tree視野な参照$も外縁~文書を参照rする結果，
"`outer.woff^v" ~fileを利用する。
◎
The .part-styled element also receives its style from the outer document, tho by being directly set rather than by inheritance. Thus, its tree-scoped reference also refer’s to the outer document, and it uses the "outer.woff" file.
</p>
</div>

<div class="example">
<p>
［
`~tree視野な名前$, `~tree視野な参照$
］がどう継承されるかを精確に~~説明するため、
3 ~levelの~treeからなる，もっと複階的な例を次に示す：
◎
Here is a more complex example, showing three levels of trees, and illustrating precisely how tree-scoped names and tree-scoped references inherit.
</p>

<pre class="lang-html">
&lt;style&gt;
  @font-face {
    font-family: foo;
    src: url(https://example.com/outer.woff);
  }
  body { font-family: foo; }
&lt;/style&gt;

&lt;child-component&gt;
  &lt;::shadow&gt;
    &lt;style&gt;
      @font-face {
        font-family: foo;
        src: url(https://example.com/inner.woff);
      }
    &lt;/style&gt;

    &lt;grandchild-component&gt;
      &lt;::shadow&gt;
        &lt;p class=inner-default&gt;
<span class="comment">
これは、外縁~文書の "`foo^v" ~font を継承している。
◎
I’m inheriting the outer document’s "foo" font.
</span>
        &lt;/p&gt;
        &lt;p class=inner-search&gt;
<span class="comment">
局所的な "`foo^v" ~fontは見出せなかったので、~treeをさらに遡るよう探索した結果，~shadowの "`foo^v" ~fontが見出される。
◎
And I can’t find a local "foo" font, so I’m searching further up the tree, and find the shadow’s "foo" font.</span>
        &lt;/p&gt;
        &lt;style&gt;
        .inner-search { font-family: foo; }
        &lt;/style&gt;
      &lt;/::shadow&gt;
    &lt;/grandchild-component&gt;
  &lt;/::shadow&gt;
&lt;/child-component&gt;
</pre>

<p>
ここでの `.inner-default^css は、前の例と同じく，外縁~文書~内に宣言された `font-family$p を継承しているので、外縁~文書の `font-face$at を参照することになる結果，
"`outer.woff^v" ~fileで描画される。
◎
Here, just as in the previous example, .inner-default is inheriting the font-family: foo declared in the outer document, and so it ends up referencing the outer document’s @font-face, and is rendered with the "outer.woff" file.
</p>

<p>
他方， `.inner-search^css は、自身の~styleを `grandchild-component^e の~shadow~tree内の~stylesheetから受取るので，
その~tree内の `foo^css ~fontを定義している `font-face$at を見出そうと試みる。
そのような `font-face^at は無いので、~shadow~treeを遡って，
`child-component^e 内に適切な `font-face^at を見出すことになる結果，
"`inner.woff^v" ~fileで描画される。
◎
On the other hand, .inner-search recieves its style from a stylesheet in &lt;grandchild-component&gt;’s shadow tree, so it attempts to find a @font-face defining a foo font in that tree. There is no such @font-face, so it starts walking up the shadow trees, finding an appropriate @font-face in &lt;child-component&gt;, so it’s rendered with the "inner.woff" file.
</p>
</div>

			<section id="shadow-names-serialization">
<h4 title="Serialized Tree-Scoped References">3.5.1. ~tree視野な参照が直列化されるとき</h4>

<p>
`~tree視野な参照$が直列化される場合、その値しか直列化されず，結付けられた`根$は失われる。
◎
If a tree-scoped reference is serialized, it serializes only its value; the associated root is lost.
</p>

<div class="example">
<p>
このことは、
<code>%要素.style.foo = getComputedStyle(%要素).foo;</code>
は
— `~shadow~tree$が存在しなければ、概して何もしないのと違って —
何もしないとは限らないことを含意する。
◎
This implies that `el.style.foo = getComputedStyle(el).foo;` is not necessarily a no-op, like it typically was before shadow trees existed.
</p>

<p>
例えば，次の文書において（仮想の~markup `::shadow^e は、要素の`~shadow~tree$を指示する）：
◎
For example, given the following document (using the imaginary &lt;::shadow&gt; markup to indicate an element’s shadow tree):
</p>

<pre class="lang-html">
&lt;p class=outer&gt;
<span class="comment">
ここでは、外縁~文書の "`foo^v" ~fontが利用される。
◎
Here’s some text in the outer document’s "foo" font.
</span>
&lt;/p&gt;
&lt;style&gt;
  @font-face {
    font-family: foo;
    src: url(foo.woff);
  }
  body { font-family: foo; }
&lt;/style&gt;

&lt;my-component&gt;
  &lt;::shadow&gt;
    &lt;p class=inner-default&gt;
<span class="comment">
これは、外縁~文書の `font-family^p を継承している。
◎
I’m inheriting the outer document’s font-family.
</span>
    &lt;/p&gt;
    &lt;p class=inner-styled&gt;
<span class="comment">
ここでは、 `my-component^e 内の "`foo^v" ~fontを利用するよう，明示的に~styleされる。
◎
And I’m explicitly styled to be in the component’s "foo" font.
</span>
    &lt;/p&gt;
    &lt;style&gt;
      @font-face {
        font-family: foo;
        src: url(https://example.com/foo.woff);
      }
      .inner-styled { font-family: foo; }
    &lt;/style&gt;
    &lt;script&gt;
      const %innerDefault = document.querySelector('.inner-default');
      const %innerStyled = document.querySelector('.inner-styled');
      const %defaultFont = getComputedStyle(%innerDefault).fontFamily;
      const %styledFont = getComputedStyle(%innerStyled).fontFamily;

      console.log(%defaultFont == %styledFont); // true!
    &lt;/script&gt;
  &lt;/::shadow&gt;
&lt;/my-component&gt;
</pre>

<p>
`.outer^css 要素は、外縁~文書の "`foo^v" `font-face$at で~styleされる。
`.inner-default^css 要素 %innerDefault は、外縁~文書から `font-family$p を継承するので，外縁~文書を参照している`~tree視野な参照$も継承する
— その結果， `.outer^css 要素と同じ~fontが利用される。
◎
The .outer element is styled with the outer document’s "foo" @font-face. The .inner-default element inherits font-family from the outer document, meaning it inherits a tree-scoped reference referencing that outer document, and so it’s in the same font as .outer.
</p>

<p>
その一方， `.inner-styled^css 要素 %innerStyled は、当の~shadow根の内側から明示的に~styleされるので、それを根とする~shadow~treeを参照している`~tree視野な参照$を新規に受取る
— その結果、この~shadowの自前の "`foo^v" `font-face$at で~styleされる。
◎
Meanwhile, .inner-styled is explicitly styled from inside the shadow root, so it receives a fresh tree-scoped reference referencing its shadow tree, and it is instead styled the shadow’s own "foo" @font-face.
</p>

<p>
にも関わらず，`my-component^e の内側で走っている~scriptからは、
%innerDefault, %innerStyled
の `font-family$p 用の値は同じに見える
— `~tree視野な参照$の［
`根$への参照
］を成す部分は、直列化により保全されないので。
~~仮に，
<code>%innerDefault.style.fontFamily = %defaultFont;</code>
のように設定した場合、
%innerDefault 用の~fontは，いきなり
%innerStyled 用の~fontに切替わる
— ［
~shadow~tree内に住まう，
%innerDefault の`~CSS~style属性$の~stylesheet
］内で `font-family$p ~propが設定されるので。
◎
Despite that, the script running inside the component sees the two elements as having the same value for font-family, because the root-reference part of a tree-scoped reference is not preserved by serialization. If it were to set innerDefault.style.fontFamily = defaultFont; (thus setting the font-family property of the element’s attribute stylesheet, which lives in the shadow tree), the .inner-default element would suddenly switch to the same font as .inner-styled!
</p>
</div>

<p class="note">注記：
`css-typed-om-1$r は、値を`具象化-$する規則において `~tree視野な参照$の［
`根$への参照
］も反映することにより，次を作者に許容するものと期待される
⇒＃
当の参照は，どの`~node~tree$から その値を得るかについて、伝えること／
2 つの`~node~tree$間で，値の意味が変化しないように値を~transportすること
◎
Note: The [css-typed-om-1] is expected to reflect the root reference of a tree-scoped reference in its reification rules for values, allowing authors to tell what node tree the reference is taking its values from, and allowing values to be transported across node trees without changing their meaning.
</p>
			</section>
		</section>
	</section>
	<section id="changes">
<h2 title="Changes">4. 変更点</h2>

<p>
<a href="~TR/2014/WD-css-scoping-1-20140403/">2014年 4月 3日 作業草案</a>
からの有意な変更点は：
◎
The following significant changes were made since the 3 April 2014 Working Draft.
</p>
<ul>
	<li>
`content^pe を `slotted^pe に改称した。
◎
Renamed ::content to ::slotted.
</li>
	<li>
`平坦~化された要素~tree$を定義した。
◎
Define the flattened tree.
</li>
	<li>
§ Shadow DOM を，現在の `DOM$r に基づくように~~編成し直した。
◎
Generally reorg and rebase the Shadow DOM section on top of current DOM.
</li>
	<li>
`scope^at, `region^pe
に関係するものを次の~levelの草案まで~~先送りした。
◎
Punt @scope and related things, and ::region and related things, to the next level of the draft.
</li>
	<li>
次に挙げるものの詳細度を定義した
⇒
`host$ps,
`host()$ps,
`host-context()$ps,
`slotted()$pe
◎
Define the specificity of :host, :host(), :host-context(), and ::slotted()
</li>
	<li>
結合子 `&gt;&gt;&gt;^css （~~過去には `/deep/^css と呼ばれていた）を除去した。
◎
Remove the &gt;&gt;&gt; (previously called /deep/) combinator.
</li>
	<li>
<a href="~CSSPSEUDO#tree-abiding">~treeに留まる疑似要素</a>は、
`slotted()$pe の後にも許容されるものと定義した。
◎
Define that tree-abiding pseudos are allowed after ::slotted().
</li>
	<li>
すべての［
疑似要素／疑似類
］に `compound-selector$t【！compound-selector-list】 を許容した。
◎
Allow &lt;compound-selector-list&gt; in all the pseudos.
</li>
	<li>
所与の要素~用の既定の要素~styleを成す~stylesheetを作成する仕方を定義した。
◎
Define a way to create a stylesheet of default element styles for a given element.
</li>
	<li>
`無特能$な要素には、何も合致しないようにした。
◎
Make featureless elements match nothing.
</li>
	<li>
“`~shadow~treeの文脈~下$” を定義した。
◎
Define in the context of a shadow tree.
</li>
</ul>

	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">~privacyと~securityの考慮点</h2>

<p>
この仕様は Shadow DOM および，ある~shadowを貫く能力を導入するが、それが何らかの［
~privacy／~security
］に課題を導入することはない
—  現在の~shadow ~DOMは、そのような境界にならないよう，意図的に指定されているので（また、
~UAの［
~shadow~DOMを利用する ／
そのような境界が<em>ある</em>
］部分は、暗黙的に未だ指定されていない保護に依拠している
— それはそれらをこの仕様にて定義されるものから保護する【？】
）。
◎
This specification introduces Shadow DOM and some shadow-piercing capabilities, but this does not introduce any privacy or security issues—shadow DOM, as currently specified, is intentionally not a privacy/security boundary (and the parts of the UA that use shadow DOM and do have a privacy/security boundary implicitly rely on protections not yet specified, which protect them from the things defined in this specification).
</p>

	</section>
</main></div>
