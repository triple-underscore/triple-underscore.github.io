<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Infrastructure for sequences of documents（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">
<style>

#_nav-table tr > *:first-child {
	max-width: 50vw;
}


.jake-diagram {
  border-style: hidden none hidden hidden;
  table-layout: fixed;
  background: white;
  color: black;
}

.jake-diagram, .jake-diagram :is(td, th, tr) {
  border-color: black;
}

.jake-diagram :where(th.step) {
  width: 95px;
  font-weight: normal;
}

.jake-diagram th:not(.step) {
  text-align: right;
}

.jake-diagram td.next-is-same-doc {
  border-right: dotted 2px;
}

.jake-diagram td.prev-is-same-doc {
  border-left: dotted 2px;
}

.jake-diagram .current {
  font-style: italic;
  font-weight: bold;
}

/* Chosen by clicking around https://colorhunt.co/palettes/pastel */
.jake-diagram .doc-0 {
  background: #F0EBE3;
}

.jake-diagram .doc-1 {
  background: #EEE4AB;
}

.jake-diagram .doc-2 {
  background: #D3CEDF;
}

.jake-diagram .doc-3 {
  background: #D6EFED;
}

.jake-diagram .doc-4 {
  background: #F4BFBF;
}

.jake-diagram .doc-5 {
  background: #DAE5D0;
}

.jake-diagram code {
	color: black;
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'coop':
case 'coep':
case 'coI':
case 'hH':
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}

</script>

<script type="text/plain" id="_source_data">

●●options

spec_date:2025-04-22
trans_update:2025-04-23
source_checked:221101
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/document-sequences.html
	abbr_url:HTMLds
site_nav:browsers,network,html
nav_prev:HTMLnavAPI
nav_next:HTMLnav
trans_1st_pub:2016-07-12

●●class_map
e:element
a:attr
sc:scheme
h:header
sl:js-slot
jv:js-value
U:code-point
v:value

●●tag_map
I:code
c:code
e:code
a:code
mt:code
sc:code
h:code
sl:span
jv:code
U:span
v:code
i:i
em:em
sub:sub

●●words_table


	●nav／履歴／閲覧／環境
agent:
navigator::::ナビゲータ
load:
	~load後:post-load
unload:
step:
about:
補助:auxiliary::~
開いた:openした::~
閉中:is closing::閉じかけ
閉じる:closeする::~
履歴上の:historicalな:~
BF:
	~BF~cache:bfcache
	一本道:linear
	前後へ:back and forward

	●関係／構造
広義-:inclusive:~
opener:::open 元
埋込元:embedder::埋め込み元
作成元:creator::~
作成元の:creator::~
対応関係:mapping::~
	~group分け:grouping
近しい:familiar:~
弱い:weakな::~
束ねら:tieさ:~

	一対一: 1:1
	一連の:series of
	~group分け:grouping
	生成元が類似な:similar-origin
	生成元を~keyに:origin-keyed

	●UI
popup:
一過:transient::~
隠す:hideする:~

	~UItab化:tabbed

	●処理一般
処理待ち:pending:~
存続期間:lifetime:~
作成時の:creation::~
切替n:switch:切り替え
並列:parallel::~
保たれ:keepされ:~
process::::プロセス
一時的:temporary:~
粗化-:coarsen:粗く
params::::パラメタ群

	終わらす:finish
	遅延~中:delaying
	報告のみの:report-only
	報告-法:reporting
	いつでも:at any time
	時点:at this point
	一歩先へ進む:step ahead of
	そのままにする:leaves 〜 as-is
	同期cしない:get out of sync
	何もさせないようにする:have it be a no-op
	逆順に:in reverse order

	●変数

	%noopener:noopener
	%B:start
	%A:navigable
	%B:potentialParent
	%A:potentialDescendant
	%B:potentialAncestor
	%文書:potentialDescendantDocument
	%~URL:url
	%~agent:agent
	%~entry:entry
	%~group:group
	%~load計時~報:loadTimingInfo
	%~navigable:-
	%~navigable:navigable
	%~navigable容器~群:navigableContainer
	%~navigable容器~群:navigableContainers
	%~navigable群:navigables
	%~opener:opener
	%~opener~top-level閲覧~文脈:openerTopLevelBrowsingContext
	%~realm実行~文脈:realm execution context
	%~sandbox~flag群:sandboxFlags
	%~sandbox法~flag集合:sandboxingFlagSet
	%~source生成元:sourceOrigin
	%~target名:targetName
	%~top-level作成時の~URL:topLevelCreationURL
	%~top-level生成元:topLevelOrigin
	%~unload対象:toUnload
	%~window種別:windowType
	%作成元:creator
	%作成元の生成元:creatorOrigin
	%作成元の基底~URL:creatorBaseURL
	%先祖~群:ancestors
	%入力~navigable:inputNavigable
	%入子な履歴:nestedHistory
	%初期~navi~POST資源:initialNavigationPostResource
	%初期~navi~URL:initialNavigationURL
	%初期~履歴~entry:initialHistoryEntry
	%名前:name
	%埋込元:embedder
	%安全でない文脈~作成~時刻:unsafeContextCreationTime
	%容器:container
	%履歴~entry:historyEntry
	%文書:d
	%文書:document
	%文書~状態:documentState
	%現在の~navigable:currentNavigable
	%現在の文書:currentDocument
	%生成元:origin
	%結果:chosen
	%要素:element
	%親~navigable:parentNavigable
	%親~navigable~entry群:parentNavigableEntries
	%親:parent
	%親~文書~状態:parentDocState
	%許可~施策:permissionsPolicy
	%辿可能:traversable
	%閲覧~文脈:browsingContext
	%~target~step履歴~entry:targetStepSHE
	%すべて~unload後の手続き:afterAllUnloads
	%~WebDriver用の~opener~navigable:openerNavigableForWebDriver
	%~source~snapshot~params:sourceSnapshotParams
	%探索する下位tree群:subtreesToSearch
	%探索する下位tree:subtreeToSearch
	%探索する文書:documentToSearch
	%現在の~top-level閲覧~文脈:currentTopLevelBrowsingContext
	%~top-level閲覧~文脈~topLevelBrowsingContext

	●保安
阻止器:blocker::~::ブロッカー
	~sandbox法:sandboxing
	許可-済み:permitted

	●仕様
伝えて:informして:~
通過制御-:gate:~
特質:property:~:::プロパティ
義務的:mandatory:~
究明-:investigate:~
	究明している:under investigation
稀:rare:~
細部:subtleties:~
文言:language:~
適格:eligible:~
実現可能:feasible:~
作成者:creator:~
図画化-:depict:~
合格-:pass:~
捕捉-:capture:~
可視化-:visualize:~
概略的:brief:~
決着-:settle:~

	選ばれ:choice
	~~選ぶ:pick
	選ぶ:choose する
	~~想定され:envision
	~~用意-:curate
	処して:dealing
	表す:denote
	考慮点:considerations
	明瞭でない:unclear
	名前を継ぐ:named after
	現実的には:in reality
	責務／責務がある:responsible
	全体を通して:throughout
	きちんと定義された:well-defined
	面して:facing
	になることもある:not necessarily 〜 non-
	必ず:never 〜 non-
	まずない:likely to never
	よい:ok
	各自の:their respective
	とすると:thus
	~~説明:illustrate
	〜結果:starts out
	し易くする:help
	無くなった:nothing 〜 anymore
	在る下では:in the presence of
	課され:impose
	できそう:may be able to
	簡潔にする:brevity
	判る:cognizant of
	数えられ:count
	もちろん:of course
	好都合になる:helpful
	より高~level:higher-level
	に注意:notice
	調べる:look at
	比類なき:inimitable
	-:labeled
	-:mark
	-:ever
	効いている:in play
	別々に:separation
	アリ性:possibilities

	●未分類
virtual:
Jake:
WindowProxy:
POST:
WebDriver:
WebDriver-BiDi:
新鮮:fresh:~
倉:shed::~::シェッド
	open:
		-:opener:
集析:mining::~::マイニング
近過去:recent:~
	最も近過去に:most recently
番号:number:~
現-:current:~
新-:new:~
ナシ:none:なし
旧-:old:~
確定的:definite:~

	様々な:various
	引き継がな:carry over
	近く:closely
	表示-可能でな:non-displayable
	~group分け:grouping
	あらゆる:every
	1 階:single
	残され:left
	~NULL 化:nulled out
	またがって:across
	現れる:appear
	含む:includeする
	整数:number
	太字斜字体:bold-italic
	後続して:subsequent
	住まい得る:can live
	~~再現:replicate
	-:ocassion


●●original_id_map

	旧 id
	creating-a-new-browsing-context-group-and-document:creating-a-new-browsing-context-group
	content-navigable:nested-browsing-context
	child-navigable:child-browsing-context
	nav-parent:parent-browsing-context
	nav-container:bc-container
	nav-container-document:bc-container-document
	create-a-new-child-navigable:creating-a-new-nested-browsing-context
	descendant-navigables:list-of-the-descendant-browsing-contexts
	document-tree-child-navigables:document-tree-child-browsing-context
	navigable-target-names:browsing-context-names
	valid-navigable-target-name:valid-browsing-context-name
	valid-navigable-target-name-or-keyword:valid-browsing-context-name-or-keyword
	the-rules-for-choosing-a-navigable:the-rules-for-choosing-a-browsing-context-given-a-browsing-context-name
	navigable-container:browsing-context-container
	nav-target:browsing-context-name
	nav-current-history-entry:current-entry
	tn-session-history-entries:session-history
	close-a-top-level-traversable:close-a-browsing-context
	close-a-top-level-traversable:closing-browsing-contexts
	familiar-with:security-1
	familiar-with:security-nav


●●words_table1
WEBDRIVER-BIDI:https://w3c.github.io/webdriver-bidi/

about_blank:about:blank
about_srcdoc:about:srcdoc
html-head-body: <code class="element">html</code>, <code class="element">head</code>, <code class="element">body</code> 

●●link_map

	●code
I.BarProp:~WINDOW#barprop
I.Document:~HTMLdom#document
I.Window:~WINDOW#window
~window:~WINDOW#the-window-object
文書:~HTMLdom#the-document-object
I.WindowProxy:~HTMLWPROXY#windowproxy
I.CustomElementRegistry:~HEcustom#customelementregistry

	＠~WINDOW#dom-window-open
	＠~WINDOW#dom-window-parent
	＠~WINDOW#dom-barprop-visible

h.Cross-Origin-Embedder-Policy:~ORIGIN#cross-origin-embedder-policy
h.Cross-Origin-Opener-Policy:~ORIGIN#cross-origin-opener-policy-2

mt.text/html:~HTMLiana#text/html
sc.~about_blank:~HTMLdep#about:blank
sc.~about_srcdoc:~HTMLurl#about:srcdoc
sl.Window:~HTMLWPROXY#concept-windowproxy-window
v.allow-popups:~ORIGIN#attr-iframe-sandbox-allow-popups

e.a:~HEtextlevel#the-a-element
e.button:~HEforms#the-button-element
e.frame:~HTMLobs#frame
e.frameset:~HTMLobs#frameset
e.iframe:~HEembed#the-iframe-element
a.target:~HTMLlinks#attr-hyperlink-target
a.sandbox:~HEembed#attr-iframe-sandbox

v.allow-top-navigation:~ORIGIN#attr-iframe-sandbox-allow-top-navigation

coI.concrete:#cross-origin-isolation-concrete
coI.logical:#cross-origin-isolation-logical
coI.none:#cross-origin-isolation-none


	●用語


~Jake図式:#jake-diagram

~navigable:#navigable
nav.~ID:#nav-id
nav.~target名:#nav-target
nav.~top-level辿可能:#nav-top
nav.作動中な~WindowProxy:#nav-wp
nav.作動中な~entry:#nav-active-history-entry
nav.作動中な~window:#nav-window
nav.作動中な文書:#nav-document
nav.作動中な閲覧~文脈:#nav-bc
nav.容器:#nav-container
nav.容器~文書:#nav-container-document
nav.現在の~session履歴~entry:#nav-current-history-entry
nav.辿可能な~navigable:#nav-traversable
nav.親:#nav-parent
nav.~load~event遅延-中か:#delaying-load-events-mode
nav.閉中か:#is-closing

辿可能な~navigable:#traversable-navigable
nav.~session履歴~entry群:#tn-session-history-entries
nav.~session履歴~辿り~queue:#tn-session-history-traversal-queue
nav.~system可視性~状態:#system-visibility-state
nav.~web内容により作成されたか:#is-created-by-web-content
nav.入子な履歴~stepの適用-を走らせているか:#tn-running-nested-apply-history-step
nav.入子な履歴を適用する段を走らせているか:#tn-running-nested-apply-history-step
nav.現在の~session履歴~step:#tn-current-session-history-step

~navigable容器:#navigable-container
内容~navigable:#content-navigable
子~navigable:#child-navigable
子孫~navigable群:#descendant-navigables
広義-子孫~navigable群:#inclusive-descendant-navigables
文書~treeに属する子~navigable群:#document-tree-child-navigables
親~navigable:#nav-parent
先祖~navigable群:#ancestor-navigables
広義-先祖~navigable群:#inclusive-ancestor-navigables
~node~navigable:#node-navigable
~navigableを初期化する:#initialize-the-navigable
~navigableを~target名により見出す:#find-a-navigable-by-target-name
~navigableを選ぶ規則:#the-rules-for-choosing-a-navigable
妥当な~navigable~target名:#valid-navigable-target-name
妥当な~navigable~target名または~keyword:#valid-navigable-target-name-or-keyword
新たな子~navigableを作成する:#create-a-new-child-navigable
子~navigableを破壊する:#destroy-a-child-navigable

~top-level辿可能:#top-level-traversable
~top-level辿可能~集合:#top-level-traversable-set
~top-level辿可能を破壊する:#destroy-a-top-level-traversable
新鮮な~top-level辿可能を作成する:#create-a-fresh-top-level-traversable
新たな~top-level辿可能を作成する:#creating-a-new-top-level-traversable
~top-level辿可能を閉じる:#close-a-top-level-traversable
~top-level辿可能を確定的に閉じる:#definitely-close-a-top-level-traversable


全部的に作動中:#fully-active
内容~window:#content-window
内容~文書:#concept-bcc-content-document
doc.容器~文書:#doc-container-document
生成元を決定する:#determining-the-origin

閲覧~文脈:#browsing-context
bc.~popupか:#is-popup
bc.~top-level辿可能:#bc-traversable
bc.~top-level閲覧~文脈:#bc-tlbc
bc.~virtual閲覧~文脈~group~ID:#virtual-browsing-context-group-id
bc.作動中な~window:#active-window
bc.作動中な文書:#active-document
bc.作成時の~opener生成元:#opener-origin-at-creation
bc.初期~URL:#browsing-context-initial-url
bc.補助か:#is-auxiliary
bc.開いた閲覧~文脈:#opener-browsing-context
補助~閲覧~文脈:#auxiliary-browsing-context
~top-level閲覧~文脈:#top-level-browsing-context
先祖~閲覧~文脈:#ancestor-browsing-context
属する閲覧~文脈:#concept-document-bc
新たな~top-level閲覧~文脈と文書を作成する:#creating-a-new-top-level-browsing-context
新たな補助~閲覧~文脈と文書を作成する:#creating-a-new-auxiliary-browsing-context
新たな閲覧~文脈~groupと文書を作成する:#creating-a-new-browsing-context-group-and-document
新たな閲覧~文脈と文書を作成する:#creating-a-new-browsing-context
近しい:#familiar-with

閲覧~文脈~group:#browsing-context-group
bcG.~agent~cluster~map:#agent-cluster-map
bcG.履歴上の~agent~cluster~key~map:#historical-agent-cluster-key-map
bcG.閲覧~文脈~集合:#browsing-context-set
bcG.非同一-生成元~隔離~mode:#bcg-cross-origin-isolation
非同一-生成元~隔離~mode:#cross-origin-isolation-mode
閲覧~文脈~groupから除去する:#bcg-remove
閲覧~文脈~groupに付加する:#bcg-append
閲覧~文脈~group集合:#browsing-context-group-set
tbcG.~group:#tlbc-group


	●用語（HTML
文書から除去された:~HTMLINFRA#remove-an-element-from-a-document
新たな一意かつ内部的な値:~HTMLcms#new-unique-internal-value
~about_blank に合致して:~HTMLurl#matches-about:blank

doc.~load計時~報:~HTMLdom#load-timing-info
doc.~referrer:~HTMLdom#the-document's-referrer
doc.初期~about_blankか:~HTMLdom#is-initial-about:blank
doc.施策~容器:~HTMLdom#concept-document-policy-container
doc.許可~施策:~HTMLdom#concept-document-permissions-policy
doc.~opener施策:~HTMLdom#concept-document-coop
doc.~about基底~URL:~HTMLdom#concept-document-about-base-url

~navi開始~時刻:~HTMLdom#navigation-start-time
初期~about_blank な文書:~HTMLdom#is-initial-about:blank
文書~load計時~報:~HTMLdom#document-load-timing-info

一過な作動化を有して:~HTMLinteraction#transient-activation
文書~基底~URL:~HTMLurl#document-base-url
利用者-作動化を消費する:~HTMLinteraction#consume-user-activation

	＠~ORIGIN#coop-struct-report-only-value
coOP.値:~ORIGIN#coop-struct-value
coop.same-origin-plus-COEP:~ORIGIN#coop-same-origin-plus-coep
coop.same-origin:~ORIGIN#coop-same-origin
~popup~sandbox法~flag集合:~ORIGIN#popup-sandboxing-flag-set
~sandboxは補助~閲覧~文脈に伝播する~flag:~ORIGIN#sandbox-propagates-to-auxiliary-browsing-contexts-flag
~sandbox法~flag集合:~ORIGIN#sandboxing-flag-set
不透明な生成元:~ORIGIN#concept-origin-opaque
~opener施策:~ORIGIN#cross-origin-opener-policy
非同一-生成元~隔離と互換:~ORIGIN#compatible-with-cross-origin-isolation
作動中な~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
作成時の~sandbox法~flag群を決定する:~ORIGIN#determining-the-creation-sandboxing-flags
同じ生成元~domain:~ORIGIN#same-origin-domain
sub.生成元:~ORIGIN#same-origin
施策~容器を~cloneする:~ORIGIN#clone-a-policy-container
生成元:~ORIGIN#concept-origin
許可-済み~navigator:~ORIGIN#one-permitted-sandboxed-navigator
閲覧~文脈~sandbox化( ~navi )~flag:~ORIGIN#sandboxed-navigation-browsing-context-flag
閲覧~文脈~sandbox化( 生成元 )~flag:~ORIGIN#sandboxed-origin-browsing-context-flag
閲覧~文脈~sandbox化( 補助~navi )~flag:~ORIGIN#sandboxed-auxiliary-navigation-browsing-context-flag

結付けられた文書:~WINDOW#concept-document-window
~window用に環境~設定群~objを設定しておく:~WINDOW#set-up-a-window-environment-settings-object

読込ngを完全に終わらす:~HTMLlifecycle#completely-finish-loading
文書とその子孫たちを破壊する:~HTMLlifecycle#destroy-a-document-and-its-descendants
文書とその子孫たちを~unloadする:~HTMLlifecycle#unload-a-document-and-its-descendants
文書を~html-head-bodyで拡充する:~HTMLlifecycle#populate-with-html/head/body
	＠~HTMLlifecycle#destroy-a-document

子~navigableの破壊について~navi~APIに伝える:~HTMLnavAPI#inform-the-navigation-api-about-child-navigable-destruction

dS.文書:~HTMLnav#document-state-document
dS.生成元:~HTMLnav#document-state-origin
dS.起動元~生成元:~HTMLnav#document-state-initiator-origin
dS.~navigable名:~HTMLnav#document-state-nav-target-name
dS.入子な履歴~群:~HTMLnav#document-state-nested-histories
dS.~about基底~URL:~HTMLnav#document-state-about-base-url
nH.~ID:~HTMLnav#nested-history-id
nH.~entry群:~HTMLnav#nested-history-entries
shE.~URL:~HTMLnav#she-url
shE.文書:~HTMLnav#she-document
shE.文書~状態:~HTMLnav#she-document-state
shE.~step:~HTMLnav#she-step
	i.文書~資源:~HTMLnav#navigation-resource
hH.replace:~HTMLnav#navigationhistorybehavior-replace
~POST資源:~HTMLnav#post-resource

~navigableを~URLへ~navigateする:~HTMLnav#navigate
~navi~algo:~HTMLnav#navigate
~navigate:~HTMLnav#navigate
~session履歴~entry:~HTMLnav#session-history-entry
~session履歴~辿り並列~queue:~HTMLnav#session-history-traversal-parallel-queue
~session履歴~辿り手続きを付加する:~HTMLnav#tn-append-session-history-traversal-steps
~session履歴~entry群を取得する:~HTMLnav#getting-session-history-entries
~unloadは取消されたか否か検査する:~HTMLnav#checking-if-unloading-is-canceled
文書を作動中にする:~HTMLnav#make-active
入子な履歴:~HTMLnav#nested-history
~navigableの作成／破壊~用に更新する:~HTMLnav#update-for-navigable-creation/destruction
履歴~stepを適用する:~HTMLnav#apply-the-history-step
文書~状態:~HTMLnav#document-state-2
新たな~session履歴~辿り並列~queueを開始する:~HTMLnav#starting-a-new-session-history-traversal-parallel-queue
	＠~HTMLnav#traverse-the-history-by-a-delta
~navigateすることは~sandbox法により許容され:~HTMLnav#allowed-to-navigate
~source~snapshot~paramsを~snapshotする:~HTMLnav#snapshotting-source-snapshot-params

enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability
~agent~cluster~key:~WAPI#agent-cluster-key
新たな~realmを作成する:~WAPI#creating-a-new-javascript-realm
環境~設定群~obj:~WAPI#environment-settings-object
生成元が類似な~window~agentを得する:~WAPI#obtain-similar-origin-window-agent
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object

~load後~task準備済み:~HTMLparsing#ready-for-post-load-tasks

	●用語（外部
実装定義:~INFRA#implementation-defined
set.付加する:~INFRA#set-append
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII~tabや~ASCII改行文字:~INFRA#ascii-tab-or-newline
~list:~INFRA#list
集合:~INFRA#ordered-set
~map:~INFRA#ordered-map
付加する:~INFRA#list-append
前付加する:~INFRA#list-prepend
拡張する:~INFRA#list-extend
空:~INFRA#list-is-empty
除去する:~INFRA#list-remove

新たな~obj:~WEBIDLjs#new

接続されて:~DOM4#connected
~node:~DOM4#interface-node
doc.~URL:~DOM4#concept-document-url
doc.~mode:~DOM4#concept-document-mode
doc.内容~型:~DOM4#concept-document-content-type
doc.生成元:~DOM4#concept-document-origin
doc.種別:~DOM4#concept-document-type
doc.宣言的な~shadow根を許容するか:~DOM4#document-allow-declarative-shadow-roots
doc.~custom要素~registry:~DOM4#document-custom-element-registry
~node文書:~DOM4#concept-node-document
~shadowも含めた~tree順序:~DOM4#concept-shadow-including-tree-order
~shadowも含めた子孫:~DOM4#concept-shadow-including-descendant
~shadowも含めた根:~DOM4#concept-shadow-including-root
~tree順序:~DOM4#concept-tree-order
子孫:~DOM4#concept-tree-descendant

url.生成元:~URL1#concept-url-origin
~URL:~URL1#concept-url
~URLを直列化する:~URL1#concept-url-serializer

~agent~cluster:~TC39#sec-agent-clusters

時刻を粗化する:~HRTIME#dfn-coarsen-time
安全でない共有される現在の時刻:~HRTIME#dfn-unsafe-shared-current-time

辿可能~storage倉を旧来~cloneする:~STORAGE#legacy-clone-a-traversable-storage-shed

~navigable用の許可~施策を作成する:~PERMISSIONS-POLICY#create-for-navigable

~WebDriver-BiDi~navigableが作成された:~WEBDRIVER-BIDI#webdriver-bidi-navigable-created
~WebDriver-BiDi~navigableが破壊された:~WEBDRIVER-BIDI#webdriver-bidi-navigable-destroyed

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ Infrastructure for sequences of documents</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

<body>

<header>
	<hgroup>
<h1>HTML — 文書連列用の基盤</h1>
<p>Infrastructure for sequences of documents</p>
	</hgroup>
</header>

<hr>

<main id="MAIN" hidden>

		<section id="infrastructure-for-sequences-of-documents">
<h3 title="Infrastructure for sequences of documents">7.3. 文書~連列~用の基盤</h3>

<p>
この標準は、
文書~連列（ `sequence of documents^en ）たちに~group分けするため，
いくつかの関係する概念を包含する。
規範的でない概略的な要約は：
◎
This standard contains several related concepts for grouping sequences of documents. As a brief, non-normative summary:
</p>
<ul>
	<li>
`~navigable$は、
利用者が面している文書~連列の表現である
— すなわち，各~文書~間で~navigateできる何かを表現する。
代表的な例として［
~web~browser内の~UItabや~UIwindow,
`iframe$e,
`frameset$e 内の `frame$e
］が挙げられる。
◎
Navigables are a user-facing representation of a sequence of documents, i.e., they represent something that can be navigated between documents. Typical examples are tabs or windows in a web browser, or iframes, or frames in a frameset.
</li>
	<li>
`辿可能な~navigable$は、
特別な型の~navigableであり，［
自身, および その子孫~navigable
］の~session履歴を制御する。
すなわち，それは、
自前の一連の文書に加えて，［
各~子孫~navigableが表現する一連の文書
］たちが成す~tree
］および［
この~treeを平坦~化した~viewを通して，前後へ一本道に辿る能
］を表現する。
◎
Traversable navigables are a special type of navigable which control the session history of themselves and of their descendant navigables. That is, in addition to their own series of documents, they represent a tree of further series of documents, plus the ability to linearly traverse back and forward through a flattened view of this tree.
</li>
	<li>
`閲覧~文脈$は、
開発者が面している［
一連の文書
］の表現である。
各`閲覧~文脈$は、
各 `WindowProxy$I ~objと一対一に対応する。
各`~navigable$は、
一連の閲覧~文脈を呈示し得ることに加え，
それら閲覧~文脈~間で［
ある種のきちんと定義された状況下で生じる`切替n＠~ORIGIN#browsing-context-group-switches-due-to-cross-origin-opener-policy$
］を伴う。
◎
Browsing contexts are a developer-facing representation of a series of documents. They correspond 1:1 with WindowProxy objects. Each navigable can present a series of browsing contexts, with switches between those browsing contexts occuring under certain well-defined circumstances.
</li>
</ul>

<p>
この標準は、
ほとんどにおいては，~navigableの文言で働くが、
ある種の~APIは，閲覧~文脈の切替nの存在を公開する
— なので、
この標準は，一部においては閲覧~文脈の用語で働く必要がある。
◎
Most of this standard works in the language of navigables, but certain APIs expose the existence of browsing context switches, and so some parts of the standard need to work in terms of browsing contexts.
</p>

			<section id="navigables">
<h4 title="Navigables">7.3.1. ~navigable</h4>

<p>
`~navigable@
（ `navigable^en ）は、
その`作動中な~entry$navを介して，利用者に`文書$を呈示する。
各`~navigable$は、
次に挙げるものを有する：
◎
A navigable presents a Document to the user via its active session history entry. Each navigable has:
</p>
<ul>
	<li>
`~ID@nav
⇒
`新たな一意かつ内部的な値$
◎
An id, a new unique internal value.
</li>
	<li>
`親@nav
⇒
`~navigable$／~NULL
◎
A parent, a navigable or null.
</li>
	<li>
<p>
`現在の~session履歴~entry@nav
⇒
`~session履歴~entry$
◎
A current session history entry, a session history entry.
</p>

<p>
これが改変され得るのは、
親の`辿可能な~navigable$の`~session履歴~辿り~queue$navの中にあるときに限られる。
◎
This can only be modified within the session history traversal queue of the parent traversable navigable.
</p>
	</li>
	<li>
<p>
`作動中な~entry@nav
⇒
`~session履歴~entry$
◎
An active session history entry, a session history entry.
</p>

<p>
これが改変され得るのは、
`作動中な~entry$navの`文書$shEの~event~loopからに限られる。
◎
This can only be modified from the event loop of the active session history entry's document.
</p>
	</li>
	<li>
<p>
`閉中か@nav
⇒
真偽値
— 初期~時は ~F とする。
◎
An is closing boolean, initially false.
</p>

<p class="note">注記：
これが ~T に設定されるのは、
`~top-level辿可能$用に限られる。
◎
This is only ever set to true for top-level traversable navigables.
</p>
	</li>
	<li>
<p>
`~load~event遅延-中か@nav
⇒
真偽値
— 初期~時は ~F とする。
◎
An is delaying load events boolean, initially false.
</p>

<p class="note">注記：
これが ~T に設定されるのは、［
当の~navigableの`親$nav ~NEQ ~NULL
］の事例に限られる。
◎
This is only ever set to true in cases where the navigable's parent is non-null.
</p>
	</li>
</ul>

<p>
`現在の~session履歴~entry$navと`作動中な~entry$navは、
通例的には同じになるが，次に挙げるときには同期cしない：
◎
The current session history entry and the active session history entry are usually the same, but they get out of sync when:
</p>
<ul>
	<li>
同期的な~naviが遂行されたとき。
この場合、
`作動中な~entry$navは，一時的に`現在の~session履歴~entry$navより一歩先へ進む。
◎
Synchronous navigations are performed. This causes the active session history entry to temporarily step ahead of the current session history entry.
</li>
	<li>
`履歴~stepを適用する$ときに表示-可能でも~errorでもない応答を受信したとき。
この場合、
`現在の~session履歴~entry$navは更新されるが，
`作動中な~entry$navは そのままになる。
◎
A non-displayable, non-error response is received when applying the history step. This updates the current session history entry but leaves the active session history entry as-is.
</li>
</ul>

<hr>

<p>
所与の`~navigable$ %~navigable 用には、
次に挙げるものも定義される：
</p>
<ul>
	<li>
<p>
`作動中な文書@nav
⇒
%~navigable にて`作動中な~entry$navの`文書$shEを指す。
◎
A navigable's active document is its active session history entry's document.
</p>

<p class="note">注記：
これは、
当の~navigableの`~top-level辿可能$navの`~session履歴~辿り~queue$navの中から安全に読取れる。
`~navigable$にて`作動中な~entry$navは，同期的に変更され得るが、
当の新たな~entryは，常に同じ`文書$を有することになる。
◎
This can be safely read from within the session history traversal queue of the navigable's top-level traversable. Although a navigable's active history entry can change synchronously, the new entry will always have the same Document.
</p>
	</li>
	<li>
<p>
`作動中な閲覧~文脈@nav
⇒
%~navigable にて`作動中な文書$navが`属する閲覧~文脈$を指す。
%~navigable が`辿可能な~navigable$である場合、
`作動中な閲覧~文脈$navは，`~top-level閲覧~文脈$になる。
◎
A navigable's active browsing context is its active document's browsing context. If this navigable is a traversable navigable, then its active browsing context will be a top-level browsing context.
</li>
	<li>
`作動中な~WindowProxy@nav
⇒
%~navigable にて`作動中な閲覧~文脈$navに結付けられた `WindowProxy$I を指す。
◎
A navigable's active WindowProxy is its active browsing context's associated WindowProxy.
</li>
	<li>
<p>
`作動中な~window@nav
⇒
%~navigable にて`作動中な~WindowProxy$navの `Window$sl を指す。
◎
A navigable's active window is its active WindowProxy's [[Window]].
</p>

<p class="note">注記：
これは、
常に，当の~navigableにて`作動中な文書$navに`関連な大域~obj$に等しくなる
— この同期cは、
`文書を作動中にする$~algoにより保たれる。
◎
This will always equal the navigable's active document's relevant global object; this is kept in sync by the make active algorithm.
</p>
</li>
	<li>
`~target名@nav
⇒
%~navigable にて`作動中な~entry$navの`文書~状態$shEの`~navigable名$dSを指す。
◎
A navigable's target name is its active session history entry's document state's navigable target name.
</li>
</ul>

<hr>

<p class="algo">
`~node$ %~node の
`~node~navigable@
は、
`~navigable$のうち［
その`作動中な文書$nav ~EQ %~node の`~node文書$
］を満たすものは［
在るならば それ ／
無いならば ~NULL
］を返す。
◎
To get the node navigable of a node node, return the navigable whose active document is node's node document, or null if there is no such navigable.
</p>

<p class="trans-note">【
該当するものは、
在っても一つに限られる。
】</p>

<hr>

<div class="algo">
<p>
`~navigableを初期化する@
~algoは、
所与の
( `~navigable$ %~navigable, `文書~状態$ %文書~状態, ［
`~navigable$／~NULL
］ %親（省略時は ~NULL ） )
に対し：
◎
To initialize the navigable navigable navigable, given a document state documentState and an optional navigable-or-null parent (default null):
</p>
<ol>
	<li>
~Assert：
%文書~状態 の`文書$dS ~NEQ ~NULL
◎
Assert: documentState's document is non-null.
</li>
	<li>
<p>
%~entry ~LET 新たな`~session履歴~entry$
— その
⇒＃
`~URL$shE ~SET %文書~状態 の`文書$dSの`~URL$doc,
`文書~状態$shE ~SET %文書~状態
◎
Let entry be a new session history entry, with
◎
URL
• documentState's document's URL
document state
• documentState
</p>

<p class="note">注記：
この~algoの~call元は、
%~entry の`~step$shEを初期化する責務がある
— それが完了するまで、
`~step$shEは `pending^l のまま残される。
◎
The caller of this algorithm is responsible for initializing entry's step; it will be left as "pending" until that is complete.
</p>
	</li>
	<li>
%~navigable の`現在の~session履歴~entry$nav ~SET %~entry
◎
Set navigable's current session history entry to entry.
</li>
	<li>
%~navigable にて`作動中な~entry$nav ~SET %~entry
◎
Set navigable's active session history entry to entry.
</li>
	<li>
%~navigable の`親$nav ~SET %親
◎
Set navigable's parent to parent.
</li>
</ol>
</div>


				<section id="traversable-navigables">
<h5 title="Traversable navigables">7.3.1.1. 辿可能な~navigable</h5>

<p>
`辿可能な~navigable@
（ `traversable navigable^en ）は、
`~navigable$であって，［
自身, および子孫の`~navigable$
］用に どの`~session履歴~entry$を［
`現在の~session履歴~entry$nav, `作動中な~entry$nav
］にするべきかも制御するものである。
◎
A traversable navigable is a navigable that also controls which session history entry should be the current session history entry and active session history entry for itself and its descendant navigables.
</p>

<p>
各 `辿可能な~navigable$は、
`~navigable$の~propに加えて，次に挙げるものも有する：
◎
In addition to the properties of a navigable, a traversable navigable has:
</p>
<ul>
	<li>
`現在の~session履歴~step@nav
⇒
整数【！number】
— 初期~時は 0 とする。
◎
A current session history step, a number, initially 0.
</li>
	<li>
`~session履歴~entry群@nav
⇒
一連の`~session履歴~entry$からなる`~list$
— 初期~時は新たな`~list$とする。
◎
Session history entries, a list of session history entries, initially a new list.
</li>
	<li>
`~session履歴~辿り~queue@nav
⇒
次の結果を成す`~session履歴~辿り並列~queue$
⇒
`新たな~session履歴~辿り並列~queueを開始する$()
◎
A session history traversal queue, a session history traversal parallel queue, the result of starting a new session history traversal parallel queue.
</li>
	<li>
`入子な履歴~stepの適用-を走らせているか@nav
⇒
真偽値
— 初期~時は ~F とする。
◎
A running nested apply history step boolean, initially false.
</li>
	<li>
<p>
`~system可視性~状態@nav
⇒
次のいずれか
⇒＃
`hidden^l ／
`visible^l
◎
A system visibility state, which is either "hidden" or "visible".
</p>

<p>
この~itemに関する要件は、
`§ ~page可視性＠~HTMLinteraction#page-visibility$を見よ。
◎
See the page visibility section for the requirements on this item.
</p>
	</li>
	<li>
`~web内容により作成されたか@nav
⇒
真偽値
— 初期~時は ~F とする。
◎
An is created by web content boolean, initially false.
</li>

</ul>

<div class="algo">
<p>
`~navigable$ %入力~navigable の
`辿可能な~navigable@nav
は、
次を走らせた結果になる：
◎
To get the traversable navigable of a navigable inputNavigable:
</p>
<ol>
	<li>
%~navigable ~LET %入力~navigable
◎
Let navigable be inputNavigable.
</li>
	<li>
~WHILE［
%~navigable は`辿可能な~navigable$でない
］
⇒
%~navigable ~SET %~navigable の`親$nav
◎
While navigable is not a traversable navigable, set navigable to navigable's parent.
</li>
	<li>
~RET %~navigable
◎
Return navigable.
</li>
</ol>
</div>

				</section>
				<section id="top-level-traversables">
<h5 title="Top-level traversables">7.3.1.2. ~top-level辿可能</h5>

<p>
`~top-level辿可能@
（ `top-level traversable^en ）
は、
`辿可能な~navigable$のうち，次を満たすものをいう
⇒
その`親$nav ~EQ ~NULL
◎
A top-level traversable is a traversable navigable with a null parent.
</p>

<p class="note">注記：
現時点では、
すべての`辿可能な~navigable$は，`~top-level辿可能$である。
将来の提案は、
そうでない辿可能を導入するものと~~想定されている。
◎
Currently, all traversable navigables are top-level traversables. Future proposals envision introducing non-top-level traversables.
</p>

<p>
~UAは、
`~top-level辿可能~集合@
を保持する
— それは、
何個かの`~top-level辿可能$からなる`集合$である。
これらは、
概して，~browser［
~UIwindow／~UItab
］の形で利用者に呈示される。
◎
A user agent holds a top-level traversable set (a set of top-level traversables). These are typically presented to the user in the form of browser windows or browser tabs.
</p>

<div class="algo">
<p>
`~navigable$ %入力~navigable の
`~top-level辿可能@nav
は、
次を走らせた結果になる：
◎
To get the top-level traversable of a navigable inputNavigable:
</p>
<ol>
	<li>
%~navigable ~LET %入力~navigable
◎
Let navigable be inputNavigable.
</li>
	<li>
~WHILE［
%~navigable の`親$nav ~NEQ ~NULL
］
⇒
%~navigable ~SET %~navigable の`親$nav
◎
While navigable's parent is not null, set navigable to navigable's parent.
</li>
	<li>
~RET %~navigable
◎
Return navigable.
</li>
</ol>
</div>

<div class="algo">
<p>
`新たな~top-level辿可能を作成する@
~algoは、
所与の
⇒＃
［`閲覧~文脈$／~NULL ］ %~opener,
文字列 %~target名,
`~navigable$ %~WebDriver用の~opener~navigable（省略時は ε ）
◎終
に対し：
◎
To create a new top-level traversable given a browsing context-or-null opener, a string targetName, and an optional navigable openerNavigableForWebDriver:
</p>
<ol>
	<li>
%文書 ~LET ~NULL
◎
Let document be null.
</li>
	<li>
~IF［
%~opener ~EQ ~NULL
］
⇒
( —, %文書 ) ~SET `新たな~top-level閲覧~文脈と文書を作成する$()
◎
If opener is null, then set document to the second return value of creating a new top-level browsing context and document.
</li>
	<li>
~ELSE
⇒
( —, %文書 ) ~SET `新たな補助~閲覧~文脈と文書を作成する$( %~opener )
◎
Otherwise, set document to the second return value of creating a new auxiliary browsing context and document given opener.
</li>
	<li>
%文書~状態 ~LET 新たな`文書~状態$
— その
⇒＃
`文書$dS ~SET %文書,
`起動元~生成元$dS ~SET %文書 の`生成元$doc,
`生成元$dS ~SET %文書 の`生成元$doc,
`~navigable名$dS ~SET %~target名,
`~about基底~URL$dS ~SET %文書 の`~about基底~URL$doc
◎
Let documentState be a new document state, with
◎
document
• document
initiator origin
• null if opener is null; otherwise, document's origin
origin
• document's origin
navigable target name
• targetName
about base URL
• document's about base URL
</li>
	<li>
~IF［
%~opener ~EQ ~NULL
］
⇒
%文書~状態 の`起動元~生成元$dS ~SET ~NULL
◎
↑</li>
	<li>
%辿可能 ~LET 新たな`辿可能な~navigable$
◎
Let traversable be a new traversable navigable.
</li>
	<li>
`~navigableを初期化する$( %辿可能, %文書~状態 )
◎
Initialize the navigable traversable given documentState.
</li>
	<li>
%初期~履歴~entry ~LET %辿可能 にて`作動中な~entry$nav
◎
Let initialHistoryEntry be traversable's active session history entry.
</li>
	<li>
%初期~履歴~entry の`~step$shE ~SET 0
◎
Set initialHistoryEntry's step to 0.
</li>
	<li>
%辿可能 の`~session履歴~entry群$navに %初期~履歴~entry を`付加する$
◎
Append initialHistoryEntry to traversable's session history entries.
</li>
	<li id="copy-session-storage">
~IF［
%~opener ~NEQ ~NULL
］
⇒
`辿可能~storage倉を旧来~cloneする$( %~opener の`~top-level辿可能$bc, %辿可能 )
`STORAGE$r
◎
If opener is non-null, then legacy-clone a traversable storage shed given opener's top-level traversable and traversable. [STORAGE]
</li>
	<li>
~UAの`~top-level辿可能~集合$に %辿可能 を`付加する$set【！`付加する$】
◎
Append traversable to the user agent's top-level traversable set.
</li>
	<li>
`~WebDriver-BiDi~navigableが作成された$( %辿可能, %~WebDriver用の~opener~navigable )
◎
Invoke WebDriver BiDi navigable created with traversable and openerNavigableForWebDriver.
</li>
	<li>
~RET %辿可能
◎
Return traversable.
</li>
</ol>
</div>

<div class="algo">
<p>
`新鮮な~top-level辿可能を作成する@
~algoは、
所与の
( `~URL$ %初期~navi~URL, ［
`~POST資源$／~NULL
］ %初期~navi~POST資源（省略時は ~NULL ） )
に対し：
◎
To create a fresh top-level traversable given a URL initialNavigationURL and an optional POST resource-or-null initialNavigationPostResource (default null):
</p>
<ol>
	<li>
%辿可能 ~LET `新たな~top-level辿可能を作成する$( ~NULL, 空~文字列 )
◎
Let traversable be the result of creating a new top-level traversable given null and the empty string.
</li>
	<li>
<p>
`~navigableを~URLへ~navigateする$( %辿可能, %初期~navi~URL, %辿可能 にて`作動中な文書$nav )
— 次も与える下で
⇒＃
`文書~資源^i ~SET %初期~navi~POST資源
◎
Navigate traversable to initialNavigationURL using traversable's active document, with documentResource set to initialNavigationPostResource.
</p>

<p class="note">注記：
これらの初期~naviは、
自身を~navigateしている %辿可能 として扱われる
— それは、［
関連な~security検査~すべてに合格することを確保する
］ことになる。
◎
We treat these initial navigations as traversable navigating itself, which will ensure all relevant security checks pass.
</p>
	</li>
	<li>
~RET %辿可能
◎
Return traversable.
</li>
</ol>
</div>

				</section>
				<section id="child-navigables">
<h5 title="Child navigables">7.3.1.3. 子~navigable</h5>

<p>
ある種の要素（例えば `iframe$e 要素）は、
利用者に`~navigable$を呈示し得る。
これらの要素は、
`~navigable容器@
（ `navigable container^en ）と呼ばれる。
◎
Certain elements (for example, iframe elements) can present a navigable to the user. These elements are called navigable containers.
</p>

<p>
各`~navigable容器$は、
`内容~navigable@
を有する
— それは、［
`~navigable$／~NULL
］であり，
初期~時は ~NULL とする。
【当の容器の中に入子にされた~navigable。】
◎
Each navigable container has a content navigable, which is either a navigable or null. It is initially null.
</p>

<div class="algo">
<p>
`~navigable$ %~navigable の
`容器@nav
は、
`~navigable容器$のうち［
その`内容~navigable$ ~EQ  %~navigable
］を満たす要素は［
在るならば それ ／
無いならば ~NULL
］を返す。
◎
The container of a navigable navigable is the navigable container whose content navigable is navigable, or null if there is no such element.
</p>

<p class="trans-note">【
該当するものは、
在っても一つに限られる。
】</p>
</div>

<div class="algo">
<p>
`~navigable$ %~navigable の
`容器~文書@nav
は、
次を走らせた結果になる：
◎
The container document of a navigable navigable is the result of running these steps:
</p>
<ol>
	<li>
%容器 ~LET %~navigable の`容器$nav
◎
↓</li>
	<li>
~IF［
%容器 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If navigable's container is null, then return null.
</li>
	<li>
<p>
~RET %容器 の`~node文書$
◎
Return navigable's container's node document.
</p>

<p class="note">注記：
【この段に達したなら】
%容器 は`接続されて$いるはずなので、
これは， %容器 の`~shadowも含めた根$に等しくなる。
◎
This is equal to navigable's container's shadow-including root as navigable's container has to be connected.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`文書$ %文書 の
`容器~文書@doc
は、
次を走らせた結果になる：
◎
The container document of a Document document is the result of running these steps:
</p>
<ol>
	<li>
~IF［
%文書 の`~node~navigable$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If document's node navigable is null, then return null.
</li>
	<li>
~RET %文書 の`~node~navigable$の`容器~文書$nav
◎
Return document's node navigable's container document.
</li>
</ol>
</div>

<p>
所与の異なる`~navigable$ %A, %B に対し，
%A は %B の
`子~navigable@
であるとは、［
%A の`親$nav ~EQ %B
］を満たすことをいう。
このことを単に，
`~navigable$ %A は “`子~navigable$である” ともいう
— それは、［
%A の`親$nav ~NEQ ~NULL
］を意味する。
◎
A navigable navigable is a child navigable of another navigable potentialParent when navigable's parent is potentialParent. We can also just say that a navigable "is a child navigable", which means that its parent is non-null.
</p>

<p class="note">注記：
すべての`子~navigable$は、
各自の`容器$navの`内容~navigable$になる。
◎
All child navigables are the content navigable of their container.
</p>

<div class="algo">
<p>
`~navigable容器$ %容器 の
`内容~文書@
は、
次を走らせた結果になる：
◎
The content document of a navigable container container is the result of running these steps:
</p>
<ol>
	<li>
~IF［
%容器 の`内容~navigable$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If container's content navigable is null, then return null.
</li>
	<li>
%文書 ~LET %容器 の`内容~navigable$にて`作動中な文書$nav
◎
Let document be container's content navigable's active document.
</li>
	<li>
~IF［
( %文書 の`生成元$doc, %容器 の`~node文書$の`生成元$doc )
は`同じ生成元~domain$でない
］
⇒
~RET ~NULL
◎
If document's origin and container's node document's origin are not same origin-domain, then return null.
</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navigable容器$ %容器 の
`内容~window@
は、
次を走らせた結果になる：
◎
The content window of a navigable container container is the result of running these steps:
</p>
<ol>
	<li>
~IF［
%容器 の`内容~navigable$ ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If container's content navigable is null, then return null.
</li>
	<li>
~RET %容器 の`内容~navigable$にて`作動中な~WindowProxy$nav
◎
Return container's content navigable's active WindowProxy's object.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`新たな子~navigableを作成する@
~algoは、
所与の
( 要素 %要素 )
に対し：
◎
To create a new child navigable, given an element element:
</p>
<ol>
	<li>
%親~navigable ~LET %要素 の`~node~navigable$
◎
Let parentNavigable be element's node navigable.
</li>
	<li>
%~group ~LET %要素 の`~node文書$が`属する閲覧~文脈$の`~top-level閲覧~文脈$bcの`~group$tbcG
◎
Let group be element's node document's browsing context's top-level browsing context's group.
</li>
	<li>
( %閲覧~文脈, %文書 ) ~LET `新たな閲覧~文脈と文書を作成する$( %要素 の`~node文書$, %要素, %~group )
◎
Let browsingContext and document be the result of creating a new browsing context and document given element's node document, element, and group.
</li>
	<li>
%~target名 ~LET %要素 は `name^a 内容~属性を［
有するならば その属性の値 ／
有さないならば ~NULL
］
◎
Let targetName be null.
◎
If element has a name content attribute, then set targetName to the value of that attribute.
</li>
	<li>
%文書~状態 ~LET 新たな`文書~状態$
— その
⇒＃
`文書$dS ~SET %文書,
`起動元~生成元$dS ~SET %文書 の`生成元$doc,
`生成元$dS ~SET %文書 の`生成元$doc,
`~navigable名$dS ~SET %~target名,
`~about基底~URL$dS ~SET %文書 の`~about基底~URL$doc
◎
Let documentState be a new document state, with
◎
document
• document
initiator origin
• document's origin
origin
• document's origin
navigable target name
• targetName
about base URL
• document's about base URL
</li>
	<li>
%~navigable ~LET 新たな`~navigable$
◎
Let navigable be a new navigable.
</li>
	<li>
`~navigableを初期化する$( %~navigable, %文書~状態, %親~navigable )
◎
Initialize the navigable navigable given documentState and parentNavigable.
</li>
	<li>
%要素 の`内容~navigable$ ~SET %~navigable
◎
Set element's content navigable to navigable.
</li>
	<li>
%履歴~entry ~LET %~navigable にて`作動中な~entry$nav
◎
Let historyEntry be navigable's active session history entry.
</li>
	<li>
%辿可能 ~LET %親~navigable の`辿可能な~navigable$nav
◎
Let traversable be parentNavigable's traversable navigable.
</li>
	<li>
<p>
`~session履歴~辿り手続きを付加する$( %辿可能, 次の手続き )
◎
Append the following session history traversal steps to traversable:
</p>
<div class="algo">
<p>
手続きは：
◎
↑</p>
		<ol>
			<li>
%親~文書~状態 ~LET %親~navigable にて`作動中な~entry$navの`文書~状態$shE
◎
Let parentDocState be parentNavigable's active session history entry's document state.
</li>
			<li>
%親~navigable~entry群 ~LET `~session履歴~entry群を取得する$( %親~navigable )
◎
Let parentNavigableEntries be the result of getting session history entries for parentNavigable.
</li>
			<li>
%~target~step履歴~entry ~LET ［
%親~navigable~entry群 を成す`~session履歴~entry$
］のうち次を満たす最初のもの
⇒
その`文書~状態$shE ~EQ %親~文書~状態
◎
Let targetStepSHE be the first session history entry in parentNavigableEntries whose document state equals parentDocState.
</li>
			<li>
%履歴~entry の`~step$shE ~SET %~target~step履歴~entry の`~step$shE
◎
Set historyEntry's step to targetStepSHE's step.
</li>
			<li>
%入子な履歴 ~LET 新たな`入子な履歴$
— その
⇒＃
`~ID$nH ~SET %~navigable の`~ID$nav
`~entry群$nH ~SET « %履歴~entry »
◎
Let nestedHistory be a new nested history whose id is navigable's id and entries list is « historyEntry ».
</li>
			<li>
%親~文書~状態 の`入子な履歴~群$dSに %入子な履歴 を`付加する$
◎
Append nestedHistory to parentDocState's nested histories.
</li>
			<li>
`~navigableの作成／破壊~用に更新する$( %辿可能 )
◎
Update for navigable creation/destruction given traversable.
</li>
		</ol>
</div>
	</li>
	<li>
`~WebDriver-BiDi~navigableが作成された$( %辿可能 )
◎
Invoke WebDriver BiDi navigable created with traversable.
</li>
</ol>
</div>

				</section>
				<section id="jake-diagrams">
<h5 title="Jake diagrams">7.3.1.4. ~Jake図式</h5>

<p>
`~Jake図式@
（ `Jake diagram^en ）は、
文書~連列
— 特に`~navigable$とそれらの`~session履歴~entry$ —
を可視化するための有用な~methodである。
典型的な~Jake図式は、
次のようになる：
◎
A useful method for visualizing sequences of documents, and in particular navigables and their session history entries, is the Jake diagram. A typical Jake diagram is the following:
</p>

<table class="jake-diagram"><thead>
<tr><td>
<th class="step">0
<th class="step current">1
<th class="step">2
<th class="step">3
<th class="step">4
<tbody>

<tr><th>`top^c
<td colspan="3" class="doc-0 current next-is-same-doc">`/t-a^c
<td colspan="1" class="doc-0 prev-is-same-doc">`/t-a#foo^c
<td colspan="1" class="doc-1">`/t-b^c

<tr><th>`frames[0]^c
<td colspan="1" class="doc-2">`/i-0-a^c
<td colspan="3" class="doc-3 current">`/i-0-b^c

<tr><th>`frames[1]^c
<td colspan="2" class="doc-4 current">`/i-1-a^c
<td colspan="2" class="doc-5">`/i-1-b^c
</table>

<div>
<p>
ここでは：
</p>
<ul>
	<li>
各~colの番号（~~上端）は、
当の辿可能の`現在の~session履歴~step$nav用にアリな値を表す。
</li>
	<li>
各~rowは、
先頭の~labelが表す`~navigable$が異なる［
~URL／文書
］間で遷移する様子を図画化する。
</li>
	<li>
最初の~row `top^c は，`~top-level辿可能$であり、
他の~rowは，`子~navigable$である。
</li>
	<li>
各~文書は、
各~cellの背景~色により区別される
— ある~rowにおける新たな背景~色は、
その~rowの`~navigable$における新たな文書を指示する。
</li>
	<li>
各~URLは、
各~cellの~text内容に与えられる。
簡潔にするため、
通例的に
— 非同一-生成元の事例を特定的に究明している場合を除いて —
`相対~URL＠~URL1#relative-url-string$【！~URL1#syntax-url-relative】として与えられる。
</li>
	<li>
所与の~navigableは、
所与の~stepの時点では存在しないかもしれない
— その事例では、
対応する~cellは空になる。
</li>
	<li>
太字斜字体な~step番号は、
当の辿可能の`現在の~session履歴~step$navを図画化する。
</li>
	<li>
太字斜字体な~URLを伴うすべての~cellは、
それが属する~rowの~navigableの`現在の~session履歴~entry$navを表現する。
</li>
</ul>
◎
Here,＼
each numbered column denotes a possible value for the traversable's session history step.＼
Each labeled row depicts a navigable, as it transitions between different URLs and documents.＼
The first, labeled top, being the top-level traversable, and the others being child navigables.＼
The documents are given by the background color of each cell, with a new background color indicating a new document in that navigable.＼
The URLs are given by the text content of the cells; usually they are given as relative URLs for brevity, unless a cross-origin case is specifically under investigation.＼
A given navigable might not exist at a given step, in which case the corresponding cells are empty.＼
The bold-italic step number depicts the current session history step of the traversable,＼
and all cells with bold-italic URLs represent the current session history entry for that row's navigable.
</div>

<p>
したがって、
上の~Jake図式は，次に挙げる~event連列を図画化する：
◎
Thus, the above Jake diagram depicts the following sequence of events:
</p>
<ol start="0">
	<li>
~URL `/t-a^c から開始している`~top-level辿可能$ %T が作成され、
順に［
`/i-0-a^c, `/i-1-a^c
］から開始している 2 個の`子~navigable$を伴う。
◎
A top-level traversable is created, starting a the URL /t-a, with two child navigables starting at /i-0-a and /i-1-a respectively.
</li>
	<li>
1 個目の子~navigableが別の文書
— ~URL `/i-0-b^c —
へ`~navigate$される。
◎
The first child navigable is navigated to another document, with URL /i-0-b.
</li>
	<li>
2 個目の子~navigableが
別の文書
— ~URL `/i-1-b^c —
へ`~navigate$される。
◎
The second child navigable is navigated to another document, with URL /i-1-b.
</li>
	<li>
%T は、
`同じ文書^emへ`~navigate$され，
~URLは `/t-a#foo^c に更新される。
◎
The top-level traversable is navigated to the same document, updating its URL to /t-a#foo.
</li>
	<li>
%T は、
別の文書
— ~URL `/t-b^c —
へ`~navigate$される。
（この文書が旧-文書の子~navigableを（もちろん）引き継がない様子に注意。）
◎
The top-level traversable is navigated to another document, with URL /t-b. (Notice how this document, of course, does not carry over the old document's child navigables.)
</li>
	<li>
%T は、
~step 1 へ戻るよう，
`履歴を差分 −3 だけ辿る＠~HTMLnav#traverse-the-history-by-a-delta$。
◎
The traversable was traversed by a delta of −3, back to step 1.
</li>
</ol>

<p>
`~Jake図式$は
複数の［
~navigable, ~navi, 辿り
］どうしの相互作用を可視化するための強力な~toolを与えるが、
アリなあらゆる相互作用は捕捉できない
— 例えば、
入子ng~levelは 1 階までしか働かない。
が、
この標準を全体を通して，複階的な状況を~~説明するために利用される。
◎
Jake diagrams are a powerful tool for visualizing the interactions of multiple navigables, navigations, and traversals. They cannot capture every possible interaction — for example, they only work with a single level of nesting — but we will have ocassion to use them to illustrate several complex situations throughout this standard.
</p>

<p class="note">注記：
`~Jake図式$は、
その作成者 “比類なき” `Jake Archibald^en 氏から名前を継ぐ。
◎
Jake diagrams are named after their creator, the inimitable Jake Archibald.
</p>

				</section>
				<section id="related-navigable-collections">
<h5 title="Related navigable collections">7.3.1.5. 関係する~navigable~collection</h5>

<p>
この標準の~algoにおいては、［
所与の`文書$から開始して，`~navigable$の~collectionを調べる
］ようにすると，好都合になることが多い。
この節では、
それら~navigableを収集するためとして~~用意された，一群の~algoを与える。
◎
It is often helpful in this standard's algorithms to look at collections of navigables starting at a given Document. This section contains a curated set of algorithms for collecting those navigables.
</p>

<p class="note">注記：
これらの~algoが返す値は、
親が子より前に現れるよう順序付けられる。
~call元は、
この順序付けに依拠する。
◎
The return values of these algorithms are ordered so that parents appears before their children. Callers rely on this ordering.
</p>

<p class="note">注記：
一般に，
`~navigable$ではなく`文書$から開始した方が良くなるのは、
そうした方が，
~call元にとって`全部的に作動中$な`文書$から開始しているかどうかが判るからである。
`全部的に作動中$でない`文書$にも［
先祖／子孫
］~navigableは在るが、
それらは，そうでなかったかのように挙動することが多い
（例： `window.parent＠~WINDOW#dom-window-parent$c 取得子において）。
◎
Starting with a Document, rather than a navigable, is generally better because it makes the caller cognizant of whether they are starting with a fully active Document or not. Although non-fully active Documents do have ancestor and descendant navigables, they often behave as if they don't (e.g., in the window.parent getter).
</p>

<div class="algo">
<p>
`文書$ %文書 の
`先祖~navigable群@
は、
次を走らせた結果になる：
◎
The ancestor navigables of a Document document are given by these steps:
</p>
<ol>
	<li>
%~navigable ~LET %文書 の`~node~navigable$の`親$nav
◎
Let navigable be document's node navigable's parent.
</li>
	<li>
%先祖~群 ~LET 新たな`~list$
◎
Let ancestors be an empty list.
</li>
	<li>
<p>
~WHILE［
%~navigable ~NEQ ~NULL
］：
◎
While navigable is not null:
</p>
		<ol>
			<li>
%先祖~群 に %~navigable を`前付加する$
◎
Prepend navigable to ancestors.
</li>
			<li>
%~navigable ~SET %~navigable の`親$nav
◎
Set navigable to navigable's parent.
</li>
		</ol>
	</li>
	<li>
~RET %先祖~群
◎
Return ancestors.
</li>
</ol>
</div>

<div class="algo">
<p>
`文書$ %文書 の
`広義-先祖~navigable群@
は、
次を走らせた結果になる：
◎
The inclusive ancestor navigables of a Document document are given by these steps:
</p>
<ol>
	<li>
%~navigable群 ~LET %文書 の`先祖~navigable群$
◎
Let navigables be document's ancestor navigables.
</li>
	<li>
%~navigable群 に %文書 の`~node~navigable$を`付加する$
◎
Append document's node navigable to navigables.
</li>
	<li>
~RET %~navigable群
◎
Return navigables.
</li>
</ol>
</div>

<div class="algo">
<p>
`文書$ %文書 の
`子孫~navigable群@
は、
次を走らせた結果になる：
◎
The descendant navigables of a Document document are given by these steps:
</p>
<ol>
	<li>
%~navigable群 ~LET 新たな`~list$
◎
Let navigables be new list.
</li>
	<li>
%~navigable容器~群 ~LET ［
%文書 の`~shadowも含めた子孫$のうち`~navigable容器$であるもの
］すべてからなる，`~shadowも含めた~tree順序$による`~list$
◎
Let navigableContainers be a list of all shadow-including descendants of document that are navigable containers, in shadow-including tree order.
</li>
	<li>
<p>
%~navigable容器~群 を成す
~EACH( %~navigable容器 )
に対し：
◎
For each navigableContainer of navigableContainers:
</p>
		<ol>
			<li>
~IF［
%~navigable容器 の`内容~navigable$ ~EQ ~NULL
］
⇒
~CONTINUE
◎
If navigableContainer's content navigable is null, then continue.
</li>
			<li>
%~navigable群 を次で`拡張する$
⇒
%~navigable容器 の`内容~navigable$にて`作動中な文書$navの`広義-子孫~navigable群$
◎
Extend navigables with navigableContainer's content navigable's active document's inclusive descendant navigables.
</li>
		</ol>
	</li>
	<li>
~RET %~navigable群
◎
Return navigables.
</li>
</ol>
</div>

<div class="algo">
<p>
`文書$ %文書 の
`広義-子孫~navigable群@
は、
次を走らせた結果になる：
◎
The inclusive descendant navigables of a Document document are given by these steps:
</p>
<ol>
	<li>
%~navigable群 ~LET « %文書 の`~node~navigable$ »
◎
Let navigables be « document's node navigable ».
</li>
	<li>
%~navigable群 を %文書 の`子孫~navigable群$で`拡張する$
◎
Extend navigables with document's descendant navigables.
</li>
	<li>
~RET %~navigable群
◎
Return navigables.
</li>
</ol>
</div>

<p class="note">注記：
これら子孫を収集している~algoは，
子孫`文書$を成す~DOM~treeを調べていくものとして述べられるが、
現実的には，実現可能でないことが多い
— ~DOM~treeは、
~algoの~call元とは別の~process内にあることもあるので。
一般に，実装は、
代わりに，~process間にまたがって適切な~treeを~~再現する。
◎
These descendant-collecting algorithms are described as looking at the DOM tree of descendant Document objects. In reality, this is often not feasible since the DOM tree can be in another process from the caller of the algorithm. Instead, implementations generally replicate the appropriate trees across processes.
</p>

<div class="algo">
<p>
`文書$ %文書 の
`文書~treeに属する子~navigable群@
は、
次を走らせた結果になる：
◎
The document-tree child navigables of a Document document are given by these steps:
</p>
<ol>
	<li>
%~navigable群 ~LET 新たな`~list$
◎
↓</li>
	<li>
~IF［
%文書 の`~node~navigable$ ~EQ ~NULL
］
⇒
~RET %~navigable群
◎
If document's node navigable is null, then return the empty list.
◎
Let navigables be new list.
</li>
	<li>
%~navigable容器~群 ~LET ［
%文書 の`子孫$のうち`~navigable容器$であるもの
］すべてからなる，`~tree順序$による`~list$
◎
Let navigableContainers be a list of all descendants of document that are navigable containers, in tree order.
</li>
	<li>
<p>
%~navigable容器~群 を成す
~EACH( %~navigable容器 )
に対し：
◎
For each navigableContainer of navigableContainers:
</p>
		<ol>
			<li>
~IF［
%~navigable容器 の`内容~navigable$ ~EQ ~NULL
］
⇒
~CONTINUE
◎
If navigableContainer's content navigable is null, then continue.
</li>
			<li>
%~navigable群 に %~navigable容器 の`内容~navigable$を`付加する$
◎
Append navigableContainer's content navigable to navigables.
</li>
		</ol>
	</li>
	<li>
~RET %~navigable群
◎
Return navigables.
</li>
</ol>
</div>

				</section>
				<section id="garbage-collection-and-browsing-contexts">
<h5 title="Navigable destruction">7.3.1.6. ~navigableの破壊</h5>

<div class="algo">
<p>
`子~navigableを破壊する@
~algoは、
所与の
( `~navigable容器$ %容器 )
に対し：
◎
To destroy a child navigable given a navigable container container:
</p>
<ol>
	<li>
%~navigable ~LET %容器 の`内容~navigable$
◎
Let navigable be container's content navigable.
</li>
	<li>
~IF［
%~navigable ~EQ ~NULL
］
⇒
~RET
◎
If navigable is null, then return.
</li>
	<li>
%容器 の`内容~navigable$ ~SET ~NULL
◎
Set container's content navigable to null.
</li>
	<li>
`子~navigableの破壊について~navi~APIに伝える$( %~navigable )
◎
Inform the navigation API about child navigable destruction given navigable.
</li>
	<li>
`文書とその子孫たちを破壊する$( %~navigable にて`作動中な文書$nav )
◎
Destroy a document and its descendants given navigable's active document.
</li>
	<li>
%親~文書~状態 ~LET %容器 の`~node~navigable$にて`作動中な~entry$navの`文書~状態$shE
◎
Let parentDocState be container's node navigable's active session history entry's document state.
</li>
	<li>
%親~文書~状態 の`入子な履歴~群$dSから，次を満たす`入子な履歴$を`除去する$
⇒
その`~ID$nH ~EQ %~navigable の`~ID$nav
◎
Remove the nested history from parentDocState's nested histories whose id equals navigable's id.
</li>
	<li>
%辿可能 ~LET %容器 の`~node~navigable$の`辿可能な~navigable$nav
◎
Let traversable be container's node navigable's traversable navigable.
</li>
	<li>
<p>
`~session履歴~辿り手続きを付加する$( %辿可能, 次の手続き )
◎
Append the following session history traversal steps to traversable:
</p>

<div class="algo">
手続きは
⇒
`~navigableの作成／破壊~用に更新する$( %辿可能 )
◎
Update for navigable creation/destruction given traversable.
</div>
	</li>
	<li>
`~WebDriver-BiDi~navigableが破壊された$( %~navigable )
◎
Invoke WebDriver BiDi navigable destroyed with navigable.
</li>
</ol>
</div>

<div class="algo">
<p>
`~top-level辿可能を破壊する@
~algoは、
所与の
( `~top-level辿可能$ %辿可能 )
に対し：
◎
To destroy a top-level traversable traversable:
</p>
<ol>
	<li>
%閲覧~文脈 ~LET %辿可能 にて`作動中な閲覧~文脈$nav
◎
Let browsingContext be traversable's active browsing context.
</li>
	<li>
<p>
%辿可能 の`~session履歴~entry群$navを成す
~EACH( %履歴~entry )
に対し
<span class="XXX">順序はどうする？</span>
：
◎
For each historyEntry in traversable's session history entries in what order?:
</p>
		<ol>
			<li>
%文書 ~LET %履歴~entry の`文書$shE
◎
Let document be historyEntry's document.
</li>
			<li>
~IF［
%文書 ~NEQ ~NULL
］
⇒
`文書とその子孫たちを破壊する$( %文書 )
◎
If document is not null, then destroy a document and its descendants given document.
</li>
		</ol>
	</li>
	<li>
`閲覧~文脈~groupから除去する$( %閲覧~文脈 )
◎
Remove browsingContext.
</li>
	<li>
~UIから %辿可能 を除去する
（例：~UItab化~browserにおいて、
~UItabを閉じるか隠す）。
◎
Remove traversable from the user interface (e.g., close or hide its tab in a tabbed browser).
</li>
	<li>
~UAの`~top-level辿可能~集合$から %辿可能 を`除去する$
◎
Remove traversable from the user agent's top-level traversable set.
</li>
	<li>
`~WebDriver-BiDi~navigableが破壊された$( %辿可能 )
◎
Invoke WebDriver BiDi navigable destroyed with traversable.
</li>
</ol>
</div>

<p>
~UAは、
いつでも，`~top-level辿可能を破壊-＠#destroy-a-top-level-traversable$してもヨイ
（概して、
`利用者からの要請に呼応して＠~HTMLlifecycle#nav-traversal-ui$）。
◎
User agents may destroy a top-level traversable at any time (typically, in response to user requests).
</p>

<div class="algo">
<p>
`~top-level辿可能を閉じる@
~algoは、
所与の
( %辿可能 )
に対し：
◎
To close a top-level traversable traversable:
</p>
<ol>
	<li>
~IF［
%辿可能 の`閉中か$nav ~EQ ~T
］
⇒
~RET
◎
If traversable's is closing is true, then return.
</li>
	<li>
`~top-level辿可能を確定的に閉じる$( %辿可能 )
◎
Definitely close traversable.
</li>
</ol>
</div>

<div class="algo">
<p>
`~top-level辿可能を確定的に閉じる@
~algoは、
所与の
( `~top-level辿可能$ %辿可能 )
に対し：
◎
To definitely close a top-level traversable traversable:
</p>
<ol>
	<li>
%~unload対象 ~LET  %辿可能 にて`作動中な文書$navの`広義-子孫~navigable群$
◎
Let toUnload be traversable's active document's inclusive descendant navigables.
</li>
	<li>
~IF［
`~unloadは取消されたか否か検査する$( %~unload対象 ) ~EQ ~T
］
⇒
~RET
◎
If the result of checking if unloading is canceled for toUnload is true, then return.
</li>
	<li>
<p>
`~session履歴~辿り手続きを付加する$( %辿可能, 次の手続き )
◎
Append the following session history traversal steps to traversable:
</p>

<div class="algo">
<p>
手続きは
⇒
`文書とその子孫たちを~unloadする$( %辿可能 にて`作動中な文書$nav, ~NULL, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~top-level辿可能を破壊する$( %辿可能 )
</div>
◎
• Let afterAllUnloads be an algorithm step which destroys traversable.
• Unload a document and its descendants given traversable's active document, null, and afterAllUnloads.
</div>
	</li>
</ol>
</div>

<p class="note">注記：
［
`~top-level辿可能を閉じる$,
`~top-level辿可能を確定的に閉じる$
］を別々にしたのは、［
次のために前者を~callする
］ことを他の仕様に次を許容するためである
⇒
~JS~codeが `window.close()＠~WINDOW#dom-window-close$c を~callしたことに因り，
当の~top-level辿可能はすでに閉中にある場合には、
何もさせないようにする。
◎
The close vs. definitely close separation allows other specifications to call close and have it be a no-op if the top-level traversable is already closing due to JavaScript code calling window.close().
</p>

				</section>
				<section id="navigable-target-names">
<h5 title="Navigable target names">7.3.1.7. ~navigable~target名</h5>

<p>
各`~navigable$には、
`~target名$navが与えられ得る。
それは、
文字列であり，ある種の~API
（ `window.open()＠~WINDOW#dom-window-open$c や `a$e 要素の `target$a 属性など）
が当の~navigableを`~navi~algo$の~targetにすることを許容する。
◎
Navigables can be given target names, which are strings allowing certain APIs (such as window.open() or the a element's target attribute) to target navigations at that navigable.
</p>

<p>
`妥当な~navigable~target名@
とは、
~AND↓ を満たす文字列である：
◎
A valid navigable target name is any string＼
</p>
<ul>
	<li>
空でない
◎
with at least one character＼
</li>
	<li>
`~ASCII~tabや~ASCII改行文字$を包含しない
◎
that does not contain both an ASCII tab or newline＼
</li>
	<li>
`003C^U `&lt;^smb を包含しない
◎
and a U+003C (&lt;),＼
</li>
	<li>
<p>
最初の文字 ~NEQ `005F^U `_^smb
◎
and it does not start with a U+005F (_).＼
</p>

<p>
（ `005F^U から開始する名前は、
次に述べる特別な~keyword用に予約される。）
◎
(Names starting with a U+005F (_) are reserved for special keywords.)
</p>
	</li>
</ul>

<p>
`妥当な~navigable~target名または~keyword@
とは、
~OR↓ を満たす文字列である：
◎
A valid navigable target name or keyword is any string that is either＼
</p>
<ul>
	<li>
`妥当な~navigable~target名$である
◎
a valid navigable target name or＼
</li>
	<li>
次に挙げるいずれかの~keywordに`~ASCII大小無視$で合致する
⇒＃
`_blank^l,
`_self^l,
`_parent^l,
`_top^l
◎
that is an ASCII case-insensitive match for one of: _blank, _self, _parent, or _top.
</li>
</ul>

<p>
~pageの “~link等”
（ ~link, ~script, ~form提出, 等々）
が指定する，`妥当な~navigable~target名または~keyword$による値
— 以下，単に %名前 と記す —
は、
~pageが~sandbox化されたか否かに応じて，
下の規範的でない “~target~navigable表t” の 3 列目以降に要約され、
その意味は，各~列に応じて異なる
— この表tの：
◎
These values have different meanings based on whether the page is sandboxed or not, as summarized in the following (non-normative) table.＼
</p>

<div class="p">
<ul>
	<li>
1 列目には、
%名前 （または %名前 で識別される~navigable）に関する条件が示される。
</li>
	<li>
2 列目には、
追加的な条件が示される。
</li>
	<li>
<p>
3, 4, 5 列目（ “既定”, “不在”, “在” ）は：
</p>
		<ul>
			<li>
［
1 列目, 2 列目
］の条件（空欄は無条件）がどちらも満たされる下で，
どの`~navigable$が~navigateされるかを与える
— これらを満たす行が複数ある場合、
それらのうち最初に現れる行に従う。
</li>
			<li>
“既定” の列は、
次が満たされないときの効果を与える
⇒
当の “~link等” は、
ある［
`sandbox$a 属性を有する `iframe$e
］内に在る
</li>
			<li>
［
“不在” ／ “在”
］の列は、
前項の条件が満たされる下で，
当の `sandbox^a 属性の値に `allow-top-navigation$v ~keywordが［
無いとき／在るとき
］の効果を与える。
</li>
		</ul>
	</li>
	<li>
<p>
この表tには、
次の表tの 1 列目に挙げる~~記号も利用される：
</p>

<table><thead>
<tr><th>~~記号
<th>意味
<tbody>

<tr><td>`現-^i【！current】
<td>
%名前 を指定している “~link等” が所属している`~navigable$を指す。

<tr><td>`親^i【！parent】
<td>
`現-^i の`親$navを指す。

<tr><td>`top^i
<td>
`現-^i の`~top-level辿可能$navを指す。

<tr><td>`新-^i【！new】
<td>
新たな`~top-level辿可能$が作成される（したがって，その`親$navは ~NULL になる）ことを意味する
（それは、
`補助~閲覧~文脈$を利用し得る
— これは、
様々な［
利用者-選好／~UA施策
］の~subjectになる）。

<tr><td>`ナシ^i【！none】
<td>
何も起きない（~navigateされる~navigableは無い）ことを意味する。

<tr><td>`新-？^i【！maybe new】
<td>
（ “不在” ／ “在” の列に限る）
`iframe^e の `sandbox$a 属性に `allow-popups$v ~keywordも指定されているならば `新-^i と同じ。
他の場合は `ナシ^i と同じ
（ただし，利用者が~sandbox法を上書きした（していた）場合、
`新-^i になり得る）。

<tr><td>`N^i
<td>
（非~keywordによる %名前 の場合に限る）
`~navigable$のうち［
`~target名$navとして %名前 を伴うもの
］を指す
（複数ある場合、
`~navigableを選ぶ規則$に従って，一つに絞られる）。
</table>

	</li>
</ul>

<p class="trans-note">【
原文による表tの説明は，省略され過ぎているので、
この訳ではかなり加筆している。
】</p>

◎
In this table, "current" means the navigable that the link or script is in, "parent" means the parent of the navigable that the link or script is in, "top" means the top-level traversable of the navigable that the link or script is in, "new" means a new traversable navigable with a null parent (which may use an auxiliary browsing context, subject to various user preferences and user agent policies), "none" means that nothing will happen, and "maybe new" means the same as "new" if the "allow-popups" keyword is also specified on the sandbox attribute (or if the user overrode the sandboxing), and the same as "none" otherwise.
</div>

<div>
<table id="_nav-table">
<caption>~target~navigable表t</caption>
<thead>
<tr><th>%名前
<th>追加的な条件
<th>既定
<th>不在
<th>在
<tbody>

<tr><td>【！none specified, for links and form submissions】
%名前 は指定されていない
<td>
<td>`現-^i
<td>`現-^i
<td>`現-^i

<tr><td>空~文字列
<td>
<td>`現-^i
<td>`現-^i
<td>`現-^i

<tr><td>`_blank^l
<td>
<td>`新-^i
<td>`新-？^i
<td>`新-？^i

<tr><td>`_self^l
<td>
<td>`現-^i
<td>`現-^i
<td>`現-^i

<tr><td rowspan="3">
【！_parent if there isn't a parent】
`_parent^l
<td>`親^i ~EQ ~NULL
<td>`現-^i
<td>`現-^i
<td>`現-^i

<tr>
<td>
【！_parent if parent is also top】
`親^i ~EQ `top^i
<td>`親^i
<td>`ナシ^i
<td>`親^i

<tr>
<td>
【！_parent if there is one and it's not top】
【！`親^i ~NIN { ~NULL, `top^i }】
<td>`親^i
<td>`ナシ^i
<td>`ナシ^i

<tr><td rowspan="2">
【！_top if top is current】
`_top^l
<td>`top^i ~EQ `現-^i
<td>`top^i
<td>`現-^i
<td>`現-^i

<tr>
<td>
【！_top if top is not current】
【！`top^i ~NEQ `現-^i】
<td>`top^i
<td>`ナシ^i
<td>`top^i

<tbody><tr><th colspan="5" scope="rowgroup">
（以下、
%名前 は`妥当な~navigable~target名$である場合）

<tr><td>
【！name that doesn't exist】
`N^i は存在しない
<td>
<td>`新-^i
<td>`新-？^i
<td>`新-？^i

<tr><td>
【！name that exists and is a descendant】
`N^i は `現-^i の子孫である
<td>
<td>`N^i
<td>`N^i
<td>`N^i

<tr><td>
【！name that exists and is current】
`N^i ~EQ `現-^i
<td>
<td>`N^i
<td>`N^i
<td>`N^i

<tr><td rowspan="2">
【！name that exists and is an ancestor that is top】
`N^i は `現-^i の先祖である
<td>`N^i ~EQ `top^i
<td>`N^i
<td>`ナシ^i
<td>`N^i

<tr>
<td>
【！name that exists and is an ancestor that is not top】
【！`N^i ~NEQ `top^i】
<td>`N^i
<td>`ナシ^i
<td>`ナシ^i

<tr><td>
【！other name that exists with common top】
`N^i の`~top-level辿可能$nav ~EQ `top^i
<td>
<td>`N^i
<td>`ナシ^i
<td>`ナシ^i

<tr><td rowspan="2">
【！name that exists with different top, if familiar and one permitted sandboxed navigator】
`N^i は `現-^i に`近しい$
<td>`現-^i は `N^i の`許可-済み~navigator$である
<td>`N^i
<td>`N^i
<td>`N^i

<tr>
<td>
【！name that exists with different top, if familiar but not one permitted sandboxed navigator】
【！`現-^i は `N^i の`許可-済み~navigator$でない】
<td>`N^i
<td>`ナシ^i
<td>`ナシ^i

<tr><td>
【！name that exists with different top, not familiar】
【！~NOT［ `N^i は `現-^i に`近しい$］】
<td>
<td>`新-^i
<td>`新-？^i
<td>`新-？^i
</table>
◎
Keyword｜Ordinary effect｜Effect in an iframe with...
｜｜sandbox=""｜sandbox="allow-top-navigation"
◎
none specified, for links and form submissions｜current｜current｜current
empty string｜current｜current｜current
_blank｜new｜maybe new｜maybe new
_self｜current｜current｜current
_parent if there isn't a parent｜current｜current｜current
_parent if parent is also top｜parent/top｜none｜parent/top
_parent if there is one and it's not top｜parent｜none｜none
_top if top is current｜current｜current｜current
_top if top is not current｜top｜none｜top
name that doesn't exist｜new｜maybe new｜maybe new
name that exists and is a descendant｜specified descendant｜specified descendant｜specified descendant
name that exists and is current｜current｜current｜current
name that exists and is an ancestor that is top｜specified ancestor｜none｜specified ancestor/top
name that exists and is an ancestor that is not top｜specified ancestor｜none｜none
other name that exists with common top｜specified｜none｜none
name that exists with different top, if familiar and one permitted sandboxed navigator｜specified｜specified｜specified
name that exists with different top, if familiar but not one permitted sandboxed navigator｜specified｜none｜none
name that exists with different top, not familiar｜new｜maybe new｜maybe new
</div>

<p class="tablenote">
<small>
~sandbox化された閲覧~文脈に対する制約のほとんどは、
他の~algo
— 例えば，`~navi~algo$ —
により適用される。
`~navigableを選ぶ規則$ではなく。
</small>
◎
Most of the restrictions on sandboxed browsing contexts are applied by other algorithms, e.g. the navigation algorithm, not the rules for choosing a navigable given below.
</p>

<hr>

<div class="algo">
<p>
`~navigableを~target名により見出す@
~algoは、
所与の
( 文字列 %名前, `~navigable$ %現在の~navigable )
に対し：
◎
To find a navigable by target name given a string name and a navigable currentNavigable:
</p>
<ol>
	<li>
%現在の文書 ~LET %現在の~navigable にて`作動中な文書$nav
◎
Let currentDocument be currentNavigable's active document.
</li>
	<li>
%~source~snapshot~params ~LET `~source~snapshot~paramsを~snapshotする$( %現在の文書 )
◎
Let sourceSnapshotParams be the result of snapshotting source snapshot params given currentDocument.
</li>
	<li>
<p>
%探索する下位tree群 ~LET `実装定義$に選ばれる，次に挙げるいずれか：
◎
Let subtreesToSearch be an implementation-defined choice of one of the following:
</p>
		<ul>
			<li>
« %現在の~navigable の`辿可能な~navigable$nav, %現在の~navigable »
◎
« currentNavigable's traversable navigable, currentNavigable »
</li>
			<li>
%現在の文書 の`広義-先祖~navigable群$
◎
the inclusive ancestor navigables of currentDocument
</li>
		</ul>

<p class="XXX">
相互運用能を達成するために，
これら 2 つのアリ性どちらに決着するかは、
`課題 #10848＠~HTMLissue/10848$ が追跡する。
◎
Issue #10848 tracks settling on one of these two possibilities, to achieve interoperability.
</p>
	</li>
	<li>
<p>
%探索する下位tree群 を成す
~EACH( %探索する下位tree )
に対し，逆順に：
◎
For each subtreeToSearch of subtreesToSearch, in reverse order:
</p>
		<ol>
			<li>
%探索する文書 ~LET %探索する下位tree にて`作動中な文書$nav
◎
Let documentToSearch be subtreeToSearch's active document.
</li>
			<li>
<p>
%探索する文書 の`広義-子孫~navigable群$を成す
~EACH( %~navigable )
に対し：
◎
For each navigable of the inclusive descendant navigables of documentToSearch:
</p>
				<ol>
					<li>
<p>
~IF［
%現在の~navigable が %~source~snapshot~params の下で %~navigable を`~navigateすることは~sandbox法により許容され$る
］
⇒
任意選択で
⇒
~CONTINUE
◎
If currentNavigable is not allowed by sandboxing to navigate navigable given sourceSnapshotParams, then optionally continue.
</p>

<p class="XXX">
相互運用能を達成するために，
この検査が要求されるようにすることは、
`課題 #10849＠~HTMLissue/10849$ が追跡する。
◎
Issue #10849 tracks making this check required, to achieve interoperability.
</p>
					</li>
					<li>
~IF［
%~navigable の`~target名$nav ~EQ %名前
］
⇒
~RET %~navigable
◎
If navigable's target name is name, then return navigable.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%現在の~top-level閲覧~文脈 ~LET %現在の~navigable にて`作動中な閲覧~文脈$navの`~top-level閲覧~文脈$bc
◎
Let currentTopLevelBrowsingContext be currentNavigable's active browsing context's top-level browsing context.
</li>
	<li>
%~group ~LET %現在の~top-level閲覧~文脈 の`~group$tbcG
◎
Let group be currentTopLevelBrowsingContext's group.
</li>
	<li>
<p>
%~group の`閲覧~文脈~集合$bcGを成す
~EACH( %~top-level閲覧~文脈 )
に対し，`実装定義$な順序で：
◎
For each topLevelBrowsingContext of group's browsing context set, in an implementation-defined order＼
</p>

<p>
~UAは、
一貫した順序付けを~~選ぶベキである
— ［
より近過去に開いたもの／
より近過去に~focusされたもの／
より近く関係するもの
］ほど~~優先するなど。
◎
(the user agent should pick a consistent ordering, such as the most recently opened, most recently focused, or more closely related):
</p>

<p class="XXX">
相互運用能を達成するために，
特定の順序付けを~~選ぶことは、
`課題 #10850＠~HTMLissue/10850$ が追跡する。
◎
Issue #10850 tracks picking a specific ordering, to achieve interoperability.
</p>
		<ol>
			<li>
~IF［
%現在の~top-level閲覧~文脈 ~EQ %~top-level閲覧~文脈
］
⇒
~CONTINUE
◎
If currentTopLevelBrowsingContext is topLevelBrowsingContext, then continue.
</li>
			<li>
%探索する文書 ~LET %~top-level閲覧~文脈 にて`作動中な文書$bc
◎
Let documentToSearch be topLevelBrowsingContext's active document.
</li>
			<li>
<p>
%探索する文書 の`広義-子孫~navigable群$を成す
~EACH( %~navigable )
に対し：
◎
For each navigable of the inclusive descendant navigables of documentToSearch:
</p>
				<ol>
					<li>
~IF［
~NOT %現在の~navigable にて`作動中な閲覧~文脈$navは %~navigable にて`作動中な閲覧~文脈$navに`近しい$
］
⇒
~CONTINUE
◎
If currentNavigable's active browsing context is not familiar with navigable's active browsing context, then continue.
</li>
					<li>
<p>
~IF［
%現在の~navigable が %~source~snapshot~params の下で %~navigable を`~navigateすることは~sandbox法により許容され$ない
］
⇒
任意選択で
⇒
~CONTINUE
◎
If currentNavigable is not allowed by sandboxing to navigate navigable given sourceSnapshotParams, then optionally continue.
</p>

<p class="XXX">
相互運用能を達成するために，
この検査が要求されるようにすることは、
`課題 #10849＠~HTMLissue/10849$ が追跡する。
◎
Issue #10849 tracks making this check required, to achieve interoperability.
</p>
					</li>
					<li>
~IF［
%~navigable の`~target名$nav ~EQ %名前
］
⇒
~RET %~navigable
◎
If navigable's target name is name, then return navigable.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navigableを選ぶ規則@
は、
所与の
( 文字列 %名前, `~navigable$ %現在の~navigable, 真偽値 %noopener )
に対し，次に従う：
◎
The rules for choosing a navigable, given a string name, a navigable currentNavigable, and a boolean noopener are as follows:
</p>
<ol>
	<li>
%~window種別 ~LET `既存のまたはナシ^i
◎
↓ Let chosen be null.
◎
Let windowType be "existing or none".
</li>
	<li>
%~sandbox法~flag集合 ~LET %現在の~navigable にて`作動中な文書$navにて`作動中な~sandbox法~flag集合$
◎
Let sandboxingFlagSet be currentNavigable's active document's active sandboxing flag set.
</li>
	<li>
%小文字~化~名 ~LET `~ASCII小文字~化する$( %名前 )
◎
↓</li>
	<li>
<p>
%結果 ~LET %小文字~化~名 に応じて：
</p>
		<ul class="switch">
			<li>
空~文字列
⇒
%現在の~navigable
</li>
			<li>
`_self^l
⇒
%現在の~navigable
</li>
			<li>
`_parent^l
⇒＃
%現在の~navigable の`親$nav ~NEQ ~NULL ならば それ ／
~ELSE_ %現在の~navigable
</li>
			<li>
`_top^l
⇒＃
%現在の~navigable の`辿可能な~navigable$nav ~NEQ ~NULL ならば それ ／
~ELSE_ %現在の~navigable
</li>
			<li>
`_blank^l
⇒
~NULL
</li>
			<li>
その他
⇒
`~navigableを~target名により見出す$( %名前, %現在の~navigable )
</li>
		</ul>
◎
If name is the empty string or an ASCII case-insensitive match for "_self", then set chosen to currentNavigable.
◎
Otherwise, if name is an ASCII case-insensitive match for "_parent", set chosen to currentNavigable's parent, if any, and currentNavigable otherwise.
◎
Otherwise, if name is an ASCII case-insensitive match for "_top", set chosen to currentNavigable's traversable navigable.
◎
Otherwise, if name is not an ASCII case-insensitive match for "_blank", and there exists a navigable that is the result of finding a navigable by target name given name and currentNavigable, set chosen to that navigable.
</li>
	<li>
<p>
~IF［
%結果 ~EQ ~NULL
］：
◎
Otherwise,＼
</p>

<p>
（新たな`~top-level辿可能$が要請されている
— 何が起こるかは、
~UAの環境設定と能に依存する。）
◎
a new top-level traversable is being requested, and what happens depends on the user agent's configuration and abilities — it is determined by the rules given for the first applicable option from the following list:
</p>
		<ol>
			<li id="popup-blocker">
~IF［
%現在の~navigable にて`作動中な~window$navは`一過な作動化を有して$いない
］~AND［
~UAは~popupを示さないよう環境設定されている
（すなわち，~UAは “~popup阻止器” を可能化している）
］
⇒
~UAは、
~popupを阻止したことを利用者に伝えてもヨイ
◎
If currentNavigable's active window does not have transient activation and the user agent has been configured to not show popups (i.e., the user agent has a "popup blocker" enabled)
• The user agent may inform the user that a popup has been blocked.
</li>
			<li id="sandboxWindowOpen">
~ELIF［
`閲覧~文脈~sandbox化( 補助~navi )~flag$ ~IN %~sandbox法~flag集合
］
⇒
~UAは、
~popupを阻止したことを開発者~consoleに報告してもヨイ
◎
If sandboxingFlagSet has the sandboxed auxiliary navigation browsing context flag set
• The user agent may report to a developer console that a popup has been blocked.
</li>
			<li>
<p>
~ELIF［
~UAは新たな`~top-level辿可能$を作成するよう環境設定されている
］：
◎
If the user agent has been configured such that in this instance it will create a new top-level traversable
</p>
				<ol>
					<li>
`利用者-作動化を消費する$( %現在の~navigable にて`作動中な~window$nav )
◎
Consume user activation of currentNavigable's active window.
</li>
					<li>
%~window種別 ~SET `制約されない新たな^i
◎
Set windowType to "new and unrestricted".
</li>
					<li>
%現在の文書 ~LET %現在の~navigable にて`作動中な文書$nav
◎
Let currentDocument be currentNavigable's active document.
</li>
					<li>
<p>
~IF［
%現在の文書 の`~opener施策$docの`値$coOP ~IN { `same-origin$coop, `same-origin-plus-COEP$coop }
］~AND［
%現在の文書 の`生成元$doc
~NEQ`生成元$sub
 %現在の文書 に`関連な設定群~obj$の`~top-level生成元$enV
］
⇒＃
%noopener ~SET ~T,
%小文字~化~名【！%名前】 ~SET `_blank^l,
%~window種別 ~SET `~openerが無い新たな^i
◎
If currentDocument's opener policy's value is "same-origin" or "same-origin-plus-COEP", and currentDocument's origin is not same origin with currentDocument's relevant settings object's top-level origin, then:
• Set noopener to true.
• Set name to "_blank".
• Set windowType to "new with no opener".
</p>

<p class="note">注記：
`~opener施策$が在る下では、
入子な文書のうち［
その~top-level閲覧~文脈にて作動中な文書とは非同一-生成元に属するもの
］の %noopener は，常に ~T に設定される。
◎
In the presence of an opener policy, nested documents that are cross-origin with their top-level browsing context's active document always set noopener to true.
</p>
					</li>
					<li>
%~target名 ~LET %小文字~化~名 に応じて
⇒＃
`_blank^l ならば空~文字列／
~ELSE_ %名前
◎
Let chosen be null.（不要）
◎
Let targetName be the empty string.
◎
If name is not an ASCII case-insensitive match for "_blank", then set targetName to name.
</li>
					<li id="noopener">
~IF［
%noopener ~EQ ~T
］
⇒
%結果 ~SET `新たな~top-level辿可能を作成する$( ~NULL, %~target名, %現在の~navigable )
◎
If noopener is true, then set chosen to the result of creating a new top-level traversable given null, targetName, and currentNavigable.
</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>
						<ol>
							<li>
%結果 ~SET `新たな~top-level辿可能を作成する$( %現在の~navigable にて`作動中な閲覧~文脈$nav, %~target名, %現在の~navigable )
◎
Set chosen to the result of creating a new top-level traversable given currentNavigable's active browsing context, targetName, and currentNavigable.
</li>
							<li>
~IF［
`閲覧~文脈~sandbox化( ~navi )~flag$ ~IN %~sandbox法~flag集合
］
⇒
%結果 にて`作動中な閲覧~文脈$navの`許可-済み~navigator$ ~SET %現在の~navigable にて`作動中な閲覧~文脈$nav
◎
If sandboxingFlagSet's sandboxed navigation browsing context flag is set, then set chosen's active browsing context's one permitted sandboxed navigator to currentNavigable's active browsing context.
</li>
						</ol>
					</li>
					<li>
~IF［
`~sandboxは補助~閲覧~文脈に伝播する~flag$ ~IN %~sandbox法~flag集合
］
⇒
%結果 にて`作動中な閲覧~文脈$navの`~popup~sandbox法~flag集合$に %~sandbox法~flag集合 を成す すべての~flagを追加する
◎
If sandboxingFlagSet's sandbox propagates to auxiliary browsing contexts flag is set, then all the flags that are set in sandboxingFlagSet must be set in chosen's active browsing context's popup sandboxing flag set.
</li>
					<li>
%結果【！未宣言：targetNavigable】 の`~web内容により作成されたか$nav ~SET ~T
◎
Set targetNavigable's is created by web content to true.
</li>
				</ol>

<p class="note">注記：
新たに作成された`~navigable$ %結果 が即時に`~navigate$される場合、
それは， `replace$hH ~naviとして行われることになる。
◎
If the newly created navigable chosen is immediately navigated, then the navigation will be done as a "replace" navigation.
</p>
			</li>
			<li>
~ELIF［
~UAは %現在の~navigable を再利用するよう環境設定されている
］
⇒
%結果 ~SET %現在の~navigable
◎
If the user agent has been configured such that in this instance it will choose currentNavigable
• Set chosen to currentNavigable.
</li>
			<li>
~ELSE（ ~UAは %現在の~navigable においては閲覧~文脈を見出さないよう環境設定されている）
⇒
何もしない
◎
If the user agent has been configured such that in this instance it will not find a navigable
• Do nothing.
</li>
		</ol>

<p class="note">注記：
~UAには、［
~UAが常に %現在の~navigable を選ぶよう環境設定する仕方
］を利用者に供することが奨励される。
◎
User agents are encouraged to provide a way for users to configure the user agent to always choose currentNavigable.
</p>
	</li>
	<li>
~RET ( %結果, %~window種別 )
◎
Return chosen and windowType.
</li>
</ol>
</div>

				</section>
			</section>
			<section id="windows">
<h4 title="Browsing contexts">7.3.2 閲覧~文脈</h4>

<p>
`閲覧~文脈@
（ `browsing context^en ）は、
一連の文書の~program的な表現であり，
1 個の`~navigable$の中に複数個のそれが 住まい得る。
各`閲覧~文脈$には、
それに対応している `WindowProxy$I ~objがあり，
次に挙げるものも伴う：
◎
A browsing context is a programmatic representation of a series of documents, multiple of which can live within a single navigable. Each browsing context has a corresponding WindowProxy object, as well as the following:
</p>

<p class="trans-note">【
［
まだ，この仕様の更新に倣うよう更新されていない他の仕様
］から参照されている`閲覧~文脈$は、
実際には`~navigable$を意味している場合が多い
— `下の記述＠#warning-avoid-using-bcs$を見よ。
】</p>

<ul>
	<li>
`開いた閲覧~文脈@bc
⇒
`閲覧~文脈$ ／ ~NULL
— 初期~時は ~NULL とする。
◎
An opener browsing context, a browsing context or null, initially null.
</li>
	<li>
`作成時の~opener生成元@bc
⇒
`生成元$／~NULL
— 初期~時は ~NULL とする。
◎
An opener origin at creation, an origin or null, initially null.
</li>
	<li>
<p>
`~popupか@bc
⇒
真偽値
— 初期~時は ~F とする。
◎
An is popup boolean, initially false.
</p>

<p class="note">注記：
この仕様における，`~popupか$bcによる義務的な影響iは、
関連な `BarProp$I ~objの `visible＠~WINDOW#dom-barprop-visible$c 取得子にしかない。
しかしながら，~UAは、
`~UI考慮点＠~HTMLlifecycle#nav-traversal-ui$用に それを利用することもあろう。
◎
The only mandatory impact in this specification of is popup is on the visible getter of the relevant BarProp objects. However, user agents might also use it for user interface considerations.
</p>
	</li>
	<li>
`補助か@bc
⇒
真偽値
— 初期~時は ~F とする。
◎
An is auxiliary boolean, initially false.
</li>
	<li>
`初期~URL@bc
⇒
`~URL$ ／ ~NULL
— 初期~時は ~NULL とする。
◎
An initial URL, a URL or null, initially null.
</li>
	<li>
`~virtual閲覧~文脈~group~ID@bc
⇒
整数
— 初期~時は 0 とする。
これは、
`~opener施策の報告-法＠~ORIGIN#coop-struct-report-only-value$に利用され，
報告のみの施策が施行されていた場合に起こる閲覧~文脈~groupの切替nを追跡し続ける。
◎
A virtual browsing context group ID integer, initially 0. This is used by opener policy reporting, to keep track of the browsing context group switches that would have happened if the report-only policy had been enforced.
</li>
</ul>

<p>
所与の`閲覧~文脈$ %B に対しては、
次に挙げるものも定義される：
</p>
<ul>
	<li>
%B にて
`作動中な~window@bc
は、
%B の `WindowProxy$I ~objの `Window$sl 内部~slotの値である
【この~slotに保持される】。
◎
A browsing context's active window is its WindowProxy object's [[Window]] internal slot value.＼
</li>
	<li>
%B にて
`作動中な文書@bc
は、
%B にて`作動中な~window$bcに`結付けられた文書$を指す。
◎
A browsing context's active document is its active window's associated Document.
</li>
	<li>
<p>
%B の
`~top-level辿可能@bc
は、
%B にて`作動中な文書$bcの`~node~navigable$の`~top-level辿可能$navを指す。
◎
A browsing context's top-level traversable is its active document's node navigable's top-level traversable.
</li>
</ul>

<p>
`補助~閲覧~文脈@
（ `auxiliary browsing context^en ）とは、
`閲覧~文脈$のうち［
その`補助か$bc ~EQ ~T
］なるものをいう。
【それ以外の`閲覧~文脈$は、<dfn>補助でない閲覧~文脈</dfn>とも称される。】
補助~閲覧~文脈は、
常に`~top-level閲覧~文脈$である。
◎
A browsing context whose is auxiliary is true is known as an auxiliary browsing context. Auxiliary browsing contexts are always top-level browsing contexts.
</p>

<p class="XXX">
別々な［
`補助か$bcの概念
］が必要yであるかどうかは、
明瞭でない。
`課題 #5680＠~HTMLissue/5680$ にて、［
`開いた閲覧~文脈$bc ~EQ ~NULL
］かどうかを利用して，これを単純~化できそうなことが指示されている。
◎
It's unclear whether a separate is auxiliary concept is necessary. In issue #5680, it is indicated that we may be able to simplify this by using whether or not the opener browsing context is null.
</p>

<p id="warning-avoid-using-bcs" class="warning">
現代の仕様は、
ほとんどの事例では，`閲覧~文脈$の概念を利用するのを避けるべきである
— ［
`閲覧~文脈~groupの切替n＠~ORIGIN#browsing-context-group-switches-due-to-cross-origin-opener-policy$／
`~agent~cluster~map$bcG
］の細部について処していない限り。
代わりに、［
`文書$, `~navigable$
］の概念の方が通例的には適切になる。
◎
Modern specifications should avoid using the browsing context concept in most cases, unless they are dealing with the subtleties of browsing context group switches and agent cluster allocation. Instead, the Document and navigable concepts are usually more appropriate.
</p>

<hr>

<p>
所与の`文書$が
`属する閲覧~文脈@
は、［
`閲覧~文脈$／~NULL
］であり，
初期~時は ~NULL とする。
◎
A Document's browsing context is a browsing context or null, initially null.
</p>

<p class="note">注記：
`文書$が`属する閲覧~文脈$は ~NULL になることもある。
特に，~data集析~toolは、
閲覧~文脈を~instance化することは，まずないであろう。
`createDocument()＠https://dom.spec.whatwg.org/#dom-domimplementation-createdocument$c
などの ~APIを利用して作成された`文書$が`属する閲覧~文脈$は、
必ず ~NULL になる。
また， `iframe$e 要素~用に作成された`文書$が`属する閲覧~文脈$は、
当の要素が後で`文書から除去された$ときには，
`~NULL 化される＠~HTMLlifecycle#destroy-a-document$。
◎
A Document does not necessarily have a non-null browsing context. In particular, data mining tools are likely to never instantiate browsing contexts. A Document created using an API such as createDocument() never has a non-null browsing context. And the Document originally created for an iframe element, which has since been removed from the document, has no associated browsing context, since that browsing context was nulled out.
</p>

<p class="note">注記：
一般に，`~window$と［
`文書$のうち［
それが`属する閲覧~文脈$ ~NEQ ~NULL
］なるもの
］は一対一に対応するが、
1 つだけ例外がある：
`~window$は，同じ`閲覧~文脈$内で 2 番目の`文書$を呈示するために再利用されることもあり、
その場合，対応関係は一対二になる。
【この一対二は，異なる時点も含めてのことであり、任意のある時点では，一意に対応する。】
これは、
`閲覧~文脈$を`初期~about_blank な文書$から別の文書へ`~navigate$するときに生じる
— それは、
`replace$hH ~navi【！with replacement】として行われることになる。
◎
In general, there is a 1-to-1 mapping from the Window object to the Document object, as long as the Document object has a non-null browsing context. There is one exception. A Window can be reused for the presentation of a second Document in the same browsing context, such that the mapping is then 1-to-2. This occurs when a browsing context is navigated from the initial about:blank Document to another, which will be done with replacement.
</p>

				<section id="creating-browsing-contexts">
<h5 title="Creating browsing contexts">7.3.2.1. 閲覧~文脈の作成-法</h5>

<div class="algo">
<p>
`新たな閲覧~文脈と文書を作成する@
~algoは、
所与の
( ［
~NULL／`文書$
］ %作成元, ［
~NULL／要素
］ %埋込元, `閲覧~文脈~group$ %~group )
に対し：
◎
To create a new browsing context and document, given null or a Document object creator, null or an element embedder, and a browsing context group group:
</p>
<ol>
	<li>
%閲覧~文脈 ~LET 新たな`閲覧~文脈$
◎
Let browsingContext be a new browsing context.
</li>
	<li>
%安全でない文脈~作成~時刻 ~LET `安全でない共有される現在の時刻$
◎
Let unsafeContextCreationTime be the unsafe shared current time.
</li>
	<li>
%作成元の生成元 ~LET ~NULL
◎
Let creatorOrigin be null.
</li>
	<li>
%作成元の基底~URL ~LET ~NULL
◎
Let creatorBaseURL be null.
</li>
	<li id="creator-browsing-context">
<p>
~IF［
%作成元 ~NEQ ~NULL
］：
◎
If creator is non-null, then:
</p>
		<ol>
			<li>
%作成元の生成元 ~SET %作成元 の`生成元$doc
◎
Set creatorOrigin to creator's origin.
</li>
			<li>
%作成元の基底~URL ~SET %作成元 の`文書~基底~URL$
◎
Set creatorBaseURL to creator's document base URL.
</li>
			<li>
%閲覧~文脈 の`~virtual閲覧~文脈~group~ID$bc ~SET %作成元 が`属する閲覧~文脈$の`~top-level閲覧~文脈$bcの`~virtual閲覧~文脈~group~ID$bc
◎
Set browsingContext's virtual browsing context group ID to creator's browsing context's top-level browsing context's virtual browsing context group ID.
</li>
		</ol>
	</li>
	<li>
%~sandbox~flag群 ~LET `作成時の~sandbox法~flag群を決定する$( %閲覧~文脈, %埋込元 )
◎
Let sandboxFlags be the result of determining the creation sandboxing flags given browsingContext and embedder.
</li>
	<li id="about-blank-origin">
%生成元 ~LET `生成元を決定する$( ↓ )
⇒＃
`~about_blank$sc,
%~sandbox~flag群,
%作成元の生成元
◎
Let origin be the result of determining the origin given about:blank, sandboxFlags, and creatorOrigin.
</li>
	<li>
%許可~施策 ~LET `~navigable用の許可~施策を作成する$( %埋込元, %生成元 )
`PERMISSIONSPOLICY$r
◎
Let permissionsPolicy be the result of creating a permissions policy given embedder and origin. [PERMISSIONSPOLICY]
</li>
	<li>
%~agent ~LET `生成元が類似な~window~agentを得する$( %生成元, %~group, ~F )
◎
Let agent be the result of obtaining a similar-origin window agent given origin, group, and false.
</li>
	<li>
%~realm実行~文脈 ~LET 次のように~custom化する下で，
%~agent 内で`新たな~realmを作成する$
⇒＃
大域~obj用に 新たな `Window$I ~objを作成する,
大域 `this^jv 束縛には %閲覧~文脈 の`WindowProxy$I ~objを利用する
◎
Let realm execution context be the result of creating a new realm given agent and the following customizations:
• For the global object, create a new Window object.
• For the global this binding, use browsingContext's WindowProxy object.
</li>
	<li>
%~top-level作成時の~URL ~LET %埋込元 に応じて
⇒＃
~NULL ならば `~about_blank$sc ／
~ELSE_ %埋込元 に`関連な設定群~obj$の`~top-level作成時の~URL$enV
◎
Let topLevelCreationURL be about:blank if embedder is null; otherwise embedder's relevant settings object's top-level creation URL.
</li>
	<li>
%~top-level生成元 ~LET %埋込元 に応じて
⇒＃
~NULL ならば %生成元 ／
~ELSE_ %埋込元 に`関連な設定群~obj$の`~top-level生成元$enV
◎
Let topLevelOrigin be origin if embedder is null; otherwise embedder's relevant settings object's top-level origin.
</li>
	<li>
%新たな設定群~obj ~LET `~window用に環境~設定群~objを設定しておく$( ↓ )
⇒＃
`~about_blank$sc,
%~realm実行~文脈,
~NULL,
%~top-level作成時の~URL,
%~top-level生成元
◎
Set up a window environment settings object with about:blank, realm execution context, null, topLevelCreationURL, and topLevelOrigin.
</li>
	<li>
%~load計時~報 ~LET 新たな`文書~load計時~報$
— その
⇒＃
`~navi開始~時刻$ ~SET `時刻を粗化する$( %安全でない文脈~作成~時刻, %新たな設定群~obj の`非同一-生成元~能力は隔離されるか？$enV )
◎
Let loadTimingInfo be a new document load timing info with its navigation start time set to the result of calling coarsen time with unsafeContextCreationTime and the new environment settings object's cross-origin isolated capability.
</li>
	<li>
<p>
%文書 ~LET 新たな`文書$
— その
⇒＃
`種別$doc ~SET `html^l,
`内容~型$doc ~SET "`text/html$mt"
`~mode$doc ~SET `quirks^l,
`生成元$doc ~SET %生成元,
`属する閲覧~文脈$ ~SET %閲覧~文脈,
`許可~施策$doc ~SET %許可~施策,
`作動中な~sandbox法~flag集合$ ~SET %~sandbox~flag群,
`~load計時~報$doc ~SET %~load計時~報,
`初期~about_blankか$doc ~SET ~T,
`~about基底~URL$doc ~SET %作成元の基底~URL,
`宣言的な~shadow根を許容するか$doc ~SET ~T,
`~custom要素~registry$doc ~SET 新たな {{CustomElementRegistry}} ~obj†
</p>

<p class="trans-note">【†
単に
`新たな~obj$( `CustomElementRegistry$I )
の結果なのか，さらに
`new CustomElementRegistry＠~HEcustom#dom-customelementregistry$c 構築子~手続き
も適用した結果なのか不明。
】</p>
◎
Let document be a new Document, with:
◎
type
• "html"
content type
• "text/html"
mode
• "quirks"
origin
• origin
browsing context
• browsingContext 
permissions policy
• permissionsPolicy
active sandboxing flag set
• sandboxFlags
load timing info
• loadTimingInfo
is initial about:blank
• true
about base URL
• creatorBaseURL
allow declarative shadow roots
• true
custom element registry
• A new {{CustomElementRegistry}} object.
</li>
	<li>
<p>
~IF［
%作成元 ~NEQ ~NULL
］：
◎
If creator is non-null, then:
</p>
		<ol>
			<li>
%文書 の`~referrer$doc ~SET `~URLを直列化する$( %作成元 の`~URL$doc )
◎
Set document's referrer to the serialization of creator's URL.
</li>
			<li>
%文書 の`施策~容器$doc ~SET `施策~容器を~cloneする$( %作成元 の`施策~容器$doc )
◎
Set document's policy container to a clone of creator's policy container.
</li>
			<li>
~IF［
%作成元 の`生成元$doc
~EQ`生成元$sub
%作成元 に`関連な設定群~obj$の`~top-level生成元$enV
］
⇒
%文書 の`~opener施策$doc ~SET %作成元 が`属する閲覧~文脈$の`~top-level閲覧~文脈$bcにて`作動中な文書$bcの`~opener施策$doc
◎
If creator's origin is same origin with creator's relevant settings object's top-level origin, then set document's opener policy to creator's browsing context's top-level browsing context's active document's opener policy.
</li>
		</ol>
	</li>
	<li>
~Assert：
%文書 の`~URL$doc, 
%文書 に`関連な設定群~obj$の`作成時の~URL$enV
は、いずれも `~about_blank$sc 。
◎
Assert: document's URL and document's relevant settings object's creation URL are about:blank.
</li>
	<li>
この時点で、
%文書 は`~load後~task準備済み$になるとする。
◎
Mark document as ready for post-load tasks.
</li>
	<li>
`文書を~html-head-bodyで拡充する$( %文書 )
◎
Populate with html/head/body given document.
</li>
	<li>
`文書を作動中にする$( %文書 )
◎
Make active document.
</li>
	<li>
`読込ngを完全に終わらす$( %文書 )
◎
Completely finish loading document.
</li>
	<li>
~RET ( %閲覧~文脈, %文書 )
◎
Return browsingContext and document.
</li>
</ol>
</div>

<div class="algo">
<p>
`新たな~top-level閲覧~文脈と文書を作成する@
~algoは：
◎
To create a new top-level browsing context and document:
</p>
<ol>
	<li>
( %~group, %文書 ) ~LET `新たな閲覧~文脈~groupと文書を作成する$()
◎
Let group and document be the result of creating a new browsing context group and document.
</li>
	<li>
~RET ( %~group の`閲覧~文脈~集合$bcG[ 0 ], %文書 )
◎
Return group's browsing context set[0] and document.
</li>
</ol>
</div>

<div class="algo">
<p>
`新たな補助~閲覧~文脈と文書を作成する@
~algoは、
所与の
( `閲覧~文脈$ %~opener )
に対し：
◎
To create a new auxiliary browsing context and document, given a browsing context opener:
</p>
<ol>
	<li>
%~opener~top-level閲覧~文脈 ~LET %~opener の`~top-level辿可能$bcにて`作動中な閲覧~文脈$nav
◎
Let openerTopLevelBrowsingContext be opener's top-level traversable's active browsing context.
</li>
	<li>
%~group ~LET %~opener~top-level閲覧~文脈 の`~group$tbcG
◎
Let group be openerTopLevelBrowsingContext's group.
</li>
	<li>
~Assert：
%~group ~NEQ ~NULL
— これ【この手続き？】は、
`~navigate$するとき直に呼出されるので。
◎
Assert: group is non-null, as navigating invokes this directly.
</li>
	<li>
( %閲覧~文脈, %文書 ) ~LET 
`新たな閲覧~文脈と文書を作成する$( %~opener にて`作動中な文書$nav, ~NULL, %~group )
◎
Let browsingContext and document be the result of creating a new browsing context and document with opener's active document, null, and group.
</li>
	<li>
%閲覧~文脈 の`補助か$bc ~SET ~T
◎
Set browsingContext's is auxiliary to true.
</li>
	<li>
`閲覧~文脈~groupに付加する$( %閲覧~文脈, %~group )
◎
Append browsingContext to group.
</li>
	<li>
%閲覧~文脈 を`開いた閲覧~文脈$bc ~SET %~opener
◎
Set browsingContext's opener browsing context to opener.
</li>
	<li>
%閲覧~文脈 の`~virtual閲覧~文脈~group~ID$bc ~SET %~opener~top-level閲覧~文脈 の`~virtual閲覧~文脈~group~ID$bc
◎
Set browsingContext's virtual browsing context group ID to openerTopLevelBrowsingContext's virtual browsing context group ID.
</li>
	<li>
%閲覧~文脈 の`作成時の~opener生成元$bc ~SET %~opener にて`作動中な文書$navの`生成元$doc
◎
Set browsingContext's opener origin at creation to opener's active document's origin.
</li>
	<li>
~RET ( %閲覧~文脈, %文書 )
◎
Return browsingContext and document.
</li>
</ol>
</div>

<div class="algo">
<p>
`生成元を決定する@
~algoは、
所与の
⇒＃
`~URL$ %~URL,
`~sandbox法~flag集合$ %~sandbox~flag群,
［ `生成元$／~NULL ］ %~source生成元
◎終
に対し：
◎
To determine the origin, given a URL url, a sandboxing flag set sandboxFlags, and an origin-or-null sourceOrigin:
</p>
<ol>
	<li id="sandboxOrigin">
~IF［
`閲覧~文脈~sandbox化( 生成元 )~flag$ ~IN %~sandbox~flag群
］
⇒
~RET 新たな`不透明な生成元$
◎
If sandboxFlags has its sandboxed origin browsing context flag set, then return a new opaque origin.
</li>
	<li>
~IF［
%~URL ~EQ ~NULL
］
⇒
~RET 新たな`不透明な生成元$
◎
If url is null, then return a new opaque origin.
</li>
	<li>
<p>
~IF［
%~URL ~EQ `~about_srcdoc$sc
］：
◎
If url is about:srcdoc, then:
</p>
		<ol>
			<li>
~Assert：
%~source生成元 ~NEQ ~NULL
◎
Assert: sourceOrigin is non-null.
</li>
			<li>
~RET %~source生成元
◎
Return sourceOrigin.
</li>
		</ol>
	</li>
	<li>
~IF［
%~URL は`~about_blank に合致して$いる
］~AND［
%~source生成元 ~NEQ ~NULL
］
⇒
~RET %~source生成元
◎
If url matches about:blank and sourceOrigin is non-null, then return sourceOrigin.
</li>
	<li>
~RET %~URL の`生成元$url
◎
Return url's origin.
</li>
</ol>

<p class="note">注記：
%~source生成元 を返す事例では、
2 つの`文書$の下層の`生成元$docは同じになり，
`document.domain＠~WINDOW#dom-document-domain$c は両者に影響することを意味する。
◎
The cases that return sourceOrigin result in two Documents that end up with the same underlying origin, meaning that document.domain affects both.
</p>
</div>

				</section>
				<section id="nested-browsing-contexts">
<h5 title="Related browsing contexts">7.3.2.2. 関係する閲覧~文脈たち</h5>

<div class="algo">
<p>
`閲覧~文脈$ %A が閲覧~文脈 %B の
`先祖~閲覧~文脈@
であるとは、
次の~algoが ~T を返すことをいう：
◎
A browsing context potentialDescendant is said to be an ancestor of a browsing context potentialAncestor if the following algorithm returns true:
</p>
<ol>
	<li>
%文書 ~LET %A にて`作動中な文書$bc
◎
Let potentialDescendantDocument be potentialDescendant's active document.
</li>
	<li>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~RET ~F
◎
If potentialDescendantDocument is not fully active, then return false.
</li>
	<li>
%文書 の`先祖~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
~IF［
%B ~EQ %~navigable にて`作動中な文書$navが`属する閲覧~文脈$
］
⇒
~RET ~T
◎
Let ancestorBCs be the list obtained by taking the browsing context of the active document of each member of potentialDescendantDocument's ancestor navigables.
◎
If ancestorBCs contains potentialAncestor, then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<p>
`~top-level閲覧~文脈@
とは、
次を満たす`閲覧~文脈$である
⇒
`作動中な文書$bcの`~node~navigable$は、
`辿可能な~navigable$である
◎
A top-level browsing context is a browsing context whose active document's node navigable is a traversable navigable.
</p>

<p class="note">注記：
`~top-level辿可能$になることは、
`要求されない^em。
◎
It is not required to be a top-level traversable.
</p>

<div class="algo">
<p>
`閲覧~文脈$ %B の
`~top-level閲覧~文脈@bc
は、
次を走らせた結果になる：
◎
The top-level browsing context of a browsing context start is the result of the following algorithm:
</p>
<ol>
	<li>
~IF［
%B にて`作動中な文書$bcは`全部的に作動中$でない
］
⇒
~RET ~NULL
◎
If start's active document is not fully active, then return null.
</li>
	<li>
%~navigable ~LET %B にて`作動中な文書$bcの`~node~navigable$
◎
Let navigable be start's active document's node navigable.
</li>
	<li>
~WHILE［
%~navigable の`親$nav ~NEQ ~NULL
］
⇒
%~navigable ~SET %~navigable の`親$nav
◎
While navigable's parent is not null, set navigable to navigable's parent.
</li>
	<li>
~RET %~navigable にて`作動中な閲覧~文脈$nav
◎
Return navigable's active browsing context.
</li>
</ol>
</div>

<div id="warning-avoid-related-bc-terms" class="warning">
<p>
用語［
`先祖~閲覧~文脈$, `~top-level閲覧~文脈$が
］が有用になることは、
稀にしかない
— 一般に，`閲覧~文脈$は、
`通例的に，利用するのは不適切な仕様~概念＠#warning-avoid-using-bcs$なので。
特に，
`閲覧~文脈$にて`作動中な文書$bcが`全部的に作動中$でないとき、
それが［
先祖／~top-level
］閲覧~文脈として数えられることは決してないことに注意。
そのようなわけで、
これらの概念は，
`~BF~cache＠~HTMLnav#note-bfcache$が効いているときには有用でない。
◎
The terms ancestor browsing context and top-level browsing context are rarely useful, since browsing contexts in general are usually the inappropriate specification concept to use. Note in particular that when a browsing context's active document is not fully active, it never counts as an ancestor or top-level browsing context, and as such these concepts are not useful when bfcache is in play.
</p>

<p>
代わりに，［
`先祖~navigable群$【！collection】／
`親~navigable$／
`辿可能な~navigable$nav
］などの概念を利用すること。
◎
Instead, use concepts such as the ancestor navigables collection, the parent navigable, or a navigable's top-level traversable.
</p>
</div>

<hr>

<div class="algo">
<p>
所与の`閲覧~文脈$ %A, %B に対し，
%A は %B に
`近しい@
（ “ %A `is familiar with^en %B ” ）とは、
~OR↓ が満たされることをいう：
◎
A browsing context A is familiar with a second browsing context B if the following algorithm returns true:
</p>
<ul>
	<li>
%A にて`作動中な文書$bcの`生成元$doc
~EQ`生成元$sub
%B にて`作動中な文書$bcの`生成元$doc
◎
If A's active document's origin is same origin with B's active document's origin, then return true.
</li>
	<li>
%A の`~top-level閲覧~文脈$bc ~EQ %B
◎
If A's top-level browsing context is B, then return true.
</li>
	<li>
［
%B は`補助~閲覧~文脈$である
］~AND［
%A は %B を`開いた閲覧~文脈$bcに`近しい$
］
◎
If B is an auxiliary browsing context and A is familiar with B's opener browsing context, then return true.
</li>
	<li>
<p>
%B の ある`先祖~閲覧~文脈$ %C として，次を満たすものが存在する
⇒
%C にて`作動中な文書$bcの`生成元$doc
~EQ`生成元$sub
%A にて`作動中な文書$bcの`生成元$doc
◎
If there exists an ancestor browsing context of B whose active document has the same origin as the active document of A, then return true.
</p>

<p class="note">注記：
これは
%A は %B の`先祖~閲覧~文脈$である事例を含む。
◎
This includes the case where A is an ancestor browsing context of B.
◎
Return false.
</p>
	</li>
</ul>
</div>

				</section>
				<section id="groupings-of-browsing-contexts">
<h5 title="Groupings of browsing contexts">7.3.2.3. 閲覧~文脈の~group分け</h5>

<p>
各`~top-level閲覧~文脈$には
`~group@tbcG
が結付けられる
— それは、［
~NULL ／`閲覧~文脈~group$
］であり，初期~時は ~NULL とする。
◎
A top-level browsing context has an associated group (null or a browsing context group). It is initially null.
</p>

<p>
~UAは、
`閲覧~文脈~group集合@
を保持する
— それは、
`閲覧~文脈~group$たちが成す`集合$である。
◎
A user agent holds a browsing context group set＼
(a set of browsing context groups).
</p>

<p>
各
`閲覧~文脈~group@
には、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
<p>
`閲覧~文脈~集合@bcG
⇒
`~top-level閲覧~文脈$たちが成す`集合$。
◎
A browsing context group holds a browsing context set＼
(a set of top-level browsing contexts).
</p>

<p class="note">注記：
`新たな閲覧~文脈~groupと文書を作成する$ときには、
新たな【！ある】`~top-level閲覧~文脈$が当の`閲覧~文脈~group$に追加される。
後続して`閲覧~文脈~group$に追加される`~top-level閲覧~文脈$は、
すべて`補助~閲覧~文脈$である。
◎
A top-level browsing context is added to the group when the group is created. All subsequent top-level browsing contexts added to the group will be auxiliary browsing contexts.
</p>
	</li>
	<li>
`~agent~cluster~map@bcG
⇒
`~agent~cluster~key$から`~agent~cluster$への弱い`~map$。
【 “弱い” とは，すなわち、】［
ある~agent~clusterに対し，それに~accessし得るものは無くなった
］と判断されるとき，それを【~garbage】収集するのは、
~UAの責務とする。
◎
A browsing context group has an associated agent cluster map＼
(a weak map of agent cluster keys to agent clusters). User agents are responsible for collecting agent clusters when it is deemed that nothing can access them anymore.
</li>
	<li>
<p>
`履歴上の~agent~cluster~key~map@bcG
⇒
`生成元$から`~agent~cluster~key$への`~map$。
この~mapは、［
所与の生成元~用に，それまで どの~agent~cluster~keyが利用されていたか
］を記録することにより，
`生成元を~keyにする~agent~cluster＠~ORIGIN#origin-keyed-agent-clusters$
特能の一貫性を確保するために利用される。
◎
A browsing context group has an associated historical agent cluster key map,＼
which is a map of origins to agent cluster keys. This map is used to ensure the consistency of the origin-keyed agent clusters feature by recording what agent cluster keys were previously used for a given origin.
</p>

<p class="note">注記
`履歴上の~agent~cluster~key~map$bcGを成す~entryは、
当の`閲覧~文脈~group$の存続期間~内に得られたものに限られる。
◎
The historical agent cluster key map only ever gains entries over the lifetime of the browsing context group.
</p>
	</li>
	<li>
`非同一-生成元~隔離~mode@bcG
⇒
`非同一-生成元~隔離~mode$
— 初期~時は `none$coI とする。
◎
A browsing context group has a cross-origin isolation mode,＼
which is a cross-origin isolation mode. It is initially "none".
</li>
</ul>

<p>
`非同一-生成元~隔離~mode@
にアリな値は
⇒＃
`none@coI,
`logical@coI,
`concrete@coI
◎
A cross-origin isolation mode is one of three possible values: "none", "logical", or "concrete".
</p>

<div class="note">
<p>注記：
`logical$coI,
`concrete$coI
は、
類似する。
どちらも， ~AND↓ を満たす`閲覧~文脈~group$用に利用される：
◎
"logical" and "concrete" are similar. They are both used for browsing context groups where:
</p>
<ul>
	<li>
それを成すどの~top-level`文書$にも次が伴われる
⇒
`same-origin$coop を値にとる `Cross-Origin-Opener-Policy$h ~header
◎
every top-level Document has `Cross-Origin-Opener-Policy: same-origin`, and
</li>
	<li>
それを成すどの`文書$にも次が伴われる
⇒
`非同一-生成元~隔離と互換$な値をとる `Cross-Origin-Embedder-Policy$h ~header
◎
every Document has a `Cross-Origin-Embedder-Policy` header whose value is compatible with cross-origin isolation.
</li>
</ul>

<p>
［
`非同一-生成元~能力は隔離されるか？$enVにより通過制御される~APIに対し，安全な~accessを是認する
］ために要求される~securityの特質を供するのが困難な~platformもある。
そのため、
その【~APIが供する】能力 %能力 への~accessを是認できるのは，
`concrete$coI に限られる。
`logical$coI は、
%能力 【への安全な~access】を~supportしていない~platformにて利用される
— そこでも，非同一-生成元~隔離により課される様々な制約は適用されるが、
%能力 は是認されない。
◎
On some platforms, it is difficult to provide the security properties required to grant safe access to the APIs gated by the cross-origin isolated capability. As a result, only "concrete" can grant access that capability. "logical" is used on platform not supporting this capability, where various restrictions imposed by cross-origin isolation will still apply, but the capability is not granted.
</p>
</div>

<div class="algo">
<p>
`新たな閲覧~文脈~groupと文書を作成する@
~algoは：
◎
To create a new browsing context group and document:
</p>
<ol>
	<li>
%~group ~LET 新たな`閲覧~文脈~group$
◎
Let group be a new browsing context group.
</li>
	<li>
~UAの`閲覧~文脈~group集合$に %~group を`付加する$set
◎
Append group to the user agent's browsing context group set.
</li>
	<li>
( %閲覧~文脈, %文書 ) ~LET `新たな閲覧~文脈と文書を作成する$( ~NULL, ~NULL, %~group )
◎
Let browsingContext and document be the result of creating a new browsing context and document with null, null, and group.
</li>
	<li>
`閲覧~文脈~groupに付加する$( %閲覧~文脈, %~group )
◎
Append browsingContext to group.
</li>
	<li>
~RET ( %~group, %文書 )
◎
Return group and document.
</li>
</ol>
</div>

<div class="algo">
<p>
`閲覧~文脈~groupに付加する@
~algoは、
所与の
( `~top-level閲覧~文脈$ %閲覧~文脈, `閲覧~文脈~group$ %~group )
に対し：
◎
To append a top-level browsing context browsingContext to a browsing context group group:
</p>
<ol>
	<li>
%~group の`閲覧~文脈~集合$bcGに %閲覧~文脈 を`付加する$set
◎
Append browsingContext to group's browsing context set.
</li>
	<li>
%閲覧~文脈 の`~group$tbcG ~SET %~group
◎
Set browsingContext's group to group.
</li>
</ol>
</div>

<div class="algo">
<p>
`閲覧~文脈~groupから除去する@
~algoは、
所与の
( `~top-level閲覧~文脈$ %閲覧~文脈 )
に対し：
◎
To remove a top-level browsing context browsingContext:
</p>
<ol>
	<li>
~Assert：
%閲覧~文脈 の`~group$tbcG ~NEQ ~NULL
◎
Assert: browsingContext's group is non-null.
</li>
	<li>
%~group ~LET %閲覧~文脈 の`~group$tbcG
◎
Let group be browsingContext's group.
</li>
	<li>
%閲覧~文脈 の`~group$tbcG ~SET ~NULL
◎
Set browsingContext's group to null.
</li>
	<li>
%~group の`閲覧~文脈~集合$bcGから %閲覧~文脈 を`除去する$
◎
Remove browsingContext from group's browsing context set.
</li>
	<li>
~IF［
%~group の`閲覧~文脈~集合$bcGは`空$である
］
⇒
~UAの`閲覧~文脈~group集合$から %~group を`除去する$
◎
If group's browsing context set is empty, then remove group from the user agent's browsing context group set.
</li>
</ol>
</div>

<p class="note">注記：
［
`閲覧~文脈~groupに付加する$／
`閲覧~文脈~groupから除去する$
］は、
`閲覧~文脈~group$の存続期間を定義し易くするための，~primitiveな演算である。
それらは、［
`文書$, `閲覧~文脈$
］用の より高~levelな［
作成／破壊
］演算から~callされる。
◎
Append and remove are primitive operations that help define the lifetime of a browsing context group. They are called by higher-level creation and destruction operations for Documents and browsing contexts.
</p>

<p id="a-browsing-context-is-discarded">
所与の`閲覧~文脈$ %B に対し，［
%B に`属する文書＠#concept-document-bc$は無くなった
］（すなわち，
そのような`文書$は，すべて`破壊された＠#destroy-a-document$）かつ［
%B の `WindowProxy$I は~garbage収集~用に適格になった
］とき、
%B が再び~accessされることは決してなくなる。
%B が`~top-level閲覧~文脈$である場合、
その時点で
~UAは
%B を`閲覧~文脈~groupから除去する$モノトスル。
◎
When there are no Document objects whose browsing context equals a given browsing context (i.e., all such Documents have been destroyed), and that browsing context's WindowProxy is eligible for garbage collection, then the browsing context will never be accessed again. If it is a top-level browsing context, then at this point the user agent must remove it.
</p>

				</section>
			</section>
			<section id="fully-active-documents">
<h4 title="Fully active documents">7.3.3 全部的に作動中な文書</h4>

<div>
<p>
`文書$ %文書 が
`全部的に作動中@
（ `fully active^en ）であるとは、［
~AND↓ を満たす`~navigable$
］が在ることをいう：
</p>
<ul>
	<li>
それにて`作動中な文書$nav ~EQ %文書
</li>
	<li>
<p>
~OR↓：
</p>
		<ul>
			<li>
`~top-level辿可能$である
</li>
			<li>
その`容器~文書$navは`全部的に作動中$である
</li>
		</ul>
	</li>
</ul>
◎
A Document d is said to be fully active when d is the active document of a navigable navigable, and either navigable is a top-level traversable or navigable's container document is fully active.
</div>

<p>
`子~navigable$ %子 は，
ある要素に結付けられるので、
%子 は常に， %子 の`親$nav内で特定の`文書$
— すなわち， %子 の`容器~文書$nav —
に束ねられる。
~UAは、
%子 の`容器~文書$navが`全部的に作動中$でない間は，
利用者が %子 とヤリトリすることを許容しないモノトスル。
◎
Because they are associated with an element, child navigables are always tied to a specific Document, their container document, in their parent navigable. User agents must not allow the user to interact with child navigables whose container documents are not themselves fully active.
</p>

<div class="example">
<p>
`文書$は、
その`~node~navigable$にて`作動中な文書$navでありながら，
`全部的に作動中$でなくなることもある
— そうなり得る様子を次の例で~~説明する。
ここでは、
~browser~windowの中に `a.html^c が読込まれる結果，
その `iframe$e の中に `b-1.html^c が読込まれる。
`b-2.html^c, `c.html^c は省略されている
（それらは、単純に空な文書でもよい）。
◎
The following example illustrates how a Document can be the active document of its node navigable, while not being fully active. Here a.html is loaded into a browser window, b-1.html starts out loaded into an iframe as shown, and b-2.html and c.html are omitted (they can simply be an empty document).
</p>

<pre class="lang-html">
&lt;!-- a.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;title&gt;~navigable A&lt;/title&gt;

&lt;iframe src="b-1.html"&gt;&lt;/iframe&gt;
&lt;button onclick="frames[0].location.href = 'b-2.html'"&gt;~clickしてください&lt;/button&gt;

&lt;!-- b-1.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;title&gt;~navigable B&lt;/title&gt;

&lt;iframe src="c.html"&gt;&lt;/iframe&gt;
</pre>

<p>
この時点では、［
`a.html^c, `b-1.html^c, `c.html^c
］から与えられる文書は、
どれも各自の`~node~navigable$にて`作動中な文書$navであり，また`全部的に作動中$でもある。
◎
At this point, the documents given by a.html, b-1.html, and c.html are all the active documents of their respective node navigables. They are also all fully active.
</p>

<p>
ここで `button$e が~clickされたとすると、
~navigable B の中へ `b-2.html^c から新たな`文書$が読込まれ，次の結果が得られる：
◎
After clicking on the button, and thus loading a new Document from b-2.html into navigable B, we have the following results:
</p>
<ul>
	<li>
`a.html^c `文書$は、
~navigable A にて`作動中な文書$navかつ`全部的に作動中$であり続ける。
◎
The a.html Document remains both the active document of navigable A, and fully active.
</li>
	<li>
`b-1.html^c `文書$は、
今や~navigable B にて`作動中な文書$nav`ではない^em
— よって、
`全部的に作動中$でもない。
◎
The b-1.html Document is now not the active document of navigable B. As such it is also not fully active.
</li>
	<li>
新たな `b-2.html^c `文書$は、
今や~navigable B にて`作動中な文書$navにあり，また`全部的に作動中$でもある。
◎
The new b-2.html Document is now the active document of navigable B, and is also fully active.
</li>
	<li>
`c.html^c `文書$は、
依然として，~navigable C にて`作動中な文書$navである。
しかしながら、
C の`容器~文書$navは `b-1.html^c `文書$であり，`全部的に作動中$ではない
— すなわち、
`c.html^c `文書$は，今や`全部的に作動中$でないことになる。
◎
The c.html Document is still the active document of navigable C. However, since C's container document is the b-1.html Document, which is itself not fully active, this means the c.html Document is now not fully active.
</li>
</ul>
</div>

			</section>
		</section>
</main>
