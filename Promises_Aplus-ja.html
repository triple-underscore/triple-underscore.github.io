<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Promises/A+ （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script >
var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
//		original_url: '',
		main: 'MAIN',
		toc: 'contents',
	};

	if(expanded){
		var e = E('_optional_controls');
		if(e) {
			e.parentNode.removeChild(e);
		}
		return options;
	}

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // verified: vers.1.1.1, 140505 spec

	return options;
}


function expand(mapping1){
	var link_map = this.link_map;

	E('MAIN').innerHTML = Util.generateSource(this, mapping1, function(source){
		return source.replace(
			/%\w+|`(.+?)([\^@$])(\w*)/g,
			create_html
		);
	});
	return;

function create_html(match, key, indicator, klass){
	if(!key) {//%
		return '<var>' + match.slice(1) + '</var>';
	}

	klass = klass || '';
	switch(klass){
	case '':
		var id = link_map[key];
		if(id){
			switch(indicator){
			case '$':
				return '<a href="#' + id + '">' + key + '</a>';
			case '@':
				return '<dfn id="' + id + '">' + key + '</dfn>';
			}
		}
		break;
	case 'c':
		return '<code>' + key +'</code>';
	case 'es':
		return '<code class="es">' + key +'</code>';
	default:
		break;
	}
	return match;
}
}

</script>


<!-- 
<script type="text/plain" id="_original_id_map"></script>
 -->

<!--%links -->
<script type="text/plain" id="_link_map">
~promise:promise
~thenable:thenable
値:value
例外:exception
事由:rejection-reason
処理待ち:pending
充足済み:fulfilled
却下済み:rejected
充足する:fulfill
却下する:reject
充足され:fulfill
却下され:reject
	~promiseの解決~手順:promise-resolution-procedure

</script>


<script type="text/plain" id="words_table">
object:
function:
method:::メソッド
promise::::プロミス
thenable:
property:::プロパティ
call:
callback::::コールバック
大域:global::~:グローバル
handler:::ハンドラ
stack:::スタック
strict:
sloppy:
macro-task:::マクロタスク
micro-task:::マイクロタスク
task:::タスク
schedule:::スケージュル
	~taskを~scheduleする:task-scheduling
trampoline:::トランポリン
待行列:queue::待ち行列:キュー
	task-scheduling~queue

返さ:return し::~
返した:return した::~

連鎖:chain::~:チェイン
投出:throw::~
状態:state::~
演算:operation::~
無視-:ignore::~
無限:infinite::~
非同期的:asynchronous::~
遷移:transition::~
値:value::~
処理待ち:pending::~
却下-:reject::~
却下済み:rejected::~
充足-:fulfill::~
充足:fulfillment::~
充足済み:fulfilled::~
引数:argument::~
解決-:resolve::~
解決:resolution::~
事由:reason::~
例外:exception::~

手順:procedure:手続き
手続き:steps:~
省略可能:optional::~:オプション

such::そのような
	上の:above::~
	この:this::~
	すべての:all::~
	それら:they::~

	3 個の:three
access:::アクセス
accessor:::アクセサ
algo:algorithm::アルゴリズム
基盤:base:~
	choosing:
循環的な:circular:~
循環:cycle:~
code:::コード
	come:come::~
	consideration:consideration::~
事例:case:~
取入れ:adopt:取り入れ
取入れる:adopt する:取り入れる
取入れさ:adopt さ:取り入れさ
	取り扱-:deal
表記-:denote:~
別個の:distinct:~
engine:::エンジン
event-loop:event loop::イベントループ
一面:face:~
新鮮:fresh:~
以降の:further:~
	限りにおいてas long as:
	満たす:meet する:
mode:::モード
性質:nature:~
出自の:originating:~
用心:precaution:~
	になるproduce:
適度な:reasonable:~
	respective:
取得:retrieval:~
取得-:retrieve:~
turn::回

遭遇-:encounter:~
	~~最終的に:finally:~
なぞる:follow する
	含め:including:~
	やりとり:interact::~
既知の:known:~
	known-conformant:known-conformant::~
小さな:minor:~
大きな:large:~
	もたらす:lead:~
	ことも:occasional::~
関与-:participate:~
	~~優先され: take a precedence::~

指す:refer する:~
	あり続け:remain:~
一般:general:~
一貫性:consistency:~
	個目:first／second
	最初の／初回:first
仕方:way:~


仕様:spec:~
主な:primary:~
上限:limit:~
中核の:core:~
主題:subject:~
集中する:focus する:力点を置く
	に取り組む:を address する
変更点:changes:~
奨励-:encourage:~
姉妹:companion:~
安定的:stable:~
実施:practice:~
実装-:implement:~
実装:implementation:~
実装者:implementer:~
将来の:future:~
後方互換:backward-compatible:~
後方互換でない:backward-incompatible:~
指定中:underspecified:~
条項:clause:~
標準:standard::~
相互運用:interoperate:~
相互運用可能:interoperable:~
相互運用可能な:interoperable:~
改訂-:revise:~
文書化-:document 化:~
早期の:earlier:~
明確化-:clarify:~
歴史的:historical:~
注記:note:~
注:note:~
準拠する:compliant な:~
事実的標準:de facto:事実上の標準
提案:proposal:~
切落とし:omit し:切り落とし
	組織:organization:~
統合-:integrate:~
要件:requirements:~
要求-:require:~
不適合:nonconformant:~
適合-:conform:~
適合的:conformant:適合
	conformant
試験-:test:~
試験:testing:~
詳細:details:~
議論:discussion:~
注意深く:carefulに:~
考察-:consider:~
信頼でき:sound:信頼できる
際どい:corner:~
	新たに発見された:newly-discovered:~
発見-:discover:~
open:::オープン
platform:::プラットフォーム
cover:::カバー


仕組み:mechanism:~
他の:other:~
	代わりに:instead:~
何か:somewhat:~
作成-:create:~
依存-:depend:~
入力:input:~
公開-:expose:~
内側:inside:~
再び:again:~
再帰:recursion:~
無限再帰:recursing forever:~
再帰的:recursive:~
利用:use:~
前:before:~
前提:assumption:~
包含-:contain:~
参照:reference:~
受取る:receive する:受け取る
受容-:accept:~
合法な:legal:~
同じ:same:~
同一性:identity:~
消化-:assimilate:~
含意-:imply:~
問題ある:problematic な:問題のある
変化-:change:~
変異不可:immutable::~
変異不可性:immutability::~
定義-:define:~
後:after:~

実行-:execute:~
遂行:perform:~
	行う

恣意的な:arbitrary:~
	:informative:~
意味-:mean:~
成果:work:~
手段:means:~
扱い:treatment:~

抽象:abstract:~
拡張-:extend:~
指示-:indicate:~
挙動する:behave する:ふるまう
挙動:behavior:ふるまい
挙動上の:behavioral:ふるまいについての
提供-:provide:~
文:statement:~
最終的な:eventual:~
最終的:eventual:~
条件:condition:~
格納-:store:~
検出-:detect:~

正しい:correct:~
深い:deep:~
深さ:depth:~
固有の:specific な:~
現在の:current:~
環境:environment:~

序論:introduction:~
各種用語:terminology:~
登録-:register:~
省略-:omit:~
省略可能な:optional:~
真の:true:~
	知られ:known:~
確保-:ensure:~
結果:result:~
	自身:itself:~
表現-:represent:~
複数の:multiple:~
見なさ:consider さ:~
見做す:assume する:~
触れる:touch する:~
許容-:allow:~
試みる:attempt する:~
走らす:run する:~
	超えて:beyond:~
	通:through:~
	避けられる:avoid される:~
部分:part:~
重要:important:~
順序:order:~
実行文脈:execution context:~
	ごく:very::~
	限りにおいてprovided
	来ている~come
設定-:set:~
member:::メンバ
	似た:like


</script>

<!--%style  -->
<style>

var {
	font-family: monospace0, monospace;
}

pre.language-js {
	background: #EEE;
	border: solid gray 1px;
	padding: 0.5em;
}

code, pre {
/*
	color: navy;
*/
}

code.es {
	color: black;
	font-weight: bold;
}


main > h1 {
	color: white;
	background: #222;
	font-size: 2em;
	padding: 0.5em;
	font-family: sans-serif0, sans-serif;
}

main > h1:before {
	content: 'then';
	color: #222;
	background: #FE2;
	font-size: 0.5em;
	display: inline-block;
	padding: 3em 0.5em 0em 1.5em;
	margin-right: 1em;
}

h2, h3 {
	color: black;
}

body {
	background: #f2f2f2;
}

footer {
	border-top: solid gray 1px;
	text-align: center;
}
footer > a {
	white-space: nowrap;
}


</style>

<!-- 
:https://creativecommons.org/publicdomain/zero/1.0/
Changelog:/changelog
Compliance Tests:https://github.com/promises-aplus/promises-tests
Credits:/credits
Differences from Promises/A:/differences-from-promises-a
GitHub organization:https://github.com/promises-aplus
Implementations:/implementations
MutationObserver:https://dom.spec.whatwg.org/#interface-mutationobserver
Promises/A proposal:http://wiki.commonjs.org/wiki/Promises/A
Specification:/
execution context:https://es5.github.io/#x10.3
process.nextTick:http://nodejs.org/api/process.html#process_process_nexttick_callback
setImmediate:https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html#processingmodel
setTimeout:https://html.spec.whatwg.org/multipage/webappapis.html#timers
the Promises/A+ organization:https://github.com/promises-aplus
-->
</head>

<body>


<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>Promises/A+ 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="https://github.com/promises-aplus">Promises/A+ organization</a>
による
<a href="https://promisesaplus.com/">Promises/A+ Promise Specification</a>
（バージョン 1.1.1, 2014-05-05）を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2016-04-10</time>
（公開：<time>2015-01-13</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<h1>Promises/A+</h1>

<div id="MAIN" style="display:none;">

<p><strong>
実装者による, 実装者のための，
信頼でき, 相互運用可能な，
JavaScript ~promiseのための~open標準。
</strong>
◎
An open standard for sound, interoperable JavaScript promises—by implementers, for implementers.
</p>

<main id="MAIN0">

	<section id="introduction">
<h2>序論</h2>

<p>
`~promise$は、非同期的~演算の最終的な結果を表現する。
~promiseとのやりとりは、主に，その `then^es ~methodを通して~~行われる
— それは、［
~promiseの最終的な値を受取る~callback
］, または／および［
~promiseを充足できなかったときに その`事由$を受取る~callback
］を登録する。
◎
A promise represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its then method, which registers callbacks to receive either a promise’s eventual value or the reason why the promise cannot be fulfilled.
</p>

<p>
この仕様は、 `then^es ~methodの挙動の詳細を与える
— それは、［
すべての［
Promises/A+ に適合する~promise実装
］が，それを提供することに依存できる
］ような，相互運用可能な基盤を提供する。
そのようなわけで、この仕様は ごく安定的と見なされるべきである。
新たに際どい事例が発見されれば，それに取り組むため、この仕様は
Promises/A+ organization により［
小さな, かつ後方互換な変更点
］で改訂されることもあり得るが、［
大きな, または後方互換でない変更点
］が統合されるのは、［
注意深く考察され, 議論が積み重ねられ, 試験された
］後に限られることになる。
◎
This specification details the behavior of the then method, providing an interoperable base which all Promises/A+ conformant promise implementations can be depended on to provide. As such, the specification should be considered very stable. Although the Promises/A+ organization may occasionally revise this specification with minor backward-compatible changes to address newly-discovered corner cases, we will integrate large or backward-incompatible changes only after careful consideration, discussion, and testing.
</p>

<p>
歴史的に， Promises/A+ は、早期の
<a href="http://wiki.commonjs.org/wiki/Promises/A">Promises/A 提案</a>
の挙動上の各~条項を明確化し、［
<em>事実的標準</em> とされている挙動を~coverする
］ために それを拡張し，また［
指定中にある／問題ある
］部分は切落としてきた。
◎
Historically, Promises/A+ clarifies the behavioral clauses of the earlier Promises/A proposal, extending it to cover de facto behaviors and omitting parts that are underspecified or problematic.
</p>

<p>
~~最終的に，中核の Promises/A+ 仕様は、どのように~promiseを
作成する／`充足する$／`却下する$
かについては 取り扱わず、代わりに，相互運用可能な `then^es ~methodを提供することに集中する。
姉妹~仕様における将来の成果が，これらの主題に触れることになるであろう。
◎
Finally, the core Promises/A+ specification does not deal with how to create, fulfill, or reject promises, choosing instead to focus on providing an interoperable then method. Future work in companion specifications may touch on these subjects.
</p>



	</section>
	<section id="terminology">
<h2 title="Terminology">1. 各種用語</h2>

<dl>
	<dt>`~promise@</dt>
	<dd>
`then^es ~methodを備える
~object／~function
であって，その挙動がこの仕様に適合するもの。
◎
“promise” is an object or function with a then method whose behavior conforms to this specification.
</dd>

	<dt>`~thenable@</dt>
	<dd>
`then^es ~methodを定義するような，
~object／~function
。
◎
“thenable” is an object or function that defines a then method.
</dd>

	<dt>`値@</dt>
	<dd>
任意の合法な JavaScript 値（ `undefined^es, `~thenable$, `~promise$も含む）。
◎
“value” is any legal JavaScript value (including undefined, a thenable, or a promise).
</dd>

	<dt>`例外@</dt>
	<dd>
`throw^c 文を利用して投出される`値$。
◎
“exception” is a value that is thrown using the throw statement.
</dd>

	<dt>`事由@</dt>
	<dd>
`~promise$がなぜ`却下され$たかを指示する`値$。
◎
“reason” is a value that indicates why a promise was rejected.
</dd>

</dl>

	</section>
	<section id="requirements">
<h2 title="Requirements">2. 要件</h2>



		<section id="promise-states">
<h3 title="Promise States">2.1 ~promiseの各種~状態</h3>

<p>
`~promise$は、［
`処理待ち@ ／
`充足済み@ ／
`却下済み@
］のいずれかの状態にあることが要求される。
~promiseは：
◎
A promise must be in one of three states: pending, fulfilled, or rejected.
</p>

<ul>
	<li>
<p>
`処理待ち$にあるときは：
◎
When pending, a promise:
</p>
		<ul>
			<li>
［
`充足済み$, `却下済み$
］いずれかの状態に遷移し得る。
◎
may transition to either the fulfilled or rejected state.
</li>
		</ul>
	</li>
	<li>
<p>
`充足済み$にあるときは：
◎
When fulfilled, a promise:
</p>
		<ul>
			<li>
他の状態に遷移しては~MUST_NOT。
◎
must not transition to any other state.
</li>
			<li>
`値$を持た~MUST。
この値は変化しては~MUST_NOT。
◎
must have a value, which must not change.
</li>
		</ul>
	</li>
	<li>
<p>
`却下済み$にあるときは：
◎
When rejected, a promise:
</p>
		<ul>
			<li>
他の状態に遷移しては~MUST_NOT。
◎
must not transition to any other state.
</li>
			<li>
`事由$を持た~MUST。
この事由は変化しては~MUST_NOT。
◎
must have a reason, which must not change.
</li>
		</ul>
	</li>
</ul>

<p>
ここで、
“変化しては~MUST_NOT”
とは、同一性について変異不可である（すなわち， <code>===</code> ）を意味する。
深い変異不可性を含意するものではない
【 ~objectであれば その~memberの同一性が保たれる必要はない 】
。
◎
Here, “must not change” means immutable identity (i.e. ===), but does not imply deep immutability.
</p>


<div class="trans-note">
<p >【
定義~補足：
】</p>

<dl>
	<dt>`充足する@（ fullfill ）</dt>
	<dd>
“`値$ %v で`~promise$ %promise を充足する” という句は、
%promise を`充足済み$状態に遷移させると同時に，
%promise の`値$を %v にすることを意味する。
</dd>

	<dt>`却下する@（ reject ）</dt>
	<dd>
“`事由$ %r で`~promise$ %promise を却下する” という句は、
%promise を`却下済み$状態に遷移させると同時に，
%promise の`事由$を %r にすることを意味する。
</dd>
</dl>
</div>


		</section>
		<section id="then-method">
<h3 title="The then Method">2.2 `then^es ~method</h3>

<p>
`~promise$は、［
その［
現在の／最終的な
］［
`値$, あるいは`事由$
］に~accessするための， `then^es ~method
］を提供し~MUST。
◎
A promise must provide a then method to access its current or eventual value or reason.
</p>

<p>
`~promise$ %promise の `then^es ~methodは、二個の引数を受容する：
◎
A promise’s then method accepts two arguments:
</p>

<pre class="language-js">
%promise.then(%onFulfilled, %onRejected)
</pre>


<ul>
	<li>
<p>
引数 %onFulfilled, %onRejected は，いずれも省略可能である：
◎
Both onFulfilled and onRejected are optional arguments:
</p>
		<ol>
			<li>
~functionでない %onFulfilled は無視され~MUST。
◎
If onFulfilled is not a function, it must be ignored.
</li>
			<li>
~functionでない %onRejected は無視され~MUST。
◎
If onRejected is not a function, it must be ignored.
</li>
		</ol>
	</li>
	<li>
<p>
%onFulfilled は、それが~functionであるならば：
◎
If onFulfilled is a function:
</p>
		<ol>
			<li>
%promise が`充足され$た後に，その 1 個目の引数に %promise の`値$を渡して ~callされ~MUST。
◎
it must be called after promise is fulfilled, with promise’s value as its first argument.
</li>
			<li>
%promise が`充足され$る前に~callされては~MUST_NOT。
◎
it must not be called before promise is fulfilled.
</li>
			<li>
複数回~callされては~MUST_NOT。
◎
it must not be called more than once.
</li>
		</ol>
	</li>
	<li>
<p>
%onRejected は、それが~functionであるならば：
◎
If onRejected is a function,
</p>
		<ol>
			<li>
%promise が`却下され$た後に、その 1 個目の引数に %promise の`事由$を渡して ~callされ~MUST。
◎
it must be called after promise is rejected, with promise’s reason as its first argument.
</li>
			<li>
%promise が`却下され$る前に~callされては~MUST_NOT。
◎
it must not be called before promise is rejected.
</li>
			<li>
複数回~callされては~MUST_NOT。
◎
it must not be called more than once.
</li>
		</ol>
	</li>
	<li>
%onFulfilled ／ %onRejected は、［
<a href="https://es5.github.io/#x10.3">実行文脈</a>
~stackが包含する~codeが，~platform~codeのみになる
］まで、~callされては~MUST_NOT。
<a href="#note-3.1">[注 3.1]</a>
◎
onFulfilled or onRejected must not be called until the execution context stack contains only platform code. [3.1].
</li>
	<li>
%onFulfilled ／ %onRejected は、
~functionとして（すなわち， `this^es 値を伴わずに）~callされ~MUST。
<a href="#note-3.2">[注 3.2]</a>
◎
onFulfilled and onRejected must be called as functions (i.e. with no this value). [3.2]
</li>
	<li>
<p>
同じ`~promise$上で， `then^es が複数回~callされることもあり得る
— その際には：
◎
then may be called multiple times on the same promise.
</p>
		<ol>
			<li>
%promise が［
`充足され$たとき／`充足済み$にあるとき
］は
⇒
渡された一連の %onFulfilled ~callbackは、それぞれの出自の `then^es が~callされた順序で実行され~MUST。
◎
If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their originating calls to then.
</li>
			<li>
%promise が［
`却下され$たとき／`却下済み$にあるとき
］は
⇒
渡された一連の %onRejected ~callbackは、それぞれの出自の `then^es が~callされた順序で実行され~MUST。
◎
If/when promise is rejected, all respective onRejected callbacks must execute in the order of their originating calls to then.
</li>
		</ol>
	</li>
	<li>
<p>
`then^es は`~promise$を返さ~MUST。
<a href="#note-3.3">[注 3.3]</a>
◎
then must return a promise [3.3].
</p>

<pre class="language-js">
%promise2 = %promise1.then(%onFulfilled, %onRejected);
</pre>

		<ol>
			<li>
%onFulfilled ／ %onRejected が`値$ %x を返したならば
⇒
<a href="#promise-resolution-procedure">~promiseの解決~手順</a>：
<code>[[Resolve]](%promise2, %x)</code>
を走らす。
◎
If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).
</li>
			<li>
%onFulfilled ／ %onRejected が
`例外$ %e を投出したならば
⇒
%promise2 は，`事由$ %e で`却下され$~MUST。
◎
If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.
</li>
			<li>
%onFulfilled は~functionでない, かつ
%promise1 が`充足され$たならば
⇒
%promise2 は， %promise1 の値と同じ値で`充足され$~MUST。
◎
If onFulfilled is not a function and promise1 is fulfilled, promise2 must be fulfilled with the same value as promise1.
</li>
			<li>
%onRejected は~functionでない, かつ
%promise1 が`却下され$たならば
⇒
%promise2 は，
%promise1 の`事由$と同じ値で`却下され$~MUST。
◎
If onRejected is not a function and promise1 is rejected, promise2 must be rejected with the same reason as promise1.
</li>
		</ol>
	</li>
</ul>



		</section>
		<section id="promise-resolution-procedure">
<h3 title="The Promise Resolution Procedure">2.3 ~promiseの解決~手順</h3>

<p>
<dfn>~promiseの解決~手順</dfn>
は、`~promise$, および`値$を入力にとる抽象~演算であり、
<span class="block"><code>[[Resolve]](%promise, %x)</code></span>
と表記される。
%x が`~thenable$であるならば、それは
%promise に %x の状態を取入れさせようと試みる
— %x が，少なくとも~promiseに似た何かであるかのように挙動する前提の下で。
~~他の場合、それは，値 %x で %promise を`充足する$。
◎
The promise resolution procedure is an abstract operation taking as input a promise and a value, which we denote as [[Resolve]](promise, x). If x is a thenable, it attempts to make promise adopt the state of x, under the assumption that x behaves at least somewhat like a promise. Otherwise, it fulfills promise with the value x.
</p>

<p>
この~thenableの扱いにより、~promise実装は，［
~thenableが Promises/A+ に準拠する `then^es ~methodを公開する
］限りにおいて，相互運用可能になる。
それはまた， Promises/A+ 実装が、不適合な実装を，適度な `then^es ~methodで “消化-” できるようにする。
◎
This treatment of thenables allows promise implementations to interoperate, as long as they expose a Promises/A+-compliant then method. It also allows Promises/A+ implementations to “assimilate” nonconformant implementations with reasonable then methods.
</p>

<p>
<code>[[Resolve]](%promise, %x)</code>
を走らすときは、次の手続きを遂行する：
◎
To run [[Resolve]](promise, x), perform the following steps:
</p>

<p class="trans-note">【
以下に現れる記号［
~LET （初期化-）, ~SET （代入）, ~IF, ~ELSE, ~RET（実行制御）, 等々
］の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照。
】</p>

<ol>
	<li>
%promise と %x が同じ~objectを指すならば
⇒
`事由$ `TypeError^es で %promise を`却下する$
◎
If promise and x refer to the same object, reject promise with a TypeError as the reason.
</li>
	<li>
<p>
~IF
%x は`~promise$である
⇒
その状態を取入れる
<a href="#note-3.4">[注 3.4]</a>
— すなわち， %x の状態に応じて：
◎
If x is a promise, adopt its state [3.4]:
</p>

<dl class="switch">
	<dt>`処理待ち$</dt>
	<dd>
%promise は、［
%x が`充足され$る／`却下され$る
］まで，`処理待ち$であり続け~MUST
— %x の状態が遷移したときは、遷移~~後の状態に応じて，下の対応する段を~~実行することになる。
◎
If x is pending, promise must remain pending until x is fulfilled or rejected.
</dd>

	<dt>`充足済み$</dt>
	<dd>
%x の`値$で %promise を`充足する$
◎
If/when x is fulfilled, fulfill promise with the same value.
</dd>

	<dt>`却下済み$</dt>
	<dd>
%x の`事由$で %promise を`却下する$
◎
If/when x is rejected, reject promise with the same reason.
</dd>
</dl>

	</li>
	<li>
<p>
~ELIF
%x は~object／~functionである：
◎
Otherwise, if x is an object or function,
</p>
		<ol>
			<li>
%then ~LET
<code>%x.`then^es</code>
<a href="#note-3.5">[注 3.5]</a>
◎
Let then be x.then. [3.5]
</li>
	<li>
~IF
前段で `then^es を取得するときに、`例外$ %e が投出された
⇒
`事由$ %e で %promise を`却下する$
◎
If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.
</li>
			<li>
<p>
~IF
%then は~functionである：
◎
↓</p>

				<ol>
					<li>
<p>
［
`this^es 値 ~SET %x
］の下で，次の二つの引数を渡して %then を~callする：
◎
If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where:
</p>
						<ul>
							<li>
1 個目の引数 %resolvePromise は、`値$ %y を伴って~callされたときに，
<code>[[Resolve]](%promise, %y)</code>
を走らす~functionである。
◎
If/when resolvePromise is called with a value y, run [[Resolve]](promise, y).
</li>
							<li>
2 個目の引数 %rejectPromise は、`事由$ %r を伴って~callされたときに，
%r で %promise を`却下する$~functionである。
◎
If/when rejectPromise is called with a reason r, reject promise with r.
</li>
							<li>
ただし、［
%resolvePromise, %rejectPromise
の両者, または いずれか
］が（合計で）複数回 ~callされたときは、初回の~callが~~優先され、以降の~callは無視される【何もしない】。
◎
If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.
</li>
						</ul>
					</li>
					<li>
<p>
~IF
%then の~callにより，`例外$ %e が投出された：
◎
If calling then throws an exception e,
</p>
						<ol>
							<li>
~IF
%resolvePromise, %rejectPromise いずれかは すでに~callされている
⇒
%e を無視する
◎
If resolvePromise or rejectPromise have been called, ignore it.
</li>
							<li>
~ELSE
⇒
`事由$ %e で %promise を`却下する$
◎
Otherwise, reject promise with e as the reason.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%x で %promise を`充足する$
◎
If then is not a function, fulfill promise with x.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%x で %promise を`充足する$
◎
If x is not an object or function, fulfill promise with x.
</li>
</ol>

<p>
`~promise$が，［［［
<code>[[Resolve]](%promise, thenable)</code>
の再帰的な性質により，最終的に
<code>[[Resolve]](%promise, thenable)</code>
が再び~callされることになる
］ような，循環的な`~thenable$の連鎖
］に関与するような`~thenable$
］で解決されたならば、上の~algoをなぞることは，無限~再帰をもたらすことになる。
実装には、要求されてはいないが，~such再帰を検出して,
<!-- informative -->
`事由$ `TypeError^es で %promise を`却下する$ことが奨励される。
<a href="#note-3.6">[注 3.6]</a>
◎
If a promise is resolved with a thenable that participates in a circular thenable chain, such that the recursive nature of [[Resolve]](promise, thenable) eventually causes [[Resolve]](promise, thenable) to be called again, following the above algorithm will lead to infinite recursion. Implementations are encouraged, but not required, to detect such recursion and reject promise with an informative TypeError as the reason. [3.6]
</p>



		</section>
	</section>
	<section id="notes">
<h2 title="Notes" data-cycling="a[href^='#note']">3. 注記</h2>

<ol>
	<li id="note-3.1">
ここでの
“~platform~code”
は、［
~engine／環境／~promise
］の実装~codeを意味する。
実施においては、この要件により，［
%onFulfilled ／ %onRejected
が，［
`then^es が~callされた~event-loopの~turn
］の後に，新鮮な~stackの下で，非同期的に実行される
］ことが確保される。
これは、
<a href="https://html.spec.whatwg.org/multipage/webappapis.html#timers"
>`setTimeout^c</a>
や
<a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html#processingmodel"
>`setImmediate^c</a>
などによる “~macro-task”
, あるいは
<a href="https://dom.spec.whatwg.org/#interface-mutationobserver"
>`MutationObserver^c</a>
や
<a href="http://nodejs.org/api/process.html#process_process_nexttick_callback"
>`process.nextTick^c</a>
などによる “~micro-task” の仕組みにより，実装し得る。
~promise実装は，~platform~codeと見なされるので、それ自身も［
中で~handlerが~callされるような，［
~taskを~scheduleする待行列や “~trampoline”
【<a href="https://en.wikipedia.org/wiki/Trampoline_%28computing%29">trampoline</a>】
］］を包含することもある。
◎
Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.
</li>
	<li id="note-3.2">
すなわち `this^es は、~strict~modeの下では，それらの内側では `undefined^es になり、~sloppy~mode【非~strict~mode】の下では，大域~objectになる。
◎
That is, in strict mode this will be undefined inside of them; in sloppy mode, it will be the global object.
</li>
	<li id="note-3.3">
実装は、
<code>%promise2 === %promise1</code>
を許容して~MAY
— 実装がすべての要件を満たす限りにおいて。
各~実装は、どの条件の下で
<code>%promise2 === %promise1</code>
になり得るかについて文書~化するべきである。
◎
Implementations may allow promise2 === promise1, provided the implementation meets all requirements. Each implementation should document whether it can produce promise2 === promise1 and under what conditions.
</li>
	<li id="note-3.4">
一般に、 %x が真の`~promise$であることは、現在の実装から来ているときにのみ，知り得る【？】。
この条項により、実装は，自身に固有の手段を利用して［
適合的が既知である~promise
］の状態を，取入れることが~~可能になる。
◎
Generally, it will only be known that x is a true promise if it comes from the current implementation. This clause allows the use of implementation-specific means to adopt the state of known-conformant promises.
</li>
	<li id="note-3.5">
この，［
まず
<code>%x.`then^es</code>
への参照を格納した上で，その参照を試験してから，その参照を~callする
］手順により、［
複数回にわたる
<code>%x.`then^es</code>
~propertyへの~access
］は避けられる。
~such用心は、［
各~取得の合間に値が変化し得るような，~accessor~propertyの一面
］における一貫性を確保するために，重要になる。
◎
This procedure of first storing a reference to x.then, then testing that reference, and then calling that reference, avoids multiple accesses to the x.then property. Such precautions are important for ensuring consistency in the face of an accessor property, whose value could change between retrievals.
</li>
	<li id="note-3.6">
実装は、`~thenable$が成す連鎖の深さに恣意的な上限を設定するべき<em>でない</em>
— 再帰は，その恣意的な上限を超えて無限になるものと見做すべきである。
`TypeError^es をもたらすのは、真の循環に限られるべきである
— 別個の~thenableからなる無限~連鎖に遭遇したときの無限再帰は、正しい挙動である。
◎
Implementations should not set arbitrary limits on the depth of thenable chains, and assume that beyond that arbitrary limit the recursion will be infinite. Only true cycles should lead to a TypeError; if an infinite chain of distinct thenables is encountered, recursing forever is the correct behavior.
</li>
</ol>

	</section>

</main></div><!-- MAIN -->

<hr>

<small>
<a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>
To the extent possible under law,
<a href="https://github.com/promises-aplus">the Promises/A+ organization</a>
has waived all copyright and related or neighboring rights to
Promises/A+ Promise Specification.
This work is published from: United States.
</small>


<footer>
<a href="https://promisesaplus.com/"
	title="Specification"
>原文仕様</a>
　
<a href="https://promisesaplus.com/changelog"
	title="Changelog"
>変更ログ</a>
　
<a href="https://promisesaplus.com/credits"
	title="Credits"
>著作者一覧</a>
　
<a href="https://promisesaplus.com/differences-from-promises-a"
	title="Differences from Promises/A"
>Promises/A との差異</a>
　
<a href="https://promisesaplus.com/implementations"
	title="Implementations"
>各種 実装</a>
　
<a href="https://github.com/promises-aplus/promises-tests"
	title="Compliance Tests"
>準拠 試験</a>
<br />
<a href="https://github.com/promises-aplus"
>GitHub organization</a>
</footer>

</body></html>
